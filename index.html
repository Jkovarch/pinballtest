<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PinbALL or Nothing</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a12;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        #gameCanvas {
            display: block;
            background: #0a0a12;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            font-family: 'Arial', sans-serif;
            color: #fff;
            z-index: 20;
            pointer-events: none;
        }

        .hud-item {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid;
        }

        #scoreDisplay {
            border-color: #ff00ff;
        }

        #ballDisplay {
            border-color: #00ffff;
        }

        /* Instructions overlay */
        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-family: 'Arial', sans-serif;
            color: #fff;
            z-index: 30;
            pointer-events: none;
            opacity: 0.9;
            transition: opacity 0.5s;
        }

        #instructions.hidden {
            opacity: 0;
        }

        #instructions h1 {
            font-size: 2.5em;
            color: #ff00ff;
            margin-bottom: 20px;
            letter-spacing: 5px;
        }

        #instructions p {
            font-size: 1em;
            margin: 10px 0;
            color: #00ffff;
        }

        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 12px;
            border-radius: 5px;
            margin: 0 5px;
            border: 1px solid rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div id="scoreDisplay" class="hud-item">SCORE: <span id="score">0</span></div>
        <div id="ballDisplay" class="hud-item">BALLS: <span id="balls">3</span></div>
    </div>

    <!-- Instructions -->
    <div id="instructions">
        <h1>PinbALL or Nothing</h1>
        <p>Keyboard: <span class="key">Z</span> Left <span class="key">/</span> Right <span class="key">SPACE</span> Launch <span class="key">V</span> Confirm</p>
        <p>Touch: Left/Right sides for flippers</p>
        <p>Swipe down to pull and release launcher</p>
    </div>

    <script>
    // ============================================
    // PinbALL or Nothing - Based on Lu1ky Pinball
    // ============================================

    'use strict';

    // === FIREBASE SETUP ===
    // REPLACE with your web app config from Firebase Console > Project Settings > Your apps > Web app
    const firebaseConfig = {
        apiKey: "AIzaSyA04wso_wktEiTj8eH4nUwoLM7tYFvn_9Y",
        authDomain: "pinballornothing.firebaseapp.com",
        databaseURL: "https://pinballornothing-default-rtdb.firebaseio.com",
        projectId: "pinballornothing",
        storageBucket: "pinballornothing.firebasestorage.app",
        messagingSenderId: "649858808879",
        appId: "1:649858808879:web:0df7f8ea752d77f8551ada",
        measurementId: "G-6JRG1PK20E"
    };

    let firebaseReady = false;
    let db = null;
    try {
        firebase.initializeApp(firebaseConfig);
        db = firebase.database();
        firebaseReady = true;
    } catch (e) {
        console.warn('Firebase init failed:', e);
    }

    function submitScoreToFirebase(initials, scoreVal, tableLevel) {
        if (!firebaseReady || !db) return;
        try {
            db.ref('scores').push().set({
                initials: initials,
                score: scoreVal,
                date: new Date().toISOString(),
                maxTableLevel: tableLevel || 0
            });
        } catch (e) { console.warn('Firebase submit failed:', e); }
    }

    function loadOnlineScores(callback) {
        if (!firebaseReady || !db) { callback([]); return; }
        try {
            db.ref('scores')
              .orderByChild('score')
              .limitToLast(10)
              .once('value', (snapshot) => {
                  const scores = [];
                  snapshot.forEach(child => { scores.push(child.val()); });
                  scores.sort((a, b) => b.score - a.score);
                  callback(scores);
              }, () => callback([]));
        } catch (e) { callback([]); }
    }

    // === SOUND SYSTEM ===
    const SndCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    const soundBuffers = {};
    let audioInitialized = false;
    let lastWallSoundTime = 0;

    function initAudio() {
        if (audioCtx) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            return;
        }
        try {
            audioCtx = new SndCtx();
            audioInitialized = true;
            loadAllSounds();
        } catch (e) { console.warn('Audio init failed:', e); }
    }

    async function loadSound(name, url) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            soundBuffers[name] = await audioCtx.decodeAudioData(arrayBuffer);
        } catch (e) {}
    }

    async function loadAllSounds() {
        const sounds = [
            'Flipper1', 'Flipper2', 'Flipper3',
            'PopBumper1', 'PopBumper2', 'PopBumper3', 'PopBumper4', 'PopBumper5',
            'SlingShot1', 'SlingShot2', 'SlingShot3',
            'Wall1', 'Wall2', 'Wall3',
            'Plunge', 'BallDrain', 'BallSave', 'TableLevelUp'
        ];
        for (const s of sounds) {
            await loadSound(s, 'PinballSounds/' + s + '.mp3');
        }
    }

    function playSound(name) {
        if (!audioCtx || !soundBuffers[name] || soundMuted) return;
        try {
            const source = audioCtx.createBufferSource();
            source.buffer = soundBuffers[name];
            source.connect(audioCtx.destination);
            source.start(0);
        } catch (e) {}
    }

    function playRandomSound(prefix, count) {
        playSound(prefix + (Math.floor(Math.random() * count) + 1));
    }

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // === CONSTANTS ===
    const TABLE_WIDTH = 400;
    const TABLE_HEIGHT = 700;
    const CENTER_X = TABLE_WIDTH / 2 - 20;
    const BALL_RADIUS = 7;
    const WALL_RADIUS = 5;
    const DOME_RADIUS = 150;
    const FLIPPER_RADIUS = 10;
    const FLIPPER_SEGMENTS = 45;
    const FLIPPER_SPREAD = 55;
    const FLIPPER_Y = TABLE_HEIGHT - 60;
    const FLIPPER_Y_ACTUAL = FLIPPER_Y + 14;
    const FLIPPER_CENTER = CENTER_X - BALL_RADIUS - WALL_RADIUS;
    const SHOOTER_X = CENTER_X + DOME_RADIUS - BALL_RADIUS;
    const SHOOTER_Y = TABLE_HEIGHT - 60;
    const RESTITUTION = 1.3;
    const BUMPER_RESTITUTION = 1.7;
    const PHYSICS_SUBSTEPS = 9;
    const GRAVITY = 0.0017;

    const TOP_LANE_Y = 55;
    const TOP_LANE_PINS = [CENTER_X - 60, CENTER_X - 20, CENTER_X + 20, CENTER_X + 60];

    const TYPE_WALL = 0;
    const TYPE_BUMPER = 1;
    const TYPE_DROP_TARGET = 2;

    const SPOT_TARGET_POSITIONS = [
        {x: 300, y: 280}, {x: 300, y: 320}, {x: 300, y: 360}, {x: 300, y: 400}
    ];
    const BUMPER_COLORS = ['#ff0000', '#00ff00', '#0088ff', '#ff00ff', '#ff8800'];

    const SAUCER_X = CENTER_X;
    const SAUCER_Y = 200;
    const SAUCER_RADIUS = 10;
    const SAUCER_CAPTURE_SPEED = 0.15;
    const SAUCER_HOLD_TIME = 120;
    const SAUCER_THRESHOLDS = [100, 500, 1000, 2000, 5000, 10000, 25000, 50000];

    const DROP_COLORS = ['#ffff00', '#ff8800', '#ff4400', '#ff00ff', '#00ffff', '#ffffff'];
    const SPOT_DARK = ['#660000', '#663300', '#666600', '#006633', '#003366', '#666666'];
    const SPOT_LIT = ['#ff3300', '#ff8800', '#ffff00', '#00ff66', '#0088ff', '#ffffff'];

    // Table 2 Constants
    const TYPE_STANDUP_TARGET = 3;
    const TYPE_RAMP = 4;
    const TYPE_SPINNER = 5;
    const TYPE_SCOOP = 6;

    // Ramp entry position (top left)
    const RAMP_ENTRY_X = 55;
    const RAMP_ENTRY_Y = 180;
    const RAMP_EXIT_X = 110;
    const RAMP_EXIT_Y = 130;

    // Drop target blocking ramp
    const RAMP_DROP_X = 55;
    const RAMP_DROP_Y = 200;

    // Spinner at ramp exit
    const SPINNER_X = 120;
    const SPINNER_Y = 145;
    const SPINNER_RADIUS = 12;

    // Scoop position (right side - moved left to avoid shooter lane)
    const SCOOP_X = 280;
    const SCOOP_Y = 350;
    const SCOOP_RADIUS = 15;

    // Pop bumper positions for table 2
    // Moved lower bumpers outward to prevent ball getting stuck between them
    const TABLE2_BUMPER_POSITIONS = [
        {x: CENTER_X - 50, y: 280},
        {x: CENTER_X + 50, y: 280},
        {x: CENTER_X, y: 320}
    ];

    // Standup target bank positions
    const STANDUP_LEFT_POSITIONS = [
        {x: 50, y: 420}, {x: 50, y: 450}, {x: 50, y: 480}
    ];
    const STANDUP_RIGHT_POSITIONS = [
        {x: 290, y: 420}, {x: 290, y: 450}, {x: 290, y: 480}
    ];

    const LANE_LIGHT_Y = FLIPPER_Y - 35;
    const LANE_LIGHT_POSITIONS = [
        {x: 42, y: LANE_LIGHT_Y}, {x: 73, y: LANE_LIGHT_Y},
        {x: 263, y: LANE_LIGHT_Y}, {x: 295, y: LANE_LIGHT_Y}
    ];

    // Game states
    const STATE_WELCOME = 0;
    const STATE_PLAYING = 1;
    const STATE_GAME_OVER = 2;
    const STATE_MENU = 3;
    const STATE_LEADERBOARD = 4;
    const STATE_STATS = 5;
    const STATE_CHOOSE_MODIFIER = 6;

    const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const MAX_HIGH_SCORES = 10;

    // === GAME STATE ===
    let objects = [];
    let score = 0;
    let ballCount = 3;
    let frame = 0;
    let gameStarted = false;
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;

    let flipperLeft = 1;
    let flipperRight = 1;
    let keys = { z: false, x: false, c: false, v: false, m: false };
    let soundMuted = false;
    try { soundMuted = localStorage.getItem('neonPinballMuted') === 'true'; } catch (e) {}

    let swipeStartY = 0;
    let isSwiping = false;

    let dropTargets = [];

    let topLaneLights = [false, false, false];
    let ballInTopLane = false;
    let flipperLeftWasPressed = false;
    let flipperRightWasPressed = false;

    let spotTargets = [false, false, false, false];
    let spotCompletions = 0;
    let scoreMultiplier = 1;

    let laneLights = [false, false, false, false];

    let saucerActive = false;
    let saucerTimer = 0;
    let saucerLevel = 0;
    let targetLevel = 0;
    let maxTableLevel = 0;

    // UI state
    let gameState = STATE_WELCOME;
    let gameOverTimer = 0;
    let finalScore = 0;
    let isNewHighScore = false;
    let initialsChars = [0, 0, 0];
    let currentInitialPos = 0;
    let prevMenuKeys = { z: false, x: false };
    let prevVKey = false;
    let prevPlungeKey = false;
    let highScores = [];
    let onlineScores = [];
    let showOnlineScores = false;
    let particles = [];
    let overlayTap = null;
    let levelUpTimer = 0;
    let saucerLevelUpDone = false;
    let ballSaveAvailable = true;
    let ballStartScore = 0;
    let ballSaveTimer = 0;
    let extraBallTimer = 0;

    // Session state
    let sessionInitials = null;
    let playerStats = null;

    // Modifier system
    let targetValueMultiplier = 1;
    let allOrNothingActive = false;
    let allOrNothingScoreBackup = 0;
    let extraBallSave3 = false;
    let modifierChoiceLeft = null;
    let modifierChoiceRight = null;
    let modifierScreenTimer = 0;
    let ballsLost = 0;
    let safetyPinActive = false;

    // === MULTI-TABLE SYSTEM ===
    let currentTable = 1;  // 1 = original table, 2 = advanced table
    let tableTransitioning = false;
    let tableTransitionTimer = 0;

    // Table 2 specific elements
    let rampDropTargetActive = true;  // Drop target blocking the ramp
    let spinnerAngle = 0;
    let spinnerSpeed = 0;  // Degrees per frame for continuous spin
    let spinnerHits = 0;
    let spinnerActive = false;  // Whether spinner just activated (triggers drop target reset)

    // Scoop and ball lock system
    let scoopBallLocked = false;
    let lockedBallX = 0;
    let lockedBallY = 0;
    let multiballActive = false;
    let balls = [];  // For multiball - array of ball objects
    let multiballReady = false;  // Ramp+spinner combo activates multiball launch

    // Standup target banks (2 banks of 3 targets each)
    let standupBankLeft = [false, false, false];
    let standupBankRight = [false, false, false];
    let standupBankLeftCompletions = 0;
    let standupBankRightCompletions = 0;

    // Table 2 object references
    let table2DropTarget = null;
    let table2Spinner = null;
    let table2Scoop = null;
    let table2PopBumpers = [];
    let table2StandupTargetsLeft = [];
    let table2StandupTargetsRight = [];
    let table2RampWalls = [];

    // === HIGH SCORE FUNCTIONS ===
    function loadHighScores() {
        try {
            const saved = localStorage.getItem('neonPinballHighScores');
            if (saved) highScores = JSON.parse(saved);
        } catch (e) { highScores = []; }
    }

    function saveHighScores() {
        try {
            localStorage.setItem('neonPinballHighScores', JSON.stringify(highScores));
        } catch (e) {}
    }

    function checkHighScore(s) {
        if (s <= 0) return false;
        if (highScores.length < MAX_HIGH_SCORES) return true;
        return s > highScores[highScores.length - 1].score;
    }

    function addHighScore(initials, s, tableLevel) {
        highScores.push({ initials: initials, score: s, date: new Date().toISOString(), maxTableLevel: tableLevel || 0 });
        highScores.sort((a, b) => b.score - a.score);
        if (highScores.length > MAX_HIGH_SCORES) highScores = highScores.slice(0, MAX_HIGH_SCORES);
        saveHighScores();
    }

    function loadSavedInitials() {
        try {
            const saved = localStorage.getItem('neonPinballInitials');
            if (saved) {
                const parsed = JSON.parse(saved);
                if (Array.isArray(parsed) && parsed.length === 3) return parsed;
            }
        } catch (e) {}
        return [0, 0, 0];
    }

    function saveSavedInitials(chars) {
        try {
            localStorage.setItem('neonPinballInitials', JSON.stringify(chars));
        } catch (e) {}
    }

    // === PLAYER STATS ===
    function defaultStats() {
        return { allTargetsCleared: 0, colorBumperHits: 0, saucerCaptures: 0, extraBallsEarned: 0, maxMultiplier: 1, gamesPlayed: 0, totalScore: 0, modPicks: {} };
    }

    function loadPlayerStats(initials) {
        try {
            const saved = localStorage.getItem('neonPinballStats_' + initials);
            if (saved) return JSON.parse(saved);
        } catch (e) {}
        return defaultStats();
    }

    function savePlayerStats(initials, stats) {
        try {
            localStorage.setItem('neonPinballStats_' + initials, JSON.stringify(stats));
        } catch (e) {}
    }

    function trackStat(key, value) {
        if (!sessionInitials || !playerStats) return;
        if (key === 'maxMultiplier') {
            playerStats.maxMultiplier = Math.max(playerStats.maxMultiplier || 1, value);
        } else {
            playerStats[key] = (playerStats[key] || 0) + (value || 1);
        }
        savePlayerStats(sessionInitials, playerStats);
    }

    // === MODIFIERS ===
    const MODIFIERS = [
        { id: 'double_mult', name: 'DOUBLE', name2: 'MULTIPLIER', desc: 'Doubles your current multiplier' },
        { id: 'upgrade_table', name: 'UPGRADE', name2: 'TABLE', desc: 'Level up the table' },
        { id: 'ball_save_3', name: 'EXTRA BALL', name2: 'SAVE', desc: 'Ball save on last ball' },
        { id: 'light_outlanes', name: 'LIGHT', name2: 'OUTLANES', desc: 'Light outlane lanes' },
        { id: 'extra_ball', name: 'EXTRA', name2: 'BALL', desc: 'Gain one extra ball' },
        { id: 'double_down', name: 'DOUBLE', name2: 'DOWN', desc: 'Targets 2x, lose 1 ball', minBalls: 2 },
        { id: 'double_double', name: 'DOUBLE', name2: 'DOUBLE DOWN', desc: 'Targets 2x, score 2x, last ball', minBalls: 2 },
        { id: 'all_or_nothing', name: 'ALL OR', name2: 'NOTHING', desc: 'Saucer = 3x, drain = 0' },
        { id: 'mulligan', name: 'MULLIGAN', name2: '', desc: 'Get that ball back, keep score', condition: () => ballsLost === 1 && score < 150 },
        { id: 'practice_shot', name: 'PRACTICE', name2: 'SHOT', desc: 'Get that ball back, keep score', condition: () => ballsLost === 1 && score < 50 },
        { id: 'rewind', name: 'REWIND', name2: '', desc: 'Back to 3 balls, score resets to 0', condition: () => ballsLost === 1 && score < 300 },
        { id: 'buy_in', name: 'BUY IN', name2: '-1000', desc: 'Pay 1000 for an extra ball', condition: () => score > 1000 && score <= 5000 },
        { id: 'pay_up', name: 'PAY UP', name2: '-5000', desc: 'Pay 5000 for an extra ball', condition: () => score > 5000 },
        { id: 'income_tax', name: 'INCOME', name2: 'TAX', desc: 'Pay 25% score for ball save', condition: () => score > 1000 },
        { id: 'tax_avoidance', name: 'TAX', name2: 'AVOIDANCE', desc: 'Pay 25% score for extra ball', condition: () => score > 5000 },
        { id: 'all_in', name: 'ALL IN', name2: '', desc: 'Pay 100% score, back to 3 balls', condition: () => score > 5000 },
        { id: 'safety_pin', name: 'SAFETY', name2: 'PIN', desc: 'Center pin gets bigger for 1 ball', condition: () => score < 1000 }
    ];

    function generateModifierChoices() {
        const valid = MODIFIERS.filter(m => {
            if (m.minBalls && ballCount < m.minBalls) return false;
            if (m.condition && !m.condition()) return false;
            return true;
        });
        const shuffled = valid.slice().sort(() => Math.random() - 0.5);
        modifierChoiceLeft = shuffled[0] || null;
        modifierChoiceRight = shuffled[1] || null;
        if (modifierChoiceLeft && modifierChoiceRight && modifierChoiceLeft.id === modifierChoiceRight.id && valid.length > 1) {
            modifierChoiceRight = shuffled.find(m => m.id !== modifierChoiceLeft.id) || shuffled[1];
        }
        modifierScreenTimer = 0;
    }

    function applyModifier(mod) {
        if (!mod) return;
        switch (mod.id) {
            case 'double_mult':
                scoreMultiplier *= 2;
                trackStat('maxMultiplier', scoreMultiplier);
                break;
            case 'upgrade_table':
                targetLevel++;
                maxTableLevel = Math.max(maxTableLevel, targetLevel);
                dropTargets.forEach(dt => { dt.active = true; });
                break;
            case 'ball_save_3':
                extraBallSave3 = true;
                break;
            case 'light_outlanes':
                laneLights[0] = true;
                laneLights[3] = true;
                if (laneLights.every(l => l)) {
                    ballCount++;
                    document.getElementById('balls').textContent = ballCount;
                    trackStat('extraBallsEarned');
                    laneLights = [false, false, false, false];
                    extraBallTimer = 120;
                    createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 2, 40);
                    createFirework(TABLE_WIDTH / 2, TABLE_HEIGHT / 3);
                }
                break;
            case 'extra_ball':
                ballCount++;
                document.getElementById('balls').textContent = ballCount;
                break;
            case 'double_down':
                targetValueMultiplier *= 2;
                ballCount--;
                document.getElementById('balls').textContent = ballCount;
                break;
            case 'double_double':
                targetValueMultiplier *= 2;
                score *= 2;
                document.getElementById('score').textContent = score;
                ballCount = 1;
                document.getElementById('balls').textContent = ballCount;
                break;
            case 'all_or_nothing':
                allOrNothingActive = true;
                allOrNothingScoreBackup = score;
                break;
            case 'mulligan':
            case 'practice_shot':
                ballCount++;
                document.getElementById('balls').textContent = ballCount;
                break;
            case 'rewind':
                ballCount = 3;
                score = 0;
                document.getElementById('score').textContent = score;
                document.getElementById('balls').textContent = ballCount;
                break;
            case 'buy_in':
                score -= 1000;
                ballCount++;
                document.getElementById('score').textContent = score;
                document.getElementById('balls').textContent = ballCount;
                break;
            case 'pay_up':
                score -= 5000;
                ballCount++;
                document.getElementById('score').textContent = score;
                document.getElementById('balls').textContent = ballCount;
                break;
            case 'income_tax':
                score -= Math.floor(score * 0.25);
                document.getElementById('score').textContent = score;
                ballSaveAvailable = true;
                break;
            case 'tax_avoidance':
                score -= Math.floor(score * 0.25);
                ballCount++;
                document.getElementById('score').textContent = score;
                document.getElementById('balls').textContent = ballCount;
                break;
            case 'all_in':
                score = 0;
                ballCount = 3;
                document.getElementById('score').textContent = score;
                document.getElementById('balls').textContent = ballCount;
                break;
            case 'safety_pin':
                safetyPinActive = true;
                for (const o of objects) {
                    if (o.isCenterPin) {
                        o.radius = 18;  // Bigger center pin below flippers
                        o.color = '#ffff00';  // Yellow to show active
                        break;
                    }
                }
                break;
        }
        // Track modifier pick count
        if (sessionInitials && playerStats) {
            if (!playerStats.modPicks) playerStats.modPicks = {};
            playerStats.modPicks[mod.id] = (playerStats.modPicks[mod.id] || 0) + 1;
            savePlayerStats(sessionInitials, playerStats);
        }
    }

    // === PARTICLES ===
    function createParticles(x, y, count) {
        const colors = ['#ff00ff', '#00ffff', '#ffff00', '#ff0000', '#00ff00', '#ff8800'];
        for (let i = 0; i < count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5 - 1,
                life: 40 + Math.random() * 80,
                color: colors[Math.floor(Math.random() * colors.length)],
                radius: 1 + Math.random() * 3
            });
        }
    }

    function createFirework(x, y) {
        const colors = ['#ff00ff', '#00ffff', '#ffff00', '#ff0000', '#00ff00'];
        for (let i = 0; i < 20; i++) {
            const angle = (Math.PI * 2 * i) / 20;
            const speed = 1 + Math.random() * 2;
            particles.push({
                x: x, y: y,
                vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                life: 30 + Math.random() * 40,
                color: colors[Math.floor(Math.random() * colors.length)],
                radius: 1 + Math.random() * 2
            });
        }
    }

    // === RESET GAME ===
    function resetGame() {
        score = 0;
        ballCount = 3;
        scoreMultiplier = 1;
        spotCompletions = 0;
        spotTargets = [false, false, false, false];
        laneLights = [false, false, false, false];
        saucerActive = false;
        saucerTimer = 0;
        saucerLevel = 0;
        targetLevel = 0;
        maxTableLevel = 0;
        topLaneLights = [false, false, false];
        particles = [];
        ballSaveAvailable = true;
        ballStartScore = 0;
        ballSaveTimer = 0;
        levelUpTimer = 0;
        extraBallTimer = 0;
        saucerLevelUpDone = false;
        targetValueMultiplier = 1;
        allOrNothingActive = false;
        allOrNothingScoreBackup = 0;
        extraBallSave3 = false;
        modifierChoiceLeft = null;
        modifierChoiceRight = null;
        ballsLost = 0;
        safetyPinActive = false;

        // Reset multi-table state
        currentTable = 1;
        tableTransitioning = false;
        tableTransitionTimer = 0;
        rampDropTargetActive = true;
        spinnerAngle = 0;
        spinnerSpeed = 0;
        spinnerHits = 0;
        spinnerActive = false;
        scoopBallLocked = false;
        multiballActive = false;
        multiballReady = false;
        balls = [];
        standupBankLeft = [false, false, false];
        standupBankRight = [false, false, false];
        standupBankLeftCompletions = 0;
        standupBankRightCompletions = 0;

        // Rebuild table 1
        buildTable();

        for (const obj of objects) {
            if (obj.isCenterPin) {
                obj.radius = safetyPinActive ? 18 : 5;
                obj.color = safetyPinActive ? '#ffff00' : '#00ffff';
                break;
            }
        }

        const ball = objects[0];
        ball.x = SHOOTER_X;
        ball.y = SHOOTER_Y - 20;
        ball.vx = 0;
        ball.vy = 0;

        const goStart = 1 + FLIPPER_SEGMENTS * 2;
        for (let si = 0; si < FLIPPER_SEGMENTS; si++) {
            const seg = objects[goStart + si];
            if (seg && seg.isShooter) {
                seg.y = SHOOTER_Y + si;
                seg.vy = 0;
            }
        }

        dropTargets.forEach(dt => { dt.active = true; });

        document.getElementById('score').textContent = score;
        document.getElementById('balls').textContent = ballCount;
        document.getElementById('instructions').classList.remove('hidden');

        gameStarted = false;
        gameState = STATE_PLAYING;
        keys.z = false;
        keys.x = false;
        keys.c = false;
        keys.v = false;
    }

    function setupNewBall() {
        // Safety: if modifier reduced ballCount to 0, go to game over
        if (ballCount <= 0) {
            finalScore = score;
            isNewHighScore = checkHighScore(score);
            gameState = STATE_GAME_OVER;
            gameOverTimer = 90;
            trackStat('gamesPlayed');
            trackStat('totalScore', finalScore);
            if (isNewHighScore && sessionInitials) {
                addHighScore(sessionInitials, finalScore, maxTableLevel);
                submitScoreToFirebase(sessionInitials, finalScore, maxTableLevel);
            }
            return;
        }
        const ball = objects[0];
        ball.x = CENTER_X + DOME_RADIUS - BALL_RADIUS;
        ball.y = SHOOTER_Y - 20;
        ball.vx = 0;
        ball.vy = 0;
        const rstStart = 1 + FLIPPER_SEGMENTS * 2;
        for (let si = 0; si < FLIPPER_SEGMENTS; si++) {
            const seg = objects[rstStart + si];
            if (seg && seg.isShooter) {
                seg.y = SHOOTER_Y + si;
                seg.vy = 0;
            }
        }
        // Reset ball save for new ball
        ballSaveAvailable = true;
        // Extra ball save on last ball (ball 3 modifier)
        if (extraBallSave3 && ballCount === 1) {
            ballSaveAvailable = true;
        }
        // Reset Safety Pin modifier (only lasts 1 ball)
        if (safetyPinActive) {
            safetyPinActive = false;
            for (const obj of objects) {
                if (obj.isCenterPin) {
                    obj.radius = 5;  // Back to normal size
                    obj.color = '#00ffff';  // Back to cyan
                    break;
                }
            }
        }
        ballStartScore = score;
        // Reset key states to prevent stuck flippers from menu selection
        keys.z = false;
        keys.x = false;
        keys.c = false;
        gameState = STATE_PLAYING;
    }

    // === OBJECT CREATION ===
    function createObject(x, y, type = TYPE_WALL, radius = WALL_RADIUS) {
        objects.push({
            x: x, y: y, type: type, radius: radius,
            vx: 0, vy: 0, bounce: 0,
            color: type === TYPE_BUMPER ? '#ff00ff' : type === TYPE_DROP_TARGET ? '#ffff00' : '#00ffff'
        });
        return objects[objects.length - 1];
    }

    // === BUILD TABLE ===
    function buildTable() {
        objects = [];
        dropTargets = [];

        const ball = createObject(CENTER_X + DOME_RADIUS - BALL_RADIUS, SHOOTER_Y - 20);
        ball.radius = BALL_RADIUS;
        ball.color = '#ffffff';
        ball.isBall = true;

        for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
            createObject(0, 0, TYPE_WALL, FLIPPER_RADIUS - i / 6);
            createObject(0, 0, TYPE_WALL, FLIPPER_RADIUS - i / 6);
        }

        for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
            const shooter = createObject(CENTER_X + DOME_RADIUS - BALL_RADIUS, TABLE_HEIGHT - 10 + i, TYPE_WALL, 5);
            shooter.isShooter = true;
            shooter.shooterIndex = i;
        }

        const DOME_BOTH = DOME_RADIUS + WALL_RADIUS;

        // Center pin below flippers (drain blocker for Safety Pin modifier)
        const centerPin = createObject(FLIPPER_CENTER, FLIPPER_Y + 25, TYPE_WALL, safetyPinActive ? 18 : 5);
        centerPin.isCenterPin = true;
        centerPin.color = safetyPinActive ? '#ffff00' : '#00ffff';  // Yellow when active, cyan when normal

        for (let side = 0; side < 2; side++) {
            const dir = side * 2 - 1;

            for (let i = 0; i < 90; i++) {
                createObject(CENTER_X + dir * DOME_BOTH, TABLE_HEIGHT - 7 * i);
            }

            for (let i = 0; i < 55; i++) {
                createObject(
                    CENTER_X + dir * DOME_BOTH * Math.cos(i / 35),
                    DOME_BOTH - DOME_BOTH * Math.sin(i / 35)
                );
            }

            for (let i = 0; i < 12; i++) {
                createObject(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55), FLIPPER_Y - 50 - i * 7);
            }

            for (let i = 0; i < 19; i++) {
                createObject(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55 - i * 3), FLIPPER_Y - 50 + i * 3);
            }

            const slingInnerX = FLIPPER_CENTER + dir * FLIPPER_SPREAD;
            const slingOuterX = FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 25);
            const slingTopY = FLIPPER_Y - 120;
            const slingBottomY = FLIPPER_Y - 70;
            const slingBottomInnerY = slingBottomY + 25;

            for (let i = 0; i <= 7; i++) {
                const t = i / 7;
                createObject(slingOuterX, slingTopY + t * (slingBottomY - slingTopY));
            }

            for (let i = 0; i <= 12; i++) {
                const t = i / 12;
                const sObj = createObject(
                    slingOuterX + (slingInnerX - slingOuterX) * t,
                    slingTopY + (slingBottomInnerY - slingTopY) * t,
                    TYPE_BUMPER, 4
                );
                sObj.isSlingshot = true;
            }

            for (let i = 0; i <= 5; i++) {
                const t = i / 5;
                createObject(
                    slingOuterX + (slingInnerX - slingOuterX) * t,
                    slingBottomY + (slingBottomInnerY - slingBottomY) * t
                );
            }
        }

        const bumperY = 160;
        const centerBumper = createObject(CENTER_X, bumperY, TYPE_BUMPER, 12);
        centerBumper.isHighValue = true;
        centerBumper.isCenterBumper = true;
        centerBumper.color = '#ff0000';

        createObject(CENTER_X - 45, bumperY - 45, TYPE_BUMPER, 24);
        createObject(CENTER_X + 45, bumperY - 45, TYPE_BUMPER, 24);
        createObject(CENTER_X - 45, bumperY + 93, TYPE_BUMPER, 24);
        createObject(CENTER_X + 45, bumperY + 93, TYPE_BUMPER, 24);

        createObject(FLIPPER_CENTER - 150, DOME_RADIUS + 90, TYPE_BUMPER, 25);
        createObject(FLIPPER_CENTER + 162, DOME_RADIUS + 90, TYPE_BUMPER, 25);

        createObject(FLIPPER_CENTER - 130, 470, TYPE_BUMPER, 12);
        createObject(FLIPPER_CENTER + 130, 470, TYPE_BUMPER, 12);

        const gridStartY = bumperY + 170;
        for (let side = 0; side < 2; side++) {
            const dir = side * 2 - 1;
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const pin = createObject(CENTER_X + col * 26 * dir, gridStartY - row * 28, TYPE_BUMPER, 4);
                    if (col === 0 && row === 1) { pin.isHighValue = true; pin.color = '#ff0000'; }
                }
            }
        }

        const dtBaseX = 42;
        const dtBaseY = 300;
        for (let row = 0; row < 4; row++) {
            for (let j = 0; j < 2; j++) {
                const dt = createObject(dtBaseX, dtBaseY + row * 32 + j * 11, TYPE_DROP_TARGET, 5);
                dt.isDropTarget = true;
                dt.active = true;
                dt.dropGroup = row;
                dt.color = '#ffff00';
                dropTargets.push(dt);
            }
        }

        for (let i = 0; i < 4; i++) {
            createObject(TOP_LANE_PINS[i], TOP_LANE_Y, TYPE_WALL, 5);
        }

        const shooterWallX = CENTER_X + DOME_RADIUS - BALL_RADIUS * 2 - WALL_RADIUS;
        for (let i = 0; i < 65; i++) {
            createObject(shooterWallX, TABLE_HEIGHT - 7 * i);
        }
    }

    // === BUILD TABLE 2 (Advanced Table) ===
    function buildTable2() {
        // Save ball state before rebuilding
        const oldBall = objects[0];
        const savedBallState = {
            x: SHOOTER_X,  // Reset to shooter position
            y: SHOOTER_Y - 20,
            vx: 0,
            vy: 0
        };

        objects = [];
        dropTargets = [];
        table2PopBumpers = [];
        table2StandupTargetsLeft = [];
        table2StandupTargetsRight = [];
        table2RampWalls = [];

        // Create ball
        const ball = createObject(savedBallState.x, savedBallState.y);
        ball.radius = BALL_RADIUS;
        ball.color = '#ffffff';
        ball.isBall = true;
        ball.vx = savedBallState.vx;
        ball.vy = savedBallState.vy;

        // Create flippers (same as table 1)
        for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
            createObject(0, 0, TYPE_WALL, FLIPPER_RADIUS - i / 6);
            createObject(0, 0, TYPE_WALL, FLIPPER_RADIUS - i / 6);
        }

        // Create shooter lane
        for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
            const shooter = createObject(CENTER_X + DOME_RADIUS - BALL_RADIUS, TABLE_HEIGHT - 10 + i, TYPE_WALL, 5);
            shooter.isShooter = true;
            shooter.shooterIndex = i;
        }

        const DOME_BOTH = DOME_RADIUS + WALL_RADIUS;

        // Center pin below flippers (drain blocker for Safety Pin modifier)
        const centerPin = createObject(FLIPPER_CENTER, FLIPPER_Y + 25, TYPE_WALL, safetyPinActive ? 18 : 5);
        centerPin.isCenterPin = true;
        centerPin.color = safetyPinActive ? '#ffff00' : '#00ffff';  // Yellow when active, cyan when normal

        // Create walls, outlanes, and slingshots (same structure as table 1)
        for (let side = 0; side < 2; side++) {
            const dir = side * 2 - 1;

            // Side walls
            for (let i = 0; i < 90; i++) {
                createObject(CENTER_X + dir * DOME_BOTH, TABLE_HEIGHT - 7 * i);
            }

            // Dome curve
            for (let i = 0; i < 55; i++) {
                createObject(
                    CENTER_X + dir * DOME_BOTH * Math.cos(i / 35),
                    DOME_BOTH - DOME_BOTH * Math.sin(i / 35)
                );
            }

            // Outlane walls
            for (let i = 0; i < 12; i++) {
                createObject(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55), FLIPPER_Y - 50 - i * 7);
            }

            for (let i = 0; i < 19; i++) {
                createObject(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55 - i * 3), FLIPPER_Y - 50 + i * 3);
            }

            // Slingshots
            const slingInnerX = FLIPPER_CENTER + dir * FLIPPER_SPREAD;
            const slingOuterX = FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 25);
            const slingTopY = FLIPPER_Y - 120;
            const slingBottomY = FLIPPER_Y - 70;
            const slingBottomInnerY = slingBottomY + 25;

            for (let i = 0; i <= 7; i++) {
                const t = i / 7;
                createObject(slingOuterX, slingTopY + t * (slingBottomY - slingTopY));
            }

            for (let i = 0; i <= 12; i++) {
                const t = i / 12;
                const sObj = createObject(
                    slingOuterX + (slingInnerX - slingOuterX) * t,
                    slingTopY + (slingBottomInnerY - slingTopY) * t,
                    TYPE_BUMPER, 4
                );
                sObj.isSlingshot = true;
            }

            for (let i = 0; i <= 5; i++) {
                const t = i / 5;
                createObject(
                    slingOuterX + (slingInnerX - slingOuterX) * t,
                    slingBottomY + (slingBottomInnerY - slingBottomY) * t
                );
            }
        }

        // === TABLE 2 UNIQUE FEATURES ===

        // Top lane pins (same position)
        for (let i = 0; i < 4; i++) {
            createObject(TOP_LANE_PINS[i], TOP_LANE_Y, TYPE_WALL, 5);
        }

        // Shooter wall
        const shooterWallX = CENTER_X + DOME_RADIUS - BALL_RADIUS * 2 - WALL_RADIUS;
        for (let i = 0; i < 65; i++) {
            createObject(shooterWallX, TABLE_HEIGHT - 7 * i);
        }

        // --- LOOP RAMP (Top Left) ---
        // Ramp entrance walls (curved path from left side to top)
        const rampEntranceX = 45;
        const rampEntranceY = 220;

        // Left wall of ramp entrance
        for (let i = 0; i < 15; i++) {
            const wall = createObject(rampEntranceX - 15, rampEntranceY - i * 8, TYPE_WALL, 4);
            wall.isRampWall = true;
            table2RampWalls.push(wall);
        }

        // Right wall of ramp entrance curving to exit
        for (let i = 0; i < 20; i++) {
            const angle = (Math.PI / 2) * (i / 20);
            const wall = createObject(
                rampEntranceX + 25 + 30 * Math.sin(angle),
                rampEntranceY - 20 - 30 * (1 - Math.cos(angle)),
                TYPE_WALL, 4
            );
            wall.isRampWall = true;
            table2RampWalls.push(wall);
        }

        // Ramp exit (curves back down toward playfield)
        for (let i = 0; i < 12; i++) {
            const wall = createObject(
                rampEntranceX + 55 + i * 5,
                rampEntranceY - 60 + i * 3,
                TYPE_WALL, 4
            );
            wall.isRampWall = true;
            table2RampWalls.push(wall);
        }

        // --- DROP TARGET blocking ramp ---
        // Made smaller (radius 5) to prevent ball getting stuck behind
        table2DropTarget = createObject(rampEntranceX + 5, rampEntranceY + 10, TYPE_DROP_TARGET, 5);
        table2DropTarget.isRampDropTarget = true;
        table2DropTarget.active = rampDropTargetActive;
        table2DropTarget.color = '#ff8800';

        // Second drop target segment for wider blocking
        const dt2 = createObject(rampEntranceX + 18, rampEntranceY + 10, TYPE_DROP_TARGET, 5);
        dt2.isRampDropTarget = true;
        dt2.active = rampDropTargetActive;
        dt2.color = '#ff8800';
        dropTargets.push(table2DropTarget);
        dropTargets.push(dt2);

        // Back wall behind drop targets to prevent ball getting stuck
        for (let i = 0; i < 5; i++) {
            createObject(rampEntranceX - 5, rampEntranceY + 5 + i * 5, TYPE_WALL, 3);
        }

        // --- SPINNER at ramp exit ---
        table2Spinner = createObject(SPINNER_X, SPINNER_Y, TYPE_SPINNER, SPINNER_RADIUS);
        table2Spinner.isSpinner = true;
        table2Spinner.color = '#00ff88';
        table2Spinner.spinAngle = 0;

        // --- 3 SMALL POP BUMPERS ---
        for (let i = 0; i < TABLE2_BUMPER_POSITIONS.length; i++) {
            const pos = TABLE2_BUMPER_POSITIONS[i];
            const bumper = createObject(pos.x, pos.y, TYPE_BUMPER, 15);
            bumper.isSmallBumper = true;
            bumper.color = BUMPER_COLORS[i % BUMPER_COLORS.length];
            table2PopBumpers.push(bumper);
        }

        // Center small bumper (like table 1's safety pin target)
        const centerBumper = createObject(CENTER_X, 360, TYPE_BUMPER, 12);
        centerBumper.isHighValue = true;
        centerBumper.isCenterBumper = true;
        centerBumper.color = '#ff0000';

        // --- SCOOP (Ball Lock) ---
        table2Scoop = createObject(SCOOP_X, SCOOP_Y, TYPE_SCOOP, SCOOP_RADIUS);
        table2Scoop.isScoop = true;
        table2Scoop.color = '#8800ff';

        // Scoop entrance guide walls
        for (let i = 0; i < 8; i++) {
            createObject(SCOOP_X - 20, SCOOP_Y - 30 + i * 4, TYPE_WALL, 3);
            createObject(SCOOP_X + 20, SCOOP_Y - 30 + i * 4, TYPE_WALL, 3);
        }

        // --- STANDUP TARGET BANKS ---
        // Left bank (3 targets)
        for (let i = 0; i < STANDUP_LEFT_POSITIONS.length; i++) {
            const pos = STANDUP_LEFT_POSITIONS[i];
            const target = createObject(pos.x, pos.y, TYPE_STANDUP_TARGET, 6);
            target.isStandupTarget = true;
            target.standupBank = 'left';
            target.standupIndex = i;
            target.color = standupBankLeft[i] ? '#00ff00' : '#006600';
            table2StandupTargetsLeft.push(target);
        }

        // Right bank (3 targets)
        for (let i = 0; i < STANDUP_RIGHT_POSITIONS.length; i++) {
            const pos = STANDUP_RIGHT_POSITIONS[i];
            const target = createObject(pos.x, pos.y, TYPE_STANDUP_TARGET, 6);
            target.isStandupTarget = true;
            target.standupBank = 'right';
            target.standupIndex = i;
            target.color = standupBankRight[i] ? '#00ff00' : '#006600';
            table2StandupTargetsRight.push(target);
        }

        // Add some guide rails near standup targets
        for (let i = 0; i < 5; i++) {
            createObject(65, 410 + i * 20, TYPE_WALL, 3);
            createObject(275, 410 + i * 20, TYPE_WALL, 3);
        }

        // Small pop bumpers above outlanes (same as Table 1)
        const smallBumperLeft = createObject(FLIPPER_CENTER - 130, 470, TYPE_BUMPER, 12);
        smallBumperLeft.color = '#ff8800';
        const smallBumperRight = createObject(FLIPPER_CENTER + 130, 470, TYPE_BUMPER, 12);
        smallBumperRight.color = '#ff8800';

        // Lane lights area (same positions as table 1)
        // These are handled in rendering, not as objects
    }

    // === TRANSITION TO TABLE 2 ===
    function transitionToTable2() {
        tableTransitioning = true;
        tableTransitionTimer = 120;  // 2 seconds of transition animation
        currentTable = 2;

        // Reset table 2 specific states
        rampDropTargetActive = true;
        spinnerAngle = 0;
        spinnerSpeed = 0;
        spinnerHits = 0;
        spinnerActive = false;
        scoopBallLocked = false;
        multiballReady = false;
        standupBankLeft = [false, false, false];
        standupBankRight = [false, false, false];

        // Build the new table
        buildTable2();

        createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 2, 60);
        createFirework(TABLE_WIDTH / 4, TABLE_HEIGHT / 4);
        createFirework(TABLE_WIDTH * 3 / 4, TABLE_HEIGHT / 4);
    }

    // === OVERLAY BUTTON HIT TEST ===
    function checkOverlayButtonHit(gameX, gameY) {
        if (gameState === STATE_WELCOME) {
            const boxW = 44;
            const boxGap = 12;
            const totalW = boxW * 3 + boxGap * 2;
            const startLetterX = (TABLE_WIDTH - totalW) / 2;
            const boxY = TABLE_HEIGHT / 2 - 40;
            const boxH = 52;
            // Up arrows
            if (gameY >= boxY - 25 && gameY <= boxY) {
                const activeBoxX = startLetterX + currentInitialPos * (boxW + boxGap);
                if (gameX >= activeBoxX && gameX <= activeBoxX + boxW) return 'scroll_up';
            }
            // Down arrows
            if (gameY >= boxY + boxH && gameY <= boxY + boxH + 25) {
                const activeBoxX = startLetterX + currentInitialPos * (boxW + boxGap);
                if (gameX >= activeBoxX && gameX <= activeBoxX + boxW) return 'scroll_down';
            }
            // BACK button
            const backBtnX = TABLE_WIDTH / 2 - 80;
            const btnRowY = boxY + boxH + 22;
            if (gameX >= backBtnX && gameX <= backBtnX + 68 && gameY >= btnRowY && gameY <= btnRowY + 36) {
                return 'back';
            }
            // CONFIRM button
            const cfmBtnX = TABLE_WIDTH / 2 + 12;
            if (gameX >= cfmBtnX && gameX <= cfmBtnX + 68 && gameY >= btnRowY && gameY <= btnRowY + 36) {
                return 'confirm';
            }
            // START button
            const startBtnY = btnRowY + 36 + 18;
            const startBtnX = TABLE_WIDTH / 2 - 75;
            if (gameX >= startBtnX && gameX <= startBtnX + 150 && gameY >= startBtnY && gameY <= startBtnY + 50) {
                return 'start';
            }
        }

        if (gameState === STATE_MENU) {
            const mbY = TABLE_HEIGHT / 2 + 10;
            const mbW = 130;
            const mbH = 50;
            const mGap = 16;
            const leftBX = TABLE_WIDTH / 2 - mbW - mGap / 2;
            const rightBX = TABLE_WIDTH / 2 + mGap / 2;
            if (gameY >= mbY && gameY <= mbY + mbH) {
                if (gameX >= leftBX && gameX <= leftBX + mbW) return 'scores';
                if (gameX >= rightBX && gameX <= rightBX + mbW) return 'play';
            }
            // Change player button
            const cpW = 160;
            const cpX = TABLE_WIDTH / 2 - cpW / 2;
            const cpY = mbY + mbH + 50;
            if (gameX >= cpX && gameX <= cpX + cpW && gameY >= cpY && gameY <= cpY + 35) {
                return 'change_player';
            }
            // Stats button
            const stBtnW = 100;
            const stBtnX = TABLE_WIDTH / 2 - stBtnW / 2;
            const stBtnY = cpY + 45;
            if (gameX >= stBtnX && gameX <= stBtnX + stBtnW && gameY >= stBtnY && gameY <= stBtnY + 35) {
                return 'stats';
            }
        }

        if (gameState === STATE_LEADERBOARD) {
            // BACK button
            const lbBX = TABLE_WIDTH / 2 - 60;
            const lbBY = TABLE_HEIGHT - 75;
            if (gameX >= lbBX && gameX <= lbBX + 120 && gameY >= lbBY && gameY <= lbBY + 40) {
                return 'back_to_menu';
            }
            // LOCAL/ONLINE toggle
            const togX = TABLE_WIDTH / 2 - 80;
            const togY = 88;
            if (gameX >= togX && gameX <= togX + 160 && gameY >= togY && gameY <= togY + 25) {
                return 'toggle_scores';
            }
        }

        if (gameState === STATE_STATS) {
            const bkX = TABLE_WIDTH / 2 - 60;
            const bkY = TABLE_HEIGHT - 75;
            if (gameX >= bkX && gameX <= bkX + 120 && gameY >= bkY && gameY <= bkY + 40) {
                return 'back_to_menu';
            }
        }

        if (gameState === STATE_CHOOSE_MODIFIER) {
            const boxW = 160;
            const boxH = 180;
            const boxY = TABLE_HEIGHT / 2 - boxH / 2;
            const leftBoxX = TABLE_WIDTH / 2 - boxW - 10;
            const rightBoxX = TABLE_WIDTH / 2 + 10;
            if (gameX >= leftBoxX && gameX <= leftBoxX + boxW && gameY >= boxY && gameY <= boxY + boxH) {
                return 'mod_left';
            }
            if (gameX >= rightBoxX && gameX <= rightBoxX + boxW && gameY >= boxY && gameY <= boxY + boxH) {
                return 'mod_right';
            }
        }

        return null;
    }

    // === PHYSICS UPDATE ===
    function updatePhysics() {
        const ball = objects[0];

        const leftJustPressed = keys.z && !flipperLeftWasPressed;
        const rightJustPressed = keys.x && !flipperRightWasPressed;

        if (leftJustPressed) playRandomSound('Flipper', 3);
        if (rightJustPressed) playRandomSound('Flipper', 3);

        if (leftJustPressed && topLaneLights.some(l => l)) {
            topLaneLights = [topLaneLights[1], topLaneLights[2], topLaneLights[0]];
        }
        if (rightJustPressed && topLaneLights.some(l => l)) {
            topLaneLights = [topLaneLights[2], topLaneLights[0], topLaneLights[1]];
        }

        flipperLeftWasPressed = keys.z;
        flipperRightWasPressed = keys.x;

        for (let substep = 0; substep < PHYSICS_SUBSTEPS; substep++) {

            flipperLeft = Math.max(-1, Math.min(1, flipperLeft + (keys.z ? -0.07 : 0.05)));
            flipperRight = Math.max(-1, Math.min(1, flipperRight + (keys.x ? -0.07 : 0.05)));

            for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
                const leftObj = objects[1 + i];
                const prevLeftX = leftObj.x;
                const prevLeftY = leftObj.y;
                leftObj.x = FLIPPER_CENTER + (-1) * (FLIPPER_SPREAD - i * Math.cos(flipperLeft / 2));
                leftObj.y = FLIPPER_Y_ACTUAL + i * Math.sin(flipperLeft / 2);
                leftObj.vx = leftObj.x - prevLeftX;
                leftObj.vy = leftObj.y - prevLeftY;
                leftObj.radius = FLIPPER_RADIUS - i / 7;

                const rightObj = objects[1 + FLIPPER_SEGMENTS + i];
                const prevRightX = rightObj.x;
                const prevRightY = rightObj.y;
                rightObj.x = FLIPPER_CENTER + (1) * (FLIPPER_SPREAD - i * Math.cos(flipperRight / 2));
                rightObj.y = FLIPPER_Y_ACTUAL + i * Math.sin(flipperRight / 2);
                rightObj.vx = rightObj.x - prevRightX;
                rightObj.vy = rightObj.y - prevRightY;
                rightObj.radius = FLIPPER_RADIUS - i / 7;
            }

            const shooterStart = 1 + FLIPPER_SEGMENTS * 2;
            const SHOOTER_MAX = TABLE_HEIGHT - 10;
            for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
                const shooter = objects[shooterStart + i];
                if (shooter && shooter.isShooter) {
                    const prevY = shooter.y;
                    shooter.y = Math.min(SHOOTER_MAX + i,
                        shooter.y + (shooter.vy = keys.c ? 0.05 :
                        Math.sin(frame) / 99 + (SHOOTER_Y + i - shooter.y) / 19));
                    shooter.vy = shooter.y - prevY;
                }
            }

            if (saucerActive) {
                ball.x = SAUCER_X;
                ball.y = SAUCER_Y;
                ball.vx = 0;
                ball.vy = 0;
                continue;
            }

            ball.x += ball.vx;
            ball.y += ball.vy;
            ball.vy += GRAVITY;

            const inLaneZone = Math.abs(ball.y - TOP_LANE_Y) < BALL_RADIUS + 15;
            if (inLaneZone && !ballInTopLane) {
                ballInTopLane = true;
                for (let g = 0; g < 3; g++) {
                    const gapLeft = TOP_LANE_PINS[g] + 6;
                    const gapRight = TOP_LANE_PINS[g + 1] - 6;
                    if (ball.x > gapLeft && ball.x < gapRight) {
                        topLaneLights[g] = true;
                        if (topLaneLights.every(l => l)) {
                            score += 50 * scoreMultiplier * targetValueMultiplier;
                            document.getElementById('score').textContent = score;
                            topLaneLights = [false, false, false];
                        }
                        break;
                    }
                }
            } else if (!inLaneZone) {
                ballInTopLane = false;
            }

            for (let i = 0; i < 4; i++) {
                if (!spotTargets[i]) {
                    const stx = SPOT_TARGET_POSITIONS[i].x;
                    const sty = SPOT_TARGET_POSITIONS[i].y;
                    const sdx = ball.x - stx;
                    const sdy = ball.y - sty;
                    if (Math.sqrt(sdx * sdx + sdy * sdy) < BALL_RADIUS + 8) {
                        spotTargets[i] = true;
                        score += (3 + targetLevel * 2) * scoreMultiplier * targetValueMultiplier;
                        document.getElementById('score').textContent = score;
                        if (spotTargets.every(s => s)) {
                            spotCompletions++;
                            scoreMultiplier *= 2;
                            trackStat('maxMultiplier', scoreMultiplier);
                            spotTargets = [false, false, false, false];
                        }
                    }
                }
            }

            for (let i = 0; i < 4; i++) {
                if (!laneLights[i]) {
                    const llx = LANE_LIGHT_POSITIONS[i].x;
                    const lly = LANE_LIGHT_POSITIONS[i].y;
                    const ldx = ball.x - llx;
                    const ldy = ball.y - lly;
                    if (Math.abs(ldx) < 18 && Math.abs(ldy) < 18) {
                        laneLights[i] = true;
                        if (laneLights.every(l => l)) {
                            ballCount++;
                            document.getElementById('balls').textContent = ballCount;
                            trackStat('extraBallsEarned');
                            laneLights = [false, false, false, false];
                            extraBallTimer = 120;
                            createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 2, 40);
                            createFirework(TABLE_WIDTH / 2, TABLE_HEIGHT / 3);
                        }
                    }
                }
            }

            // Check if ball is lost
            if (ball.y > TABLE_HEIGHT + 50) {
                if (ballSaveAvailable && ((score - ballStartScore) < 20 || (extraBallSave3 && ballCount === 1))) {
                    // Ball save!
                    ballSaveAvailable = false;
                    ballSaveTimer = 120;
                    playSound('BallSave');
                    ball.x = SHOOTER_X;
                    ball.y = SHOOTER_Y - 20;
                    ball.vx = 0;
                    ball.vy = 0;
                    const bsStart = 1 + FLIPPER_SEGMENTS * 2;
                    for (let si = 0; si < FLIPPER_SEGMENTS; si++) {
                        const seg = objects[bsStart + si];
                        if (seg && seg.isShooter) {
                            seg.y = SHOOTER_Y + si;
                            seg.vy = 0;
                        }
                    }
                    createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 2, 30);
                } else if (ballCount > 0) {
                    ballCount--;
                    ballsLost++;
                    document.getElementById('balls').textContent = ballCount;
                    playSound('BallDrain');

                    if (ballCount > 0) {
                        // Handle All or Nothing drain penalty
                        if (allOrNothingActive) {
                            score = 0;
                            document.getElementById('score').textContent = score;
                            allOrNothingActive = false;
                        }
                        // Move ball off-screen to prevent re-triggering in substep loop
                        ball.x = -100;
                        ball.y = -100;
                        ball.vx = 0;
                        ball.vy = 0;
                        // Show modifier choice before next ball
                        generateModifierChoices();
                        gameState = STATE_CHOOSE_MODIFIER;
                    } else {
                        // Game over
                        if (allOrNothingActive) {
                            score = 0;
                            document.getElementById('score').textContent = score;
                            allOrNothingActive = false;
                        }
                        finalScore = score;
                        isNewHighScore = checkHighScore(score);
                        gameState = STATE_GAME_OVER;
                        gameOverTimer = 90;
                        ball.x = -100;
                        ball.y = -100;
                        ball.vx = 0;
                        ball.vy = 0;
                        // Track stats
                        trackStat('gamesPlayed');
                        trackStat('totalScore', finalScore);
                        // Auto-submit score with session initials
                        if (isNewHighScore && sessionInitials) {
                            addHighScore(sessionInitials, finalScore, maxTableLevel);
                            submitScoreToFirebase(sessionInitials, finalScore, maxTableLevel);
                            createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 3, 60);
                        }
                    }
                }
            }

            // Collision detection
            for (let i = 1; i < objects.length; i++) {
                const obj = objects[i];
                if (obj.isDropTarget && !obj.active) continue;
                // Skip scoop in normal collision - handled separately for ball lock
                if (obj.isScoop) continue;
                // Skip standup targets for now - disabled for testing
                if (obj.isStandupTarget) continue;

                const dx = ball.x - obj.x;
                const dy = ball.y - obj.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = ball.radius + obj.radius;

                if (dist < minDist && dist > 0) {
                    const relVx = obj.vx - ball.vx;
                    const relVy = obj.vy - ball.vy;
                    const dotProduct = relVx * dx + relVy * dy;

                    if (dotProduct > 0 && !(obj.type && !ball.vx)) {
                        const overlap = minDist - dist;
                        ball.x += (dx / dist) * overlap;
                        ball.y += (dy / dist) * overlap;

                        const tangent = dist * dist / (relVy * dx - relVx * dy);
                        let restitution;

                        if (obj.isDropTarget && obj.active && !obj.bounce) {
                            obj.bounce = 10;

                            // Table 2: Ramp drop target special handling
                            if (currentTable === 2 && obj.isRampDropTarget) {
                                // Deactivate ramp drop targets
                                dropTargets.forEach(dt => {
                                    if (dt.isRampDropTarget) { dt.active = false; dt.bounce = 10; }
                                });
                                rampDropTargetActive = false;
                                score += 25 * scoreMultiplier * targetValueMultiplier;
                                document.getElementById('score').textContent = score;
                                createParticles(obj.x, obj.y, 15);
                            } else {
                                // Normal drop target handling (Table 1)
                                dropTargets.forEach(dt => {
                                    if (dt.dropGroup === obj.dropGroup) { dt.active = false; dt.bounce = 10; }
                                });
                                score += (5 + targetLevel * 3) * scoreMultiplier * targetValueMultiplier;
                                document.getElementById('score').textContent = score;
                                if (dropTargets.every(dt => !dt.active)) {
                                    score += (25 + targetLevel * 10) * scoreMultiplier * targetValueMultiplier;
                                    document.getElementById('score').textContent = score;
                                    trackStat('allTargetsCleared');
                                    setTimeout(() => { dropTargets.forEach(dt => { dt.active = true; }); }, 1500);
                                }
                            }
                            restitution = BUMPER_RESTITUTION;
                        }

                        // Table 2: Standup target handling
                        if (currentTable === 2 && obj.isStandupTarget && !obj.bounce) {
                            obj.bounce = 15;
                            const bank = obj.standupBank;
                            const idx = obj.standupIndex;

                            if (bank === 'left' && !standupBankLeft[idx]) {
                                standupBankLeft[idx] = true;
                                obj.color = '#00ff00';
                                score += 10 * scoreMultiplier * targetValueMultiplier;
                                document.getElementById('score').textContent = score;
                                playRandomSound('PopBumper', 5);
                                createParticles(obj.x, obj.y, 10);

                                // Check for bank completion
                                if (standupBankLeft.every(t => t)) {
                                    scoreMultiplier++;
                                    standupBankLeftCompletions++;
                                    trackStat('maxMultiplier', scoreMultiplier);
                                    score += 50 * scoreMultiplier * targetValueMultiplier;
                                    document.getElementById('score').textContent = score;
                                    createParticles(70, 450, 30);
                                    createFirework(70, 420);
                                    // Reset bank after delay
                                    setTimeout(() => {
                                        standupBankLeft = [false, false, false];
                                        table2StandupTargetsLeft.forEach(t => { t.color = '#006600'; });
                                    }, 2000);
                                }
                            } else if (bank === 'right' && !standupBankRight[idx]) {
                                standupBankRight[idx] = true;
                                obj.color = '#00ff00';
                                score += 10 * scoreMultiplier * targetValueMultiplier;
                                document.getElementById('score').textContent = score;
                                playRandomSound('PopBumper', 5);
                                createParticles(obj.x, obj.y, 10);

                                // Check for bank completion
                                if (standupBankRight.every(t => t)) {
                                    scoreMultiplier++;
                                    standupBankRightCompletions++;
                                    trackStat('maxMultiplier', scoreMultiplier);
                                    score += 50 * scoreMultiplier * targetValueMultiplier;
                                    document.getElementById('score').textContent = score;
                                    createParticles(330, 450, 30);
                                    createFirework(330, 420);
                                    // Reset bank after delay
                                    setTimeout(() => {
                                        standupBankRight = [false, false, false];
                                        table2StandupTargetsRight.forEach(t => { t.color = '#006600'; });
                                    }, 2000);
                                }
                            }
                            restitution = BUMPER_RESTITUTION;
                        }

                        // Table 2: Spinner handling
                        if (currentTable === 2 && obj.isSpinner && !obj.bounce) {
                            obj.bounce = 5;
                            spinnerHits++;
                            // Add spin speed based on ball velocity for realistic spinning
                            const ballSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                            spinnerSpeed += ballSpeed * 10;  // Harder hit = more spins
                            score += 5 * scoreMultiplier * targetValueMultiplier;
                            document.getElementById('score').textContent = score;
                            playRandomSound('SlingShot', 3);

                            // Spinner reactivates the drop target after enough hits
                            if (spinnerHits >= 3) {
                                spinnerActive = true;
                                spinnerHits = 0;
                                // Reactivate ramp drop target
                                rampDropTargetActive = true;
                                dropTargets.forEach(dt => {
                                    if (dt.isRampDropTarget) { dt.active = true; }
                                });
                                createParticles(SPINNER_X, SPINNER_Y, 20);

                                // If ball is locked in scoop, prepare for multiball
                                if (scoopBallLocked) {
                                    multiballReady = true;
                                    createFirework(SCOOP_X, SCOOP_Y);
                                }
                            }
                            restitution = RESTITUTION;
                        } else if (obj.type === TYPE_BUMPER && !obj.bounce) {
                            obj.bounce = 10;
                            // Sound: slingshot vs pop bumper
                            if (obj.isSlingshot) {
                                playRandomSound('SlingShot', 3);
                            } else {
                                playRandomSound('PopBumper', 5);
                                if (obj.isCenterBumper) trackStat('colorBumperHits');
                            }
                            if (obj.y < FLIPPER_Y - 80) {
                                if (obj.isHighValue) { score += 15 * scoreMultiplier * targetValueMultiplier; }
                                else { score += 3 * scoreMultiplier * targetValueMultiplier; }
                                document.getElementById('score').textContent = score;
                            }
                            restitution = BUMPER_RESTITUTION;
                        } else {
                            restitution = RESTITUTION;
                            // Wall sound with cooldown - only on hard impacts
                            const impactSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                            if (!obj.isShooter && i > FLIPPER_SEGMENTS * 2 && audioCtx && impactSpeed > 2) {
                                const now = audioCtx.currentTime;
                                if (now - lastWallSoundTime > 0.25) {
                                    lastWallSoundTime = now;
                                    playRandomSound('Wall', 3);
                                }
                            }
                        }

                        ball.vx += (relVx + dy / tangent) * restitution;
                        ball.vy += (relVy - dx / tangent) * restitution;
                        gameStarted = true;
                    }
                }
                if (obj.bounce > 0) { obj.bounce--; }
            }

            // Saucer capture check
            if (!saucerActive) {
                const sdx = ball.x - SAUCER_X;
                const sdy = ball.y - SAUCER_Y;
                const sDist = Math.sqrt(sdx * sdx + sdy * sdy);
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (sDist < SAUCER_RADIUS + BALL_RADIUS) {
                    if (speed < SAUCER_CAPTURE_SPEED) {
                        saucerActive = true;
                        trackStat('saucerCaptures');
                        saucerTimer = SAUCER_HOLD_TIME;
                        saucerLevelUpDone = false;
                        ball.x = SAUCER_X;
                        ball.y = SAUCER_Y;
                        ball.vx = 0;
                        ball.vy = 0;
                    } else if (sDist > 0) {
                        ball.vx += (sdx / sDist) * 0.003;
                        ball.vy += (sdy / sDist) * 0.003;
                    }
                }
            }

            // Table 2: Scoop (ball lock) check
            if (currentTable === 2 && !scoopBallLocked && !multiballActive) {
                const scx = ball.x - SCOOP_X;
                const scy = ball.y - SCOOP_Y;
                const scDist = Math.sqrt(scx * scx + scy * scy);
                const scSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);

                if (scDist < SCOOP_RADIUS + BALL_RADIUS) {
                    if (scSpeed < 0.2) {
                        // Ball captured in scoop - lock it!
                        scoopBallLocked = true;
                        lockedBallX = ball.x;
                        lockedBallY = ball.y;
                        score += 100 * scoreMultiplier * targetValueMultiplier;
                        document.getElementById('score').textContent = score;
                        createParticles(SCOOP_X, SCOOP_Y, 25);
                        playSound('TableLevelUp');

                        // Spawn a new ball in the shooter lane
                        ball.x = SHOOTER_X;
                        ball.y = SHOOTER_Y - 20;
                        ball.vx = 0;
                        ball.vy = 0;

                        // Reset shooter position
                        const rstStart = 1 + FLIPPER_SEGMENTS * 2;
                        for (let si = 0; si < FLIPPER_SEGMENTS; si++) {
                            const seg = objects[rstStart + si];
                            if (seg && seg.isShooter) {
                                seg.y = SHOOTER_Y + si;
                                seg.vy = 0;
                            }
                        }
                    } else if (scDist > 0) {
                        // Gentle attraction toward scoop
                        ball.vx -= (scx / scDist) * 0.002;
                        ball.vy -= (scy / scDist) * 0.002;
                    }
                }
            }

            // Table 2: Multiball launch check
            if (currentTable === 2 && scoopBallLocked && multiballReady && !multiballActive) {
                // Launch multiball!
                multiballActive = true;
                multiballReady = false;
                score += 500 * scoreMultiplier * targetValueMultiplier;
                document.getElementById('score').textContent = score;

                // Release locked ball from scoop with upward velocity
                // We'll simulate this by creating a second ball effect
                // For simplicity, we'll just eject the current ball faster
                // and give bonus points
                scoopBallLocked = false;

                createParticles(SCOOP_X, SCOOP_Y, 40);
                createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 2, 40);
                createFirework(TABLE_WIDTH / 2, TABLE_HEIGHT / 3);
                createFirework(TABLE_WIDTH / 4, TABLE_HEIGHT / 3);
                createFirework(TABLE_WIDTH * 3 / 4, TABLE_HEIGHT / 3);
                playSound('TableLevelUp');

                // Multiball mode: double scoring for a period
                const originalMultiplier = scoreMultiplier;
                scoreMultiplier *= 2;

                // End multiball after 30 seconds
                setTimeout(() => {
                    multiballActive = false;
                    scoreMultiplier = originalMultiplier;
                }, 30000);
            }
        }

        // Plunge sound detection
        if (!keys.c && prevPlungeKey && gameState === STATE_PLAYING) {
            playSound('Plunge');
        }

        // Saucer timer (per frame)
        if (saucerActive) {
            saucerTimer--;
            if (saucerTimer <= 0) {
                if (saucerLevelUpDone) {
                    saucerActive = false;
                    saucerLevelUpDone = false;
                    const ball = objects[0];
                    ball.vy = -0.4;
                    ball.vx = (Math.random() - 0.5) * 0.15;
                } else {
                    const threshold = saucerLevel < SAUCER_THRESHOLDS.length
                        ? SAUCER_THRESHOLDS[saucerLevel]
                        : SAUCER_THRESHOLDS[SAUCER_THRESHOLDS.length - 1] * 2;
                    if (score >= threshold) {
                        targetLevel++;
                        saucerLevel++;
                        maxTableLevel = Math.max(maxTableLevel, targetLevel);
                        score += 50 * scoreMultiplier * targetValueMultiplier;
                        document.getElementById('score').textContent = score;
                        if (allOrNothingActive) {
                            score *= 3;
                            document.getElementById('score').textContent = score;
                            allOrNothingActive = false;
                            createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 3, 50);
                        }
                        saucerLevelUpDone = true;
                        levelUpTimer = 90;
                        saucerTimer = 90;
                        createParticles(SAUCER_X, SAUCER_Y - 20, 40);
                        createFirework(TABLE_WIDTH / 2, TABLE_HEIGHT / 4);
                        playSound('TableLevelUp');

                        // Transition to Table 2 on first successful saucer capture
                        if (currentTable === 1) {
                            saucerTimer = 150;  // Extra time for transition
                            setTimeout(() => {
                                transitionToTable2();
                            }, 1500);  // Delay to let player see the level-up
                        }
                    } else {
                        score += 15 * scoreMultiplier * targetValueMultiplier;
                        document.getElementById('score').textContent = score;
                        if (allOrNothingActive) {
                            score *= 3;
                            document.getElementById('score').textContent = score;
                            allOrNothingActive = false;
                            createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 3, 50);
                        }
                        saucerActive = false;
                        const ball = objects[0];
                        ball.vy = -0.4;
                        ball.vx = (Math.random() - 0.5) * 0.15;
                    }
                }
            }
        }

        // Update display timers and particles during gameplay
        if (levelUpTimer > 0) {
            levelUpTimer--;
            if (levelUpTimer > 0 && levelUpTimer % 15 === 0) {
                createFirework(
                    60 + Math.random() * (TABLE_WIDTH - 120),
                    80 + Math.random() * (TABLE_HEIGHT / 4)
                );
            }
        }
        if (ballSaveTimer > 0) ballSaveTimer--;
        if (extraBallTimer > 0) {
            extraBallTimer--;
            if (extraBallTimer > 0 && extraBallTimer % 20 === 0) {
                createFirework(
                    60 + Math.random() * (TABLE_WIDTH - 120),
                    80 + Math.random() * (TABLE_HEIGHT / 3)
                );
            }
        }

        // Table 2 specific updates
        if (currentTable === 2) {
            // Update spinner rotation continuously
            if (spinnerSpeed > 0.5) {
                spinnerAngle += spinnerSpeed;  // Continuous rotation
                spinnerSpeed *= 0.97;  // Friction decay
                // Award points for each rotation
                if (Math.floor((spinnerAngle - spinnerSpeed) / 360) < Math.floor(spinnerAngle / 360)) {
                    score += 5 * scoreMultiplier * targetValueMultiplier;
                    document.getElementById('score').textContent = score;
                }
            } else {
                spinnerSpeed = 0;
            }
        }

        // Table transition timer
        if (tableTransitioning && tableTransitionTimer > 0) {
            tableTransitionTimer--;
            if (tableTransitionTimer <= 0) {
                tableTransitioning = false;
            }
        }

        particles = particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.03;
            p.life--;
            return p.life > 0;
        });

        prevPlungeKey = keys.c;
    }

    // === MENU STATE UPDATE ===
    function updateMenuState() {
        // Update particles
        particles = particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.03;
            p.life--;
            return p.life > 0;
        });

        const leftJust = keys.z && !prevMenuKeys.z;
        const rightJust = keys.x && !prevMenuKeys.x;
        const vJust = keys.v && !prevVKey;
        const plungeJust = keys.c && !prevPlungeKey;

        if (gameState === STATE_WELCOME) {
            if (vJust || overlayTap === 'confirm' || overlayTap === 'start') {
                if (overlayTap === 'start') {
                    // Quick start with current initials
                    sessionInitials = ALPHABET[initialsChars[0]] + ALPHABET[initialsChars[1]] + ALPHABET[initialsChars[2]];
                    saveSavedInitials([initialsChars[0], initialsChars[1], initialsChars[2]]);
                    playerStats = loadPlayerStats(sessionInitials);
                    resetGame();
                } else {
                    currentInitialPos++;
                    if (currentInitialPos >= 3) {
                        sessionInitials = ALPHABET[initialsChars[0]] + ALPHABET[initialsChars[1]] + ALPHABET[initialsChars[2]];
                        saveSavedInitials([initialsChars[0], initialsChars[1], initialsChars[2]]);
                        playerStats = loadPlayerStats(sessionInitials);
                        resetGame();
                    }
                }
            } else if (plungeJust || overlayTap === 'back') {
                if (currentInitialPos > 0) currentInitialPos--;
            } else if (leftJust && !keys.x) {
                initialsChars[currentInitialPos] = (initialsChars[currentInitialPos] + 25) % 26;
            } else if (rightJust && !keys.z) {
                initialsChars[currentInitialPos] = (initialsChars[currentInitialPos] + 1) % 26;
            } else if (overlayTap === 'scroll_up') {
                initialsChars[currentInitialPos] = (initialsChars[currentInitialPos] + 25) % 26;
            } else if (overlayTap === 'scroll_down') {
                initialsChars[currentInitialPos] = (initialsChars[currentInitialPos] + 1) % 26;
            }
        }

        else if (gameState === STATE_GAME_OVER) {
            gameOverTimer--;
            if (gameOverTimer <= 0) {
                gameState = STATE_MENU;
            }
        }

        else if (gameState === STATE_MENU) {
            if ((leftJust && !keys.x) || overlayTap === 'scores') {
                gameState = STATE_LEADERBOARD;
                // Load online scores when entering leaderboard
                loadOnlineScores(scores => { onlineScores = scores; });
            } else if ((rightJust && !keys.z) || vJust || overlayTap === 'play') {
                resetGame();
            } else if (overlayTap === 'change_player') {
                sessionInitials = null;
                playerStats = null;
                currentInitialPos = 0;
                gameState = STATE_WELCOME;
            } else if (overlayTap === 'stats') {
                gameState = STATE_STATS;
            }
        }

        else if (gameState === STATE_LEADERBOARD) {
            if (leftJust || rightJust || plungeJust || vJust || overlayTap === 'back_to_menu') {
                gameState = STATE_MENU;
            } else if (overlayTap === 'toggle_scores') {
                showOnlineScores = !showOnlineScores;
                if (showOnlineScores) {
                    loadOnlineScores(scores => { onlineScores = scores; });
                }
            }
        }

        else if (gameState === STATE_CHOOSE_MODIFIER) {
            modifierScreenTimer++;
            if (modifierScreenTimer > 30) {
                if (leftJust || overlayTap === 'mod_left') {
                    applyModifier(modifierChoiceLeft);
                    setupNewBall();
                } else if (rightJust || overlayTap === 'mod_right') {
                    applyModifier(modifierChoiceRight);
                    setupNewBall();
                }
            }
        }

        else if (gameState === STATE_STATS) {
            if (leftJust || rightJust || plungeJust || vJust || overlayTap === 'back_to_menu') {
                gameState = STATE_MENU;
            }
        }

        prevMenuKeys = { z: keys.z, x: keys.x };
        prevVKey = keys.v;
        prevPlungeKey = keys.c;
        overlayTap = null;
    }

    // === DRAW OVERLAY ===
    function drawOverlay() {
        if (gameState === STATE_WELCOME) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

            // Title
            ctx.textAlign = 'center';
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = '#ff00ff';
            ctx.fillText('PinB', TABLE_WIDTH / 2 - 52, TABLE_HEIGHT / 5);
            ctx.fillStyle = '#00ffff';
            ctx.fillText('ALL', TABLE_WIDTH / 2 + 18, TABLE_HEIGHT / 5);

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 22px Arial';
            ctx.fillText('or Nothing', TABLE_WIDTH / 2, TABLE_HEIGHT / 5 + 32);

            // Initials entry
            ctx.fillStyle = '#888888';
            ctx.font = '14px Arial';
            ctx.fillText('ENTER YOUR INITIALS', TABLE_WIDTH / 2, TABLE_HEIGHT / 2 - 60);

            const boxW = 44;
            const boxH = 52;
            const boxGap = 12;
            const totalW = boxW * 3 + boxGap * 2;
            const startX = (TABLE_WIDTH - totalW) / 2;
            const boxY = TABLE_HEIGHT / 2 - 40;

            for (let i = 0; i < 3; i++) {
                const bx = startX + i * (boxW + boxGap);
                const isActive = i === currentInitialPos;
                const isConfirmed = i < currentInitialPos;

                ctx.strokeStyle = isActive ? '#00ffff' : (isConfirmed ? '#ff00ff' : '#444444');
                ctx.lineWidth = isActive ? 3 : 2;
                ctx.strokeRect(bx, boxY, boxW, boxH);

                if (isConfirmed) {
                    ctx.fillStyle = 'rgba(255, 0, 255, 0.15)';
                    ctx.fillRect(bx, boxY, boxW, boxH);
                }

                const letter = (isConfirmed || isActive) ? ALPHABET[initialsChars[i]] : '_';
                ctx.fillStyle = isActive ? '#00ffff' : (isConfirmed ? '#ff00ff' : '#555555');
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(letter, bx + boxW / 2, boxY + 37);

                if (isActive) {
                    ctx.fillStyle = '#ff00ff';
                    ctx.font = '16px Arial';
                    ctx.fillText('\u25B2', bx + boxW / 2, boxY - 8);
                    ctx.fillText('\u25BC', bx + boxW / 2, boxY + boxH + 18);
                }
            }

            // BACK and CONFIRM buttons side by side
            const btnRowY = boxY + boxH + 22;

            // BACK button (left)
            const backBtnX = TABLE_WIDTH / 2 - 80;
            ctx.strokeStyle = '#ff8800';
            ctx.lineWidth = 2;
            ctx.strokeRect(backBtnX, btnRowY, 68, 36);
            ctx.fillStyle = '#ff8800';
            ctx.font = 'bold 13px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BACK', backBtnX + 34, btnRowY + 24);

            // CONFIRM button (right)
            const cfmBtnX = TABLE_WIDTH / 2 + 12;
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(cfmBtnX, btnRowY, 68, 36);
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 13px Arial';
            ctx.fillText('CONFIRM', cfmBtnX + 34, btnRowY + 24);

            // START button
            const startBtnY = btnRowY + 36 + 18;
            const startBtnX = TABLE_WIDTH / 2 - 75;
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 3;
            ctx.strokeRect(startBtnX, startBtnY, 150, 50);
            ctx.fillStyle = '#ff00ff';
            ctx.font = 'bold 22px Arial';
            ctx.fillText('START', TABLE_WIDTH / 2, startBtnY + 34);

            // Instructions
            ctx.fillStyle = '#666666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('L/R: SCROLL   V: NEXT   SPACE: BACK   START: PLAY', TABLE_WIDTH / 2, startBtnY + 68);
        }

        else if (gameState === STATE_GAME_OVER) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

            ctx.fillStyle = '#ff00ff';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', TABLE_WIDTH / 2, TABLE_HEIGHT / 3);

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px Arial';
            ctx.fillText(finalScore.toString(), TABLE_WIDTH / 2, TABLE_HEIGHT / 3 + 40);

            if (sessionInitials) {
                ctx.fillStyle = '#00ffff';
                ctx.font = '16px Arial';
                ctx.fillText(sessionInitials, TABLE_WIDTH / 2, TABLE_HEIGHT / 3 + 65);
            }

            if (maxTableLevel > 0) {
                ctx.fillStyle = '#ff8800';
                ctx.font = '14px Arial';
                ctx.fillText('TABLE LEVEL: ' + maxTableLevel, TABLE_WIDTH / 2, TABLE_HEIGHT / 3 + 85);
            }

            if (isNewHighScore && frame % 20 < 14) {
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 18px Arial';
                ctx.fillText('NEW HIGH SCORE!', TABLE_WIDTH / 2, TABLE_HEIGHT / 3 + 110);
            }
        }

        else if (gameState === STATE_MENU) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

            ctx.fillStyle = '#ffffff';
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('FINAL SCORE', TABLE_WIDTH / 2, TABLE_HEIGHT / 3 - 20);

            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 30px Arial';
            ctx.fillText(finalScore.toString(), TABLE_WIDTH / 2, TABLE_HEIGHT / 3 + 15);

            if (sessionInitials) {
                ctx.fillStyle = '#00ffff';
                ctx.font = '14px Arial';
                ctx.fillText('Player: ' + sessionInitials, TABLE_WIDTH / 2, TABLE_HEIGHT / 3 + 40);
            }

            const btnY = TABLE_HEIGHT / 2 + 10;
            const btnW = 130;
            const btnH = 50;
            const gap = 16;

            const leftBtnX = TABLE_WIDTH / 2 - btnW - gap / 2;
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(leftBtnX, btnY, btnW, btnH);
            ctx.fillStyle = '#ff00ff';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SCORES', leftBtnX + btnW / 2, btnY + 32);

            const rightBtnX = TABLE_WIDTH / 2 + gap / 2;
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(rightBtnX, btnY, btnW, btnH);
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('PLAY', rightBtnX + btnW / 2, btnY + 32);

            ctx.fillStyle = '#666666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('LEFT: SCORES    RIGHT/V: PLAY AGAIN', TABLE_WIDTH / 2, btnY + btnH + 30);

            // CHANGE PLAYER button
            const cpBtnW = 160;
            const cpBtnX = TABLE_WIDTH / 2 - cpBtnW / 2;
            const cpBtnY = btnY + btnH + 50;
            ctx.strokeStyle = '#ff8800';
            ctx.lineWidth = 1;
            ctx.strokeRect(cpBtnX, cpBtnY, cpBtnW, 35);
            ctx.fillStyle = '#ff8800';
            ctx.font = 'bold 13px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CHANGE PLAYER', TABLE_WIDTH / 2, cpBtnY + 23);

            // STATS button
            const stBtnW = 100;
            const stBtnX = TABLE_WIDTH / 2 - stBtnW / 2;
            const stBtnY = cpBtnY + 45;
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 1;
            ctx.strokeRect(stBtnX, stBtnY, stBtnW, 35);
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 13px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('STATS', TABLE_WIDTH / 2, stBtnY + 23);
        }

        else if (gameState === STATE_LEADERBOARD) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

            ctx.fillStyle = '#ff00ff';
            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('HIGH SCORES', TABLE_WIDTH / 2, 70);

            // LOCAL/ONLINE toggle
            const togY = 88;
            ctx.font = '12px Arial';
            ctx.fillStyle = !showOnlineScores ? '#00ffff' : '#555555';
            ctx.textAlign = 'right';
            ctx.fillText('LOCAL', TABLE_WIDTH / 2 - 8, togY + 15);
            ctx.fillStyle = showOnlineScores ? '#00ffff' : '#555555';
            ctx.textAlign = 'left';
            ctx.fillText('ONLINE', TABLE_WIDTH / 2 + 8, togY + 15);
            ctx.fillStyle = '#444444';
            ctx.fillText('|', TABLE_WIDTH / 2 - 2, togY + 15);

            const scoresToShow = showOnlineScores ? onlineScores : highScores;

            if (scoresToShow.length === 0) {
                ctx.fillStyle = '#555555';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(showOnlineScores ? 'NO ONLINE SCORES' : 'NO SCORES YET', TABLE_WIDTH / 2, 180);
            } else {
                for (let i = 0; i < scoresToShow.length && i < MAX_HIGH_SCORES; i++) {
                    const hs = scoresToShow[i];
                    const y = 130 + i * 38;

                    ctx.fillStyle = '#888888';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText((i + 1) + '.', TABLE_WIDTH / 2 - 100, y);

                    ctx.fillStyle = '#00ffff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(hs.initials || '???', TABLE_WIDTH / 2 - 85, y);

                    ctx.fillStyle = '#ffffff';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(hs.score.toString(), TABLE_WIDTH / 2 + 60, y);

                    // Table level
                    if (hs.maxTableLevel) {
                        ctx.fillStyle = '#ff8800';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText('Lv' + hs.maxTableLevel, TABLE_WIDTH / 2 + 68, y);
                    }

                    const d = new Date(hs.date);
                    ctx.fillStyle = '#555555';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(d.toLocaleDateString(), TABLE_WIDTH / 2 + 60, y + 14);
                }
            }

            // BACK button
            const lbBackX = TABLE_WIDTH / 2 - 60;
            const lbBackY = TABLE_HEIGHT - 75;
            const lbBackW = 120;
            const lbBackH = 40;
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(lbBackX, lbBackY, lbBackW, lbBackH);
            ctx.fillStyle = '#ff00ff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BACK', TABLE_WIDTH / 2, lbBackY + 26);
        }

        else if (gameState === STATE_CHOOSE_MODIFIER) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CHOOSE A BONUS', TABLE_WIDTH / 2, TABLE_HEIGHT / 4);

            const boxW = 160;
            const boxH = 180;
            const boxY = TABLE_HEIGHT / 2 - boxH / 2;
            const leftBoxX = TABLE_WIDTH / 2 - boxW - 10;
            const rightBoxX = TABLE_WIDTH / 2 + 10;

            const ready = modifierScreenTimer > 30;

            // Left box
            ctx.strokeStyle = ready ? '#ff00ff' : '#553355';
            ctx.lineWidth = 2;
            ctx.strokeRect(leftBoxX, boxY, boxW, boxH);
            if (modifierChoiceLeft) {
                ctx.fillStyle = ready ? '#ff00ff' : '#553355';
                ctx.font = 'bold 18px Arial';
                ctx.fillText(modifierChoiceLeft.name, leftBoxX + boxW / 2, boxY + 50);
                ctx.fillText(modifierChoiceLeft.name2, leftBoxX + boxW / 2, boxY + 75);
                ctx.fillStyle = ready ? '#aaaaaa' : '#555555';
                ctx.font = '11px Arial';
                ctx.fillText(modifierChoiceLeft.desc, leftBoxX + boxW / 2, boxY + 110);
                // Pick count
                const leftPicks = (playerStats && playerStats.modPicks) ? (playerStats.modPicks[modifierChoiceLeft.id] || 0) : 0;
                ctx.fillStyle = '#666666';
                ctx.font = '10px Arial';
                ctx.fillText('Picked ' + leftPicks + 'x', leftBoxX + boxW / 2, boxY + 145);
            }

            // Right box
            ctx.strokeStyle = ready ? '#00ffff' : '#335555';
            ctx.lineWidth = 2;
            ctx.strokeRect(rightBoxX, boxY, boxW, boxH);
            if (modifierChoiceRight) {
                ctx.fillStyle = ready ? '#00ffff' : '#335555';
                ctx.font = 'bold 18px Arial';
                ctx.fillText(modifierChoiceRight.name, rightBoxX + boxW / 2, boxY + 50);
                ctx.fillText(modifierChoiceRight.name2, rightBoxX + boxW / 2, boxY + 75);
                ctx.fillStyle = ready ? '#aaaaaa' : '#555555';
                ctx.font = '11px Arial';
                ctx.fillText(modifierChoiceRight.desc, rightBoxX + boxW / 2, boxY + 110);
                // Pick count
                const rightPicks = (playerStats && playerStats.modPicks) ? (playerStats.modPicks[modifierChoiceRight.id] || 0) : 0;
                ctx.fillStyle = '#666666';
                ctx.font = '10px Arial';
                ctx.fillText('Picked ' + rightPicks + 'x', rightBoxX + boxW / 2, boxY + 145);
            }

            ctx.fillStyle = ready ? '#666666' : '#444444';
            ctx.font = '11px Arial';
            ctx.fillText(ready ? 'LEFT / RIGHT to choose' : 'Get ready...', TABLE_WIDTH / 2, TABLE_HEIGHT - 80);
        }

        else if (gameState === STATE_STATS) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

            ctx.fillStyle = '#ff00ff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PLAYER STATS', TABLE_WIDTH / 2, 70);

            if (sessionInitials) {
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 18px Arial';
                ctx.fillText(sessionInitials, TABLE_WIDTH / 2, 100);
            }

            const stats = playerStats || (sessionInitials ? loadPlayerStats(sessionInitials) : null);
            if (stats) {
                const statLines = [
                    ['Games Played', stats.gamesPlayed || 0],
                    ['Total Score', stats.totalScore || 0],
                    ['Targets Cleared', stats.allTargetsCleared || 0],
                    ['Color Bumper Hits', stats.colorBumperHits || 0],
                    ['Saucer Captures', stats.saucerCaptures || 0],
                    ['Extra Balls', stats.extraBallsEarned || 0],
                    ['Max Multiplier', (stats.maxMultiplier || 1) + 'x']
                ];

                for (let i = 0; i < statLines.length; i++) {
                    const y = 140 + i * 36;
                    ctx.fillStyle = '#888888';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(statLines[i][0], 60, y);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(statLines[i][1].toString(), TABLE_WIDTH - 60, y);
                }
            } else {
                ctx.fillStyle = '#555555';
                ctx.font = '16px Arial';
                ctx.fillText('NO STATS YET', TABLE_WIDTH / 2, 200);
            }

            // BACK button
            const bkBtnX = TABLE_WIDTH / 2 - 60;
            const bkBtnY = TABLE_HEIGHT - 75;
            ctx.strokeStyle = '#ff8800';
            ctx.lineWidth = 2;
            ctx.strokeRect(bkBtnX, bkBtnY, 120, 40);
            ctx.fillStyle = '#ff8800';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BACK', TABLE_WIDTH / 2, bkBtnY + 27);
        }
    }

    // === DRAWING ===
    // === ENHANCED VISUAL RENDERING SYSTEM ===
    let gridOffset = 0;  // For animated grid

    // Draw glowing animated grid background
    function drawAnimatedGrid() {
        const gridSize = 25;
        const time = frame * 0.02;
        gridOffset = (gridOffset + 0.3) % gridSize;

        // Draw vertical lines with pulse effect
        for (let x = 0; x <= TABLE_WIDTH; x += gridSize) {
            const pulsePhase = (x / TABLE_WIDTH + time) % 1;
            const brightness = 0.03 + 0.02 * Math.sin(pulsePhase * Math.PI * 2);

            ctx.strokeStyle = `rgba(0, 255, 255, ${brightness})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, TABLE_HEIGHT);
            ctx.stroke();
        }

        // Draw horizontal lines with upward-moving glow
        for (let y = 0; y <= TABLE_HEIGHT; y += gridSize) {
            const adjustedY = (y + gridOffset) % TABLE_HEIGHT;
            const pulsePos = 1 - (adjustedY / TABLE_HEIGHT);
            const glowIntensity = 0.03 + 0.04 * Math.pow(Math.sin(pulsePos * Math.PI), 2);

            ctx.strokeStyle = `rgba(0, 255, 255, ${glowIntensity})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(TABLE_WIDTH, y);
            ctx.stroke();
        }

        // Add traveling light waves going upward
        const waveCount = 3;
        for (let w = 0; w < waveCount; w++) {
            const waveY = TABLE_HEIGHT - ((frame * 1.5 + w * (TABLE_HEIGHT / waveCount)) % TABLE_HEIGHT);
            const waveAlpha = 0.15 * (1 - Math.abs(waveY - TABLE_HEIGHT/2) / (TABLE_HEIGHT/2));

            if (waveAlpha > 0.01) {
                const gradient = ctx.createLinearGradient(0, waveY - 20, 0, waveY + 20);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0)');
                gradient.addColorStop(0.5, `rgba(0, 255, 255, ${waveAlpha})`);
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(0, waveY - 20, TABLE_WIDTH, 40);
            }
        }
    }

    // Draw a bumper with 3D depth, glow, and reflections
    function drawBumper3D(x, y, radius, color, isActive) {
        const bounceScale = isActive ? 1.15 : 1;
        const r = radius * bounceScale;

        // Outer glow
        ctx.save();
        const glowRadius = r * 1.8;
        const glow = ctx.createRadialGradient(x, y, r * 0.5, x, y, glowRadius);
        glow.addColorStop(0, color + '40');
        glow.addColorStop(0.5, color + '15');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(x, y, glowRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Shadow underneath
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.beginPath();
        ctx.ellipse(x + 3, y + 4, r * 0.9, r * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Main body with gradient
        const bodyGrad = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);
        bodyGrad.addColorStop(0, lightenColor(color, 60));
        bodyGrad.addColorStop(0.4, color);
        bodyGrad.addColorStop(1, darkenColor(color, 40));

        ctx.fillStyle = bodyGrad;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();

        // Outer ring
        ctx.strokeStyle = darkenColor(color, 30);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, r - 1, 0, Math.PI * 2);
        ctx.stroke();

        // Inner circle (cap)
        const capGrad = ctx.createRadialGradient(x - r * 0.2, y - r * 0.2, 0, x, y, r * 0.6);
        capGrad.addColorStop(0, '#ffffff');
        capGrad.addColorStop(0.3, lightenColor(color, 40));
        capGrad.addColorStop(1, color);

        ctx.fillStyle = capGrad;
        ctx.beginPath();
        ctx.arc(x, y, r * 0.6, 0, Math.PI * 2);
        ctx.fill();

        // Top highlight reflection
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.ellipse(x - r * 0.25, y - r * 0.35, r * 0.35, r * 0.2, -0.5, 0, Math.PI * 2);
        ctx.fill();

        // Small specular highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.beginPath();
        ctx.arc(x - r * 0.3, y - r * 0.4, r * 0.12, 0, Math.PI * 2);
        ctx.fill();
    }

    // Draw smooth walls instead of circle chains
    function drawSmoothWalls() {
        const DOME_BOTH = DOME_RADIUS + WALL_RADIUS;

        // Helper to draw a wall segment with glow
        function drawWallPath(path, color, lineWidth, glowColor) {
            // Shadow
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = lineWidth + 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.translate(2, 3);
            ctx.stroke(path);
            ctx.restore();

            // Glow
            ctx.save();
            ctx.shadowColor = glowColor || color;
            ctx.shadowBlur = 8;
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke(path);
            ctx.restore();

            // Main line
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke(path);

            // Highlight
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = lineWidth * 0.3;
            ctx.translate(-1, -1);
            ctx.stroke(path);
            ctx.restore();
        }

        // Left side wall
        let path = new Path2D();
        path.moveTo(CENTER_X - DOME_BOTH, TABLE_HEIGHT);
        path.lineTo(CENTER_X - DOME_BOTH, TABLE_HEIGHT - 90 * 7);
        drawWallPath(path, '#00dddd', 10, '#00ffff');

        // Right side wall
        path = new Path2D();
        path.moveTo(CENTER_X + DOME_BOTH, TABLE_HEIGHT);
        path.lineTo(CENTER_X + DOME_BOTH, TABLE_HEIGHT - 90 * 7);
        drawWallPath(path, '#00dddd', 10, '#00ffff');

        // Top dome (left curve)
        path = new Path2D();
        for (let i = 0; i <= 55; i++) {
            const x = CENTER_X - DOME_BOTH * Math.cos(i / 35);
            const y = DOME_BOTH - DOME_BOTH * Math.sin(i / 35);
            if (i === 0) path.moveTo(x, y);
            else path.lineTo(x, y);
        }
        drawWallPath(path, '#00dddd', 10, '#00ffff');

        // Top dome (right curve)
        path = new Path2D();
        for (let i = 0; i <= 55; i++) {
            const x = CENTER_X + DOME_BOTH * Math.cos(i / 35);
            const y = DOME_BOTH - DOME_BOTH * Math.sin(i / 35);
            if (i === 0) path.moveTo(x, y);
            else path.lineTo(x, y);
        }
        drawWallPath(path, '#00dddd', 10, '#00ffff');

        // Shooter lane wall
        const shooterWallX = CENTER_X + DOME_RADIUS - BALL_RADIUS * 2 - WALL_RADIUS;
        path = new Path2D();
        path.moveTo(shooterWallX, TABLE_HEIGHT);
        path.lineTo(shooterWallX, TABLE_HEIGHT - 65 * 7);
        drawWallPath(path, '#00aa88', 8, '#00ffaa');

        // Outlane walls (both sides)
        for (let side = 0; side < 2; side++) {
            const dir = side * 2 - 1;

            // Vertical outlane guide
            path = new Path2D();
            path.moveTo(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55), FLIPPER_Y - 50);
            path.lineTo(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55), FLIPPER_Y - 50 - 11 * 7);
            drawWallPath(path, '#ff6600', 8, '#ff8800');

            // Diagonal outlane guide
            path = new Path2D();
            path.moveTo(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55), FLIPPER_Y - 50);
            path.lineTo(FLIPPER_CENTER + dir * FLIPPER_SPREAD, FLIPPER_Y - 50 + 18 * 3);
            drawWallPath(path, '#ff6600', 8, '#ff8800');

            // Slingshot outer wall
            const slingOuterX = FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 25);
            const slingTopY = FLIPPER_Y - 120;
            const slingBottomY = FLIPPER_Y - 70;

            path = new Path2D();
            path.moveTo(slingOuterX, slingTopY);
            path.lineTo(slingOuterX, slingBottomY);
            drawWallPath(path, '#00dddd', 6, '#00ffff');
        }
    }

    // Draw slingshot triangles with glow
    function drawSlingshots() {
        for (let side = 0; side < 2; side++) {
            const dir = side * 2 - 1;
            const slingInnerX = FLIPPER_CENTER + dir * FLIPPER_SPREAD;
            const slingOuterX = FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 25);
            const slingTopY = FLIPPER_Y - 120;
            const slingBottomY = FLIPPER_Y - 70;
            const slingBottomInnerY = slingBottomY + 25;

            // Check if slingshot is bouncing
            let isBouncing = false;
            for (const obj of objects) {
                if (obj.isSlingshot && obj.bounce > 0) {
                    const dx = Math.abs(obj.x - (slingOuterX + slingInnerX) / 2);
                    if (dx < 30) {
                        isBouncing = true;
                        break;
                    }
                }
            }

            const baseColor = isBouncing ? '#ffffff' : '#ff00aa';
            const glowColor = isBouncing ? '#ffffff' : '#ff00ff';

            // Glow behind
            ctx.save();
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = isBouncing ? 20 : 10;

            // Fill triangle
            const grad = ctx.createLinearGradient(slingOuterX, slingTopY, slingInnerX, slingBottomInnerY);
            grad.addColorStop(0, baseColor);
            grad.addColorStop(1, darkenColor(baseColor, 30));

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(slingOuterX, slingTopY);
            ctx.lineTo(slingInnerX, slingBottomInnerY);
            ctx.lineTo(slingOuterX, slingBottomY);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // Border
            ctx.strokeStyle = lightenColor(baseColor, 30);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(slingOuterX, slingTopY);
            ctx.lineTo(slingInnerX, slingBottomInnerY);
            ctx.stroke();
        }
    }

    // Draw flippers with glow and depth
    function drawFlippers() {
        for (let side = 0; side < 2; side++) {
            const isLeft = side === 0;
            const isPressed = isLeft ? keys.z : keys.x;
            const flipperAngle = isLeft ? flipperLeft : flipperRight;
            const baseColor = isLeft ? '#ff0080' : '#0080ff';
            const activeColor = isLeft ? '#ff00ff' : '#00ffff';
            const color = isPressed ? activeColor : baseColor;

            // Collect flipper segment positions
            const segments = [];
            for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
                const objIndex = isLeft ? (1 + i) : (1 + FLIPPER_SEGMENTS + i);
                const obj = objects[objIndex];
                if (obj) {
                    segments.push({ x: obj.x, y: obj.y, radius: obj.radius });
                }
            }

            if (segments.length < 2) continue;

            // Draw glow
            ctx.save();
            ctx.shadowColor = color;
            ctx.shadowBlur = isPressed ? 20 : 10;

            // Draw as filled shape
            ctx.fillStyle = color;
            ctx.beginPath();

            // Top edge
            for (let i = 0; i < segments.length; i++) {
                const s = segments[i];
                const x = s.x;
                const y = s.y - s.radius * 0.8;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }

            // Round tip
            const lastSeg = segments[segments.length - 1];
            ctx.arc(lastSeg.x, lastSeg.y, lastSeg.radius * 0.8, -Math.PI/2, Math.PI/2);

            // Bottom edge (reverse)
            for (let i = segments.length - 1; i >= 0; i--) {
                const s = segments[i];
                ctx.lineTo(s.x, s.y + s.radius * 0.8);
            }

            // Round base
            const firstSeg = segments[0];
            ctx.arc(firstSeg.x, firstSeg.y, firstSeg.radius * 0.8, Math.PI/2, -Math.PI/2);

            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // Gradient overlay for 3D effect
            const gradX = segments[0].x;
            const gradY = segments[0].y;
            const grad = ctx.createLinearGradient(gradX, gradY - 15, gradX, gradY + 15);
            grad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0.2)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            for (let i = 0; i < segments.length; i++) {
                const s = segments[i];
                const x = s.x;
                const y = s.y - s.radius * 0.8;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.arc(lastSeg.x, lastSeg.y, lastSeg.radius * 0.8, -Math.PI/2, Math.PI/2);
            for (let i = segments.length - 1; i >= 0; i--) {
                const s = segments[i];
                ctx.lineTo(s.x, s.y + s.radius * 0.8);
            }
            ctx.arc(firstSeg.x, firstSeg.y, firstSeg.radius * 0.8, Math.PI/2, -Math.PI/2);
            ctx.closePath();
            ctx.fill();
        }
    }

    // Draw the ball with enhanced glow and trail
    function drawBall3D(x, y, radius, vx, vy) {
        // Motion trail
        const speed = Math.sqrt(vx * vx + vy * vy);
        const trailLength = Math.min(5, Math.floor(speed * 3));

        for (let i = trailLength; i > 0; i--) {
            const alpha = 0.1 * (1 - i / trailLength);
            const trailX = x - vx * i * 2;
            const trailY = y - vy * i * 2;
            const trailRadius = radius * (1 - i * 0.1);

            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.beginPath();
            ctx.arc(trailX, trailY, trailRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Outer glow
        ctx.save();
        const glow = ctx.createRadialGradient(x, y, radius * 0.5, x, y, radius * 2.5);
        glow.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
        glow.addColorStop(0.5, 'rgba(200, 200, 255, 0.1)');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(x, y, radius * 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(x + 2, y + 3, radius * 0.8, radius * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Main ball body
        const ballGrad = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, 0, x, y, radius);
        ballGrad.addColorStop(0, '#ffffff');
        ballGrad.addColorStop(0.3, '#e8e8ff');
        ballGrad.addColorStop(0.7, '#c0c0d0');
        ballGrad.addColorStop(1, '#808090');

        ctx.fillStyle = ballGrad;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Chrome ring
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(x, y, radius - 1, 0, Math.PI * 2);
        ctx.stroke();

        // Top highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.beginPath();
        ctx.ellipse(x - radius * 0.3, y - radius * 0.35, radius * 0.3, radius * 0.15, -0.5, 0, Math.PI * 2);
        ctx.fill();

        // Specular point
        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
        ctx.beginPath();
        ctx.arc(x - radius * 0.35, y - radius * 0.4, radius * 0.12, 0, Math.PI * 2);
        ctx.fill();
    }

    // Draw shooter lane with glow
    function drawShooterLane() {
        const shooterStart = 1 + FLIPPER_SEGMENTS * 2;
        let minY = TABLE_HEIGHT;
        let maxY = 0;

        for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
            const shooter = objects[shooterStart + i];
            if (shooter && shooter.isShooter) {
                minY = Math.min(minY, shooter.y);
                maxY = Math.max(maxY, shooter.y);
            }
        }

        const plungerX = CENTER_X + DOME_RADIUS - BALL_RADIUS;
        const plungerWidth = 12;

        // Plunger housing
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(plungerX - plungerWidth/2 - 2, minY - 10, plungerWidth + 4, maxY - minY + 20);

        // Plunger shaft
        const grad = ctx.createLinearGradient(plungerX - plungerWidth/2, 0, plungerX + plungerWidth/2, 0);
        grad.addColorStop(0, '#004400');
        grad.addColorStop(0.3, '#00aa00');
        grad.addColorStop(0.7, '#00aa00');
        grad.addColorStop(1, '#004400');

        ctx.fillStyle = grad;
        ctx.fillRect(plungerX - plungerWidth/2, minY, plungerWidth, maxY - minY);

        // Plunger tip
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(plungerX, minY, plungerWidth/2, Math.PI, 0);
        ctx.fill();

        // Glow when compressed
        if (keys.c) {
            ctx.save();
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(plungerX, minY, plungerWidth/2, Math.PI, 0);
            ctx.fill();
            ctx.restore();
        }
    }

    // Color utility functions
    function lightenColor(hex, percent) {
        const num = parseInt(hex.replace('#', ''), 16);
        const r = Math.min(255, (num >> 16) + percent);
        const g = Math.min(255, ((num >> 8) & 0x00FF) + percent);
        const b = Math.min(255, (num & 0x0000FF) + percent);
        return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
    }

    function darkenColor(hex, percent) {
        const num = parseInt(hex.replace('#', ''), 16);
        const r = Math.max(0, (num >> 16) - percent);
        const g = Math.max(0, ((num >> 8) & 0x00FF) - percent);
        const b = Math.max(0, (num & 0x0000FF) - percent);
        return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
    }

    // Simple circle for small elements
    function drawCircle(x, y, radius, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(x - radius * 0.2, y - radius * 0.2, radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
    }

    // Small pin with subtle 3D effect
    function drawPin3D(x, y, radius, color) {
        // Small shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(x + 1, y + 2, radius * 0.8, radius * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Body
        const grad = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, 0, x, y, radius);
        grad.addColorStop(0, lightenColor(color, 80));
        grad.addColorStop(0.5, color);
        grad.addColorStop(1, darkenColor(color, 40));

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.arc(x - radius * 0.25, y - radius * 0.25, radius * 0.25, 0, Math.PI * 2);
        ctx.fill();
    }

    // Draw drop target with 3D look
    function drawDropTarget3D(x, y, radius, color, isActive) {
        if (!isActive) {
            // Inactive - just a dark recess
            ctx.fillStyle = '#222200';
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            return;
        }

        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.beginPath();
        ctx.ellipse(x + 1, y + 2, radius, radius * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Glow
        ctx.save();
        ctx.shadowColor = color;
        ctx.shadowBlur = 8;

        // Body
        const grad = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, 0, x, y, radius);
        grad.addColorStop(0, lightenColor(color, 60));
        grad.addColorStop(0.5, color);
        grad.addColorStop(1, darkenColor(color, 50));

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(x - radius * 0.2, y - radius * 0.2, radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
    }

    function draw() {
        ctx.fillStyle = '#0a0a12';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        // Animated glowing grid background
        drawAnimatedGrid();

        // Draw smooth walls (aesthetic layer over physics circles)
        drawSmoothWalls();

        // Draw slingshots with glow
        drawSlingshots();

        // Draw flippers with enhanced glow
        drawFlippers();

        // Draw shooter lane
        drawShooterLane();

        // Border with glow
        ctx.save();
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 10;
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(5, 5, TABLE_WIDTH - 10, TABLE_HEIGHT - 10);
        ctx.restore();

        // Draw game objects with enhanced rendering
        const ball = objects[0];

        // First pass: Draw drop targets
        for (let i = objects.length - 1; i >= 1; i--) {
            const obj = objects[i];
            if (obj.isDropTarget) {
                let color = DROP_COLORS[targetLevel % DROP_COLORS.length];
                if (obj.isRampDropTarget) color = '#ff8800';
                if (obj.bounce > 0) color = '#ffffff';
                drawDropTarget3D(obj.x, obj.y, obj.radius + (obj.bounce || 0), color, obj.active);
            }
        }

        // Second pass: Draw bumpers (pop bumpers with 3D effect)
        for (let i = objects.length - 1; i >= 1; i--) {
            const obj = objects[i];
            if (obj.type === TYPE_BUMPER && !obj.isSlingshot) {
                let color = obj.color;
                if (obj.isCenterBumper && obj.bounce <= 0) {
                    color = BUMPER_COLORS[spotCompletions % BUMPER_COLORS.length];
                } else if (obj.isHighValue && obj.bounce <= 0) {
                    color = '#ff0000';
                }
                if (obj.bounce > 0) color = '#ffffff';

                // Use 3D bumper for larger bumpers
                if (obj.radius >= 10) {
                    drawBumper3D(obj.x, obj.y, obj.radius, color, obj.bounce > 0);
                } else {
                    // Smaller pins get simpler 3D treatment
                    drawPin3D(obj.x, obj.y, obj.radius + (obj.bounce || 0), color);
                }
            }
        }

        // Third pass: Draw standup targets
        for (let i = objects.length - 1; i >= 1; i--) {
            const obj = objects[i];
            if (obj.isStandupTarget) {
                const bank = obj.standupBank;
                const idx = obj.standupIndex;
                const isLit = bank === 'left' ? standupBankLeft[idx] : standupBankRight[idx];
                let color = obj.bounce > 0 ? '#ffffff' : (isLit ? '#00ff00' : '#006600');
                drawPin3D(obj.x, obj.y, obj.radius + (obj.bounce || 0), color);
            }
        }

        // Fourth pass: Draw center pin and top lane pins
        for (let i = objects.length - 1; i >= 1; i--) {
            const obj = objects[i];
            // Skip flippers, shooter, bumpers, drop targets, standup targets
            if (i >= 1 && i <= FLIPPER_SEGMENTS * 2) continue;
            if (obj.isShooter) continue;
            if (obj.type === TYPE_BUMPER) continue;
            if (obj.isDropTarget) continue;
            if (obj.isStandupTarget) continue;
            if (obj.isSpinner) continue;
            if (obj.isScoop) continue;
            if (obj.isRampWall) continue;  // Walls handled by drawSmoothWalls

            // These are decorative pins (center pin, top lane pins, etc.)
            if (obj.isCenterPin) {
                const color = safetyPinActive ? '#ffff00' : '#00ffff';
                drawPin3D(obj.x, obj.y, obj.radius, color);
            } else if (obj.radius <= 6) {
                // Small pins at top lanes
                drawPin3D(obj.x, obj.y, obj.radius, obj.color || '#00ffff');
            }
        }

        // Draw lights with enhanced glow effects
        const topLaneLightY = TOP_LANE_Y;
        for (let i = 0; i < 3; i++) {
            const lx = (TOP_LANE_PINS[i] + TOP_LANE_PINS[i + 1]) / 2;
            const isLit = topLaneLights[i];

            if (isLit) {
                // Glow effect for lit lights
                ctx.save();
                const glow = ctx.createRadialGradient(lx, topLaneLightY, 2, lx, topLaneLightY, 20);
                glow.addColorStop(0, 'rgba(255, 255, 0, 0.6)');
                glow.addColorStop(0.5, 'rgba(255, 200, 0, 0.2)');
                glow.addColorStop(1, 'transparent');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(lx, topLaneLightY, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Light body
            const lightGrad = ctx.createRadialGradient(lx - 3, topLaneLightY - 3, 0, lx, topLaneLightY, 10);
            if (isLit) {
                lightGrad.addColorStop(0, '#ffffff');
                lightGrad.addColorStop(0.4, '#ffff00');
                lightGrad.addColorStop(1, '#aa8800');
            } else {
                lightGrad.addColorStop(0, '#555555');
                lightGrad.addColorStop(0.4, '#333333');
                lightGrad.addColorStop(1, '#222222');
            }
            ctx.fillStyle = lightGrad;
            ctx.beginPath();
            ctx.arc(lx, topLaneLightY, 10, 0, Math.PI * 2);
            ctx.fill();

            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(lx - 3, topLaneLightY - 3, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Spot targets with enhanced rendering
        for (let i = 0; i < 4; i++) {
            const st = SPOT_TARGET_POSITIONS[i];
            const isLit = spotTargets[i];
            const litColor = SPOT_LIT[targetLevel % SPOT_LIT.length];
            const darkColor = SPOT_DARK[targetLevel % SPOT_DARK.length];

            if (isLit) {
                // Glow for lit spots
                ctx.save();
                ctx.shadowColor = litColor;
                ctx.shadowBlur = 12;
                ctx.fillStyle = litColor;
                ctx.beginPath();
                ctx.arc(st.x, st.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            drawPin3D(st.x, st.y, 6, isLit ? litColor : darkColor);
        }

        // Lane lights with glow
        for (let i = 0; i < 4; i++) {
            const ll = LANE_LIGHT_POSITIONS[i];
            const isLit = laneLights[i];

            if (isLit) {
                ctx.save();
                const glow = ctx.createRadialGradient(ll.x, ll.y, 2, ll.x, ll.y, 15);
                glow.addColorStop(0, 'rgba(0, 255, 0, 0.5)');
                glow.addColorStop(0.5, 'rgba(0, 200, 0, 0.2)');
                glow.addColorStop(1, 'transparent');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(ll.x, ll.y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            drawPin3D(ll.x, ll.y, 5, isLit ? '#00ff00' : '#333333');
        }

        // Saucer with enhanced rendering
        const saucerColor = saucerActive ? (frame % 10 < 5 ? '#ffffff' : '#00ffff') : '#555555';

        if (saucerActive) {
            // Pulsing glow when active
            ctx.save();
            const pulseIntensity = 0.3 + 0.2 * Math.sin(frame * 0.1);
            const saucerGlow = ctx.createRadialGradient(SAUCER_X, SAUCER_Y, 5, SAUCER_X, SAUCER_Y, 30);
            saucerGlow.addColorStop(0, `rgba(0, 255, 255, ${pulseIntensity})`);
            saucerGlow.addColorStop(0.5, `rgba(0, 200, 255, ${pulseIntensity * 0.5})`);
            saucerGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = saucerGlow;
            ctx.beginPath();
            ctx.arc(SAUCER_X, SAUCER_Y, 30, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // Saucer body
        ctx.save();
        ctx.shadowColor = saucerColor;
        ctx.shadowBlur = saucerActive ? 15 : 5;
        ctx.strokeStyle = saucerColor;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(SAUCER_X, SAUCER_Y, SAUCER_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        // Saucer inner gradient
        const innerGrad = ctx.createRadialGradient(SAUCER_X, SAUCER_Y, 0, SAUCER_X, SAUCER_Y, SAUCER_RADIUS);
        innerGrad.addColorStop(0, 'rgba(0, 50, 100, 0.8)');
        innerGrad.addColorStop(1, 'rgba(0, 20, 40, 0.9)');
        ctx.fillStyle = innerGrad;
        ctx.beginPath();
        ctx.arc(SAUCER_X, SAUCER_Y, SAUCER_RADIUS - 2, 0, Math.PI * 2);
        ctx.fill();

        if (!saucerActive) {
            const nextThreshold = saucerLevel < SAUCER_THRESHOLDS.length
                ? SAUCER_THRESHOLDS[saucerLevel]
                : SAUCER_THRESHOLDS[SAUCER_THRESHOLDS.length - 1] * 2;
            ctx.fillStyle = '#888888';
            ctx.font = 'bold 8px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(nextThreshold, SAUCER_X, SAUCER_Y + 3);
        }

        // === TABLE 2 SPECIFIC RENDERING ===
        if (currentTable === 2) {
            // Draw ramp path guide with glow
            ctx.save();
            if (!rampDropTargetActive) {
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 10;
            }
            ctx.strokeStyle = rampDropTargetActive ? '#444444' : '#00ff88';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(45, 230);
            ctx.quadraticCurveTo(30, 160, 70, 100);
            ctx.quadraticCurveTo(120, 80, 140, 120);
            ctx.stroke();
            ctx.restore();

            // Ramp rails (3D look)
            if (!rampDropTargetActive) {
                ctx.strokeStyle = '#00aa66';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(40, 230);
                ctx.quadraticCurveTo(25, 160, 65, 100);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(50, 230);
                ctx.quadraticCurveTo(35, 160, 75, 100);
                ctx.stroke();
            }

            // Draw "RAMP" label with glow
            ctx.save();
            if (!rampDropTargetActive) {
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 8;
            }
            ctx.fillStyle = rampDropTargetActive ? '#666666' : '#00ff88';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('RAMP', 55, 250);
            ctx.restore();

            // Draw spinner - realistic coin-flip style with enhanced effects
            if (table2Spinner) {
                const spinnerWidth = 30;
                const spinnerHeight = 20;
                const spinPhase = (spinnerAngle * Math.PI) / 180;
                const apparentWidth = Math.abs(Math.cos(spinPhase)) * spinnerHeight;
                const isSpinning = spinnerSpeed > 5;

                ctx.save();
                ctx.translate(SPINNER_X, SPINNER_Y);

                // Glow when spinning
                if (isSpinning) {
                    const spinGlow = ctx.createRadialGradient(0, 0, 5, 0, 0, 25);
                    spinGlow.addColorStop(0, 'rgba(0, 255, 136, 0.4)');
                    spinGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = spinGlow;
                    ctx.beginPath();
                    ctx.arc(0, 0, 25, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Axle with 3D effect
                const axleGrad = ctx.createLinearGradient(0, -2, 0, 2);
                axleGrad.addColorStop(0, '#008855');
                axleGrad.addColorStop(0.5, '#00aa66');
                axleGrad.addColorStop(1, '#006644');
                ctx.strokeStyle = axleGrad;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(-spinnerWidth / 2, 0);
                ctx.lineTo(spinnerWidth / 2, 0);
                ctx.stroke();

                // Spinning blade
                const rectWidth = Math.max(2, apparentWidth);
                const bladeGrad = ctx.createLinearGradient(-rectWidth / 2, 0, rectWidth / 2, 0);
                bladeGrad.addColorStop(0, '#00aa66');
                bladeGrad.addColorStop(0.3, '#00ffaa');
                bladeGrad.addColorStop(0.7, '#00ffaa');
                bladeGrad.addColorStop(1, '#00aa66');

                ctx.fillStyle = bladeGrad;
                ctx.fillRect(-rectWidth / 2, -spinnerWidth / 2, rectWidth, spinnerWidth);

                // Edge highlights
                ctx.strokeStyle = '#aaffdd';
                ctx.lineWidth = 1;
                ctx.strokeRect(-rectWidth / 2, -spinnerWidth / 2, rectWidth, spinnerWidth);

                ctx.restore();

                // Spinner label
                ctx.save();
                if (isSpinning) {
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 8;
                }
                ctx.fillStyle = '#00ff88';
                ctx.font = 'bold 8px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SPIN', SPINNER_X, SPINNER_Y + 22);
                ctx.restore();
            }

            // Draw scoop with enhanced 3D effect
            if (table2Scoop) {
                const scoopColor = scoopBallLocked ? '#ff00ff' : '#8800ff';

                // Glow when ball locked
                if (scoopBallLocked) {
                    ctx.save();
                    const scoopGlow = ctx.createRadialGradient(SCOOP_X, SCOOP_Y, 5, SCOOP_X, SCOOP_Y, 30);
                    scoopGlow.addColorStop(0, 'rgba(255, 0, 255, 0.5)');
                    scoopGlow.addColorStop(0.5, 'rgba(255, 0, 255, 0.2)');
                    scoopGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = scoopGlow;
                    ctx.beginPath();
                    ctx.arc(SCOOP_X, SCOOP_Y, 30, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Scoop rim with depth
                ctx.save();
                ctx.shadowColor = scoopColor;
                ctx.shadowBlur = 10;
                ctx.strokeStyle = scoopColor;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(SCOOP_X, SCOOP_Y, SCOOP_RADIUS + 2, Math.PI * 0.3, Math.PI * 0.7, true);
                ctx.stroke();
                ctx.restore();

                // Scoop hole gradient
                const holeGrad = ctx.createRadialGradient(SCOOP_X, SCOOP_Y, 0, SCOOP_X, SCOOP_Y, SCOOP_RADIUS);
                holeGrad.addColorStop(0, '#110022');
                holeGrad.addColorStop(0.7, '#220044');
                holeGrad.addColorStop(1, '#330066');
                ctx.fillStyle = holeGrad;
                ctx.beginPath();
                ctx.arc(SCOOP_X, SCOOP_Y, SCOOP_RADIUS - 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw locked ball in scoop
                if (scoopBallLocked) {
                    const lockPulse = 0.8 + 0.2 * Math.sin(frame * 0.15);
                    ctx.save();
                    ctx.globalAlpha = lockPulse;
                    drawBall3D(SCOOP_X, SCOOP_Y, BALL_RADIUS, 0, 0);
                    ctx.restore();

                    // "LOCKED" text with glow
                    ctx.save();
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = frame % 10 < 5 ? '#ff00ff' : '#ffffff';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('LOCKED', SCOOP_X, SCOOP_Y + 28);
                    ctx.restore();
                }

                // Scoop label
                ctx.save();
                ctx.shadowColor = scoopColor;
                ctx.shadowBlur = 5;
                ctx.fillStyle = scoopColor;
                ctx.font = 'bold 8px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('LOCK', SCOOP_X, SCOOP_Y - 22);
                ctx.restore();
            }

            // Draw standup target bank labels
            ctx.fillStyle = standupBankLeft.every(t => t) ? '#00ff00' : '#006600';
            ctx.font = 'bold 9px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('MULT', 50, 405);
            ctx.fillText('+' + (standupBankLeftCompletions + 1) + 'X', 50, 495);

            ctx.fillStyle = standupBankRight.every(t => t) ? '#00ff00' : '#006600';
            ctx.fillText('MULT', 290, 405);
            ctx.fillText('+' + (standupBankRightCompletions + 1) + 'X', 290, 495);

            // Multiball ready indicator
            if (multiballReady) {
                ctx.save();
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 20;
                ctx.fillStyle = frame % 8 < 4 ? '#ff00ff' : '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('MULTIBALL READY!', TABLE_WIDTH / 2, 80);
                ctx.restore();
            }

            // Multiball active indicator
            if (multiballActive) {
                ctx.save();
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.fillStyle = frame % 6 < 3 ? '#00ffff' : '#ff00ff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('MULTIBALL!', TABLE_WIDTH / 2, 70);
                ctx.font = 'bold 12px Arial';
                ctx.fillText('2X SCORING', TABLE_WIDTH / 2, 88);
                ctx.restore();
            }

            // Table 2 indicator with subtle glow
            ctx.save();
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 8;
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('TABLE 2', 10, TABLE_HEIGHT - 15);
            ctx.restore();
        }

        // Table transition effect
        if (tableTransitioning && tableTransitionTimer > 0) {
            const progress = 1 - (tableTransitionTimer / 120);
            ctx.save();
            ctx.globalAlpha = Math.sin(progress * Math.PI);
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 30;
            ctx.fillText('TABLE 2', TABLE_WIDTH / 2, TABLE_HEIGHT / 2 - 20);
            ctx.font = 'bold 16px Arial';
            ctx.fillText('ADVANCED MODE', TABLE_WIDTH / 2, TABLE_HEIGHT / 2 + 15);
            ctx.restore();
        }

        // Score multiplier with pulsing glow
        if (scoreMultiplier > 1) {
            ctx.save();
            const multPulse = 0.8 + 0.2 * Math.sin(frame * 0.1);
            ctx.shadowColor = '#ff8800';
            ctx.shadowBlur = 10 * multPulse;
            ctx.fillStyle = '#ff8800';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(scoreMultiplier + 'X', CENTER_X, FLIPPER_Y - 140);
            ctx.restore();
        }

        // Draw ball LAST (on top of everything) with enhanced 3D rendering
        if (ball.x > -50) {
            drawBall3D(ball.x, ball.y, ball.radius, ball.vx, ball.vy);
        }

        // Draw mute button during gameplay
        if (gameState === STATE_PLAYING) {
            const mbx = TABLE_WIDTH - 48;
            const mby = 14;
            ctx.strokeStyle = soundMuted ? '#ff4444' : '#444444';
            ctx.lineWidth = 1;
            ctx.strokeRect(mbx, mby, 38, 20);
            ctx.fillStyle = soundMuted ? '#ff4444' : '#888888';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(soundMuted ? 'MUTE' : 'SND', mbx + 19, mby + 14);
        }

        // Draw level up text
        if (levelUpTimer > 0) {
            const luAlpha = Math.min(1, levelUpTimer / 20);
            ctx.save();
            ctx.globalAlpha = luAlpha;
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('TABLE LEVEL UP!', TABLE_WIDTH / 2, TABLE_HEIGHT / 3);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('LEVEL ' + targetLevel, TABLE_WIDTH / 2, TABLE_HEIGHT / 3 + 28);
            ctx.restore();
        }

        // Draw ball save text
        if (ballSaveTimer > 0) {
            const bsAlpha = Math.min(1, ballSaveTimer / 20);
            ctx.save();
            ctx.globalAlpha = bsAlpha;
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BALL SAVE!', TABLE_WIDTH / 2, TABLE_HEIGHT / 3);
            ctx.restore();
        }

        // Draw extra ball text
        if (extraBallTimer > 0 && levelUpTimer <= 0) {
            const ebAlpha = Math.min(1, extraBallTimer / 20);
            ctx.save();
            ctx.globalAlpha = ebAlpha;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('EXTRA BALL!', TABLE_WIDTH / 2, TABLE_HEIGHT / 3);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('+1 BALL', TABLE_WIDTH / 2, TABLE_HEIGHT / 3 + 24);
            ctx.restore();
        }

        // Draw particles with enhanced glow
        for (const p of particles) {
            const alpha = Math.max(0, p.life / 80);
            ctx.globalAlpha = alpha;

            // Particle glow
            ctx.save();
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 8;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Bright center
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        // Draw state overlay
        if (gameState !== STATE_PLAYING) {
            drawOverlay();
        }

        ctx.restore();

        if (gameStarted && gameState === STATE_PLAYING) {
            document.getElementById('instructions').classList.add('hidden');
        }
    }

    // === GAME LOOP ===
    let lastTime = 0;
    let accumulator = 0;
    const fixedDelta = 1000 / 60;

    function gameLoop(timestamp) {
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;
        accumulator += Math.min(deltaTime, 50);

        if (gameState === STATE_PLAYING) {
            while (accumulator >= fixedDelta) {
                updatePhysics();
                accumulator -= fixedDelta;
                frame++;
            }
        } else {
            while (accumulator >= fixedDelta) {
                accumulator -= fixedDelta;
                frame++;
            }
            updateMenuState();
        }

        draw();
        requestAnimationFrame(gameLoop);
    }

    // === RESIZE HANDLER ===
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const scaleX = canvas.width / TABLE_WIDTH;
        const scaleY = canvas.height / TABLE_HEIGHT;
        scale = Math.min(scaleX, scaleY) * 0.95;

        offsetX = (canvas.width - TABLE_WIDTH * scale) / 2;
        offsetY = (canvas.height - TABLE_HEIGHT * scale) / 2;
    }

    // === INPUT HANDLING ===
    // Track actual key states to detect stuck keys
    let keyboardState = { z: false, slash: false, space: false };

    document.addEventListener('keydown', (e) => {
        initAudio();
        // Left flipper: Z key (primary), Shift-Left (alternative)
        if (e.key === 'z' || e.key === 'Z') { keys.z = true; keyboardState.z = true; }
        if (e.code === 'ShiftLeft') keys.z = true;
        // Right flipper: / key (primary), Shift-Right or X (alternative)
        if (e.key === '/' || e.key === '?') { keys.x = true; keyboardState.slash = true; }
        if (e.code === 'ShiftRight' || e.key === 'x' || e.key === 'X') keys.x = true;
        // Plunger: Space or C
        if (e.code === 'Space' || e.key === 'c' || e.key === 'C') { keys.c = true; keyboardState.space = true; }
        if (e.key === 'v' || e.key === 'V') keys.v = true;
        if ((e.key === 'm' || e.key === 'M') && !e.repeat) {
            soundMuted = !soundMuted;
            try { localStorage.setItem('neonPinballMuted', soundMuted ? 'true' : 'false'); } catch (ex) {}
        }
        // Secret hotkey "2" to instantly switch to Table 2 for testing
        if (e.key === '2' && !e.repeat && gameState === STATE_PLAYING && currentTable === 1) {
            transitionToTable2();
        }
        if (e.code === 'Space') e.preventDefault();
    });

    document.addEventListener('keyup', (e) => {
        // Left flipper release
        if (e.key === 'z' || e.key === 'Z') { keys.z = false; keyboardState.z = false; }
        if (e.code === 'ShiftLeft') keys.z = false;
        // Right flipper release
        if (e.key === '/' || e.key === '?') { keys.x = false; keyboardState.slash = false; }
        if (e.code === 'ShiftRight' || e.key === 'x' || e.key === 'X') keys.x = false;
        // Plunger release
        if (e.code === 'Space' || e.key === 'c' || e.key === 'C') { keys.c = false; keyboardState.space = false; }
        if (e.key === 'v' || e.key === 'V') keys.v = false;
    });

    // Reset all keys when window loses focus (prevents stuck flippers)
    window.addEventListener('blur', () => {
        keys.z = false;
        keys.x = false;
        keys.c = false;
        keys.v = false;
        keyboardState.z = false;
        keyboardState.slash = false;
        keyboardState.space = false;
    });

    // Also reset when window regains focus to catch any missed keyup events
    window.addEventListener('focus', () => {
        keys.z = false;
        keys.x = false;
        keys.c = false;
        keys.v = false;
        keyboardState.z = false;
        keyboardState.slash = false;
        keyboardState.space = false;
    });

    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            keys.z = false;
            keys.x = false;
            keys.c = false;
            keys.v = false;
            keyboardState.z = false;
            keyboardState.slash = false;
            keyboardState.space = false;
        }
    });

    // === TOUCH CONTROLS ===
    document.body.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
    document.body.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

    let activeTouches = new Map();

    function handleTouchStart(e) {
        initAudio();
        for (let touch of e.changedTouches) {
            const x = touch.clientX;
            const y = touch.clientY;
            const width = window.innerWidth;

            // Check overlay buttons in non-playing states
            if (gameState !== STATE_PLAYING) {
                const gameX = (x - offsetX) / scale;
                const gameY = (y - offsetY) / scale;
                const action = checkOverlayButtonHit(gameX, gameY);
                if (action) {
                    overlayTap = action;
                    continue;
                }
                // Fallthrough for left/right scroll in welcome/menu states
            }

            // Check mute button during gameplay
            if (gameState === STATE_PLAYING) {
                const gameX = (x - offsetX) / scale;
                const gameY = (y - offsetY) / scale;
                if (gameX >= TABLE_WIDTH - 48 && gameX <= TABLE_WIDTH - 10 && gameY >= 14 && gameY <= 34) {
                    soundMuted = !soundMuted;
                    try { localStorage.setItem('neonPinballMuted', soundMuted ? 'true' : 'false'); } catch (ex) {}
                    continue;
                }
            }

            if (x < width * 0.5) {
                activeTouches.set(touch.identifier, { zone: 'left', startY: y });
                keys.z = true;
            } else {
                activeTouches.set(touch.identifier, { zone: 'right', startY: y });
                keys.x = true;
            }
        }
    }

    function handleTouchMove(e) {
        for (let touch of e.changedTouches) {
            const touchData = activeTouches.get(touch.identifier);
            if (touchData && touchData.zone === 'right') {
                const deltaY = touch.clientY - touchData.startY;
                if (deltaY > 30) {
                    keys.c = true;
                    touchData.swiping = true;
                }
            }
        }
    }

    function handleTouchEnd(e) {
        for (let touch of e.changedTouches) {
            const touchData = activeTouches.get(touch.identifier);
            activeTouches.delete(touch.identifier);

            let stillLeft = false, stillRight = false;
            for (let [id, data] of activeTouches) {
                if (data.zone === 'left') stillLeft = true;
                if (data.zone === 'right') stillRight = true;
            }

            if (!stillLeft) keys.z = false;
            if (!stillRight) keys.x = false;

            if (touchData && touchData.swiping) {
                keys.c = false;
            }
        }
    }

    document.addEventListener('touchstart', handleTouchStart, { passive: false });
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd, { passive: false });
    document.addEventListener('touchcancel', handleTouchEnd, { passive: false });

    // Mouse controls with overlay button support
    canvas.addEventListener('mousedown', (e) => {
        initAudio();
        const x = e.clientX;
        const y = e.clientY;
        const width = window.innerWidth;

        // Check overlay buttons in non-playing states
        if (gameState !== STATE_PLAYING) {
            const gameX = (x - offsetX) / scale;
            const gameY = (y - offsetY) / scale;
            const action = checkOverlayButtonHit(gameX, gameY);
            if (action) {
                overlayTap = action;
                return;
            }
            // Left/right half for flipper scroll in menus
            if (e.button === 0) {
                if (x < width * 0.5) { keys.z = true; } else { keys.x = true; }
            }
            return;
        }

        // Check mute button
        const gameX = (x - offsetX) / scale;
        const gameY = (y - offsetY) / scale;
        if (gameX >= TABLE_WIDTH - 48 && gameX <= TABLE_WIDTH - 10 && gameY >= 14 && gameY <= 34) {
            soundMuted = !soundMuted;
            try { localStorage.setItem('neonPinballMuted', soundMuted ? 'true' : 'false'); } catch (ex) {}
            return;
        }

        if (e.button === 0) {
            if (x < width * 0.5) { keys.z = true; } else { keys.x = true; }
        }
        if (e.button === 2) { keys.c = true; }
    });

    canvas.addEventListener('mouseup', (e) => {
        if (e.button === 0) { keys.z = false; keys.x = false; }
        if (e.button === 2) { keys.c = false; }
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // === INITIALIZATION ===
    loadHighScores();
    initialsChars = loadSavedInitials();
    currentInitialPos = 0;
    gameState = STATE_WELCOME;
    document.getElementById('instructions').classList.add('hidden');
    window.addEventListener('resize', resize);
    resize();
    buildTable();
    requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
