<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PinbALL or Nothing</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #03010e;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background:
                radial-gradient(ellipse at 50% 20%, rgba(255,0,200,0.06) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 80%, rgba(0,40,120,0.2) 0%, transparent 60%);
            pointer-events: none;
            z-index: 0;
        }

        #gameCanvas {
            display: block;
            background: transparent;
            position: relative;
            z-index: 1;
        }

        /* DMD rendered on canvas - no HTML CSS needed */

        /* Instructions overlay */
        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-family: 'Orbitron', monospace;
            color: #fff;
            z-index: 30;
            pointer-events: none;
            opacity: 0.9;
            transition: opacity 0.5s;
        }

        #instructions.hidden {
            opacity: 0;
        }

        #instructions h1 {
            font-size: 2.5em;
            color: #ff00ff;
            margin-bottom: 20px;
            letter-spacing: 5px;
            text-shadow: 0 0 20px rgba(255,0,255,0.8);
        }

        #instructions p {
            font-size: 0.8em;
            margin: 10px 0;
            color: #40e0ff;
            font-family: 'Share Tech Mono', monospace;
            letter-spacing: 1px;
        }

        .key {
            display: inline-block;
            background: rgba(255, 0, 200, 0.15);
            padding: 3px 10px;
            border-radius: 3px;
            margin: 0 4px;
            border: 1px solid rgba(255, 0, 200, 0.5);
            color: #ff80e8;
            font-family: 'Share Tech Mono', monospace;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- DMD rendered on canvas – hidden off-screen buffer -->
    <canvas id="dmdCanvas" style="display:none"></canvas>
    <!-- hidden score/ball spans for JS references -->
    <span id="score"  style="display:none">0</span>
    <span id="balls"  style="display:none">3</span>

    <!-- Instructions -->
    <div id="instructions">
        <h1>PinbALL or Nothing</h1>
        <p>Keyboard: <span class="key">Z</span> Left <span class="key">/</span> Right <span class="key">SPACE</span> Launch <span class="key">V</span> Confirm</p>
        <p>Touch: Left/Right sides for flippers</p>
        <p>Swipe down to pull and release launcher</p>
    </div>

    <script>
    // ============================================
    // PinbALL or Nothing - Based on Lu1ky Pinball
    // ============================================

    'use strict';

    // === FIREBASE SETUP ===
    // REPLACE with your web app config from Firebase Console > Project Settings > Your apps > Web app
    const firebaseConfig = {
        apiKey: "AIzaSyA04wso_wktEiTj8eH4nUwoLM7tYFvn_9Y",
        authDomain: "pinballornothing.firebaseapp.com",
        databaseURL: "https://pinballornothing-default-rtdb.firebaseio.com",
        projectId: "pinballornothing",
        storageBucket: "pinballornothing.firebasestorage.app",
        messagingSenderId: "649858808879",
        appId: "1:649858808879:web:0df7f8ea752d77f8551ada",
        measurementId: "G-6JRG1PK20E"
    };

    let firebaseReady = false;
    let db = null;
    try {
        firebase.initializeApp(firebaseConfig);
        db = firebase.database();
        firebaseReady = true;
    } catch (e) {
        console.warn('Firebase init failed:', e);
    }

    function submitScoreToFirebase(initials, scoreVal, tableLevel) {
        if (!firebaseReady || !db) return;
        try {
            db.ref('scores').push().set({
                initials: initials,
                score: scoreVal,
                date: new Date().toISOString(),
                maxTableLevel: tableLevel || 0
            });
        } catch (e) { console.warn('Firebase submit failed:', e); }
    }

    function loadOnlineScores(callback) {
        if (!firebaseReady || !db) { callback([]); return; }
        try {
            db.ref('scores')
              .orderByChild('score')
              .limitToLast(10)
              .once('value', (snapshot) => {
                  const scores = [];
                  snapshot.forEach(child => { scores.push(child.val()); });
                  scores.sort((a, b) => b.score - a.score);
                  callback(scores);
              }, () => callback([]));
        } catch (e) { callback([]); }
    }

    // === SOUND SYSTEM ===
    const SndCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    const soundBuffers = {};
    let audioInitialized = false;
    let lastWallSoundTime = 0;

    function initAudio() {
        if (audioCtx) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            return;
        }
        try {
            audioCtx = new SndCtx();
            audioInitialized = true;
            loadAllSounds();
        } catch (e) { console.warn('Audio init failed:', e); }
    }

    async function loadSound(name, url) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            soundBuffers[name] = await audioCtx.decodeAudioData(arrayBuffer);
        } catch (e) {}
    }

    async function loadAllSounds() {
        const sounds = [
            'Flipper1', 'Flipper2', 'Flipper3',
            'PopBumper1', 'PopBumper2', 'PopBumper3', 'PopBumper4', 'PopBumper5',
            'SlingShot1', 'SlingShot2', 'SlingShot3',
            'Wall1', 'Wall2', 'Wall3',
            'Plunge', 'BallDrain', 'BallSave', 'TableLevelUp'
        ];
        for (const s of sounds) {
            await loadSound(s, 'PinballSounds/' + s + '.mp3');
        }
    }

    function playSound(name) {
        if (!audioCtx || !soundBuffers[name] || soundMuted) return;
        try {
            const source = audioCtx.createBufferSource();
            source.buffer = soundBuffers[name];
            source.connect(audioCtx.destination);
            source.start(0);
        } catch (e) {}
    }

    function playRandomSound(prefix, count) {
        playSound(prefix + (Math.floor(Math.random() * count) + 1));
    }

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // === CONSTANTS ===
    const TABLE_WIDTH = 400;
    const TABLE_HEIGHT = 700;
    const CENTER_X = TABLE_WIDTH / 2 - 20;
    const OX = CENTER_X;   // Overlay horizontal centre (same as visual centre of playfield)
    const BALL_RADIUS = 7;
    const WALL_RADIUS = 5;
    const DOME_RADIUS = 150;
    const FLIPPER_RADIUS = 10;
    const FLIPPER_SEGMENTS = 45;
    const FLIPPER_SPREAD = 55;
    const FLIPPER_Y = TABLE_HEIGHT - 60;
    const FLIPPER_Y_ACTUAL = FLIPPER_Y + 14;
    const FLIPPER_CENTER = CENTER_X - BALL_RADIUS - WALL_RADIUS;
    const SHOOTER_X = CENTER_X + DOME_RADIUS - BALL_RADIUS;
    const SHOOTER_Y = TABLE_HEIGHT - 60;
    const RESTITUTION = 1.3;
    const BUMPER_RESTITUTION = 1.7;
    const PHYSICS_SUBSTEPS = 9;
    const GRAVITY = 0.0017;
    


    const TOP_LANE_Y = 55;
    const TOP_LANE_PINS = [CENTER_X - 60, CENTER_X - 20, CENTER_X + 20, CENTER_X + 60];

    const TYPE_WALL = 0;
    const TYPE_BUMPER = 1;
    const TYPE_DROP_TARGET = 2;

    const SPOT_TARGET_POSITIONS = [
        {x: 300, y: 280}, {x: 300, y: 320}, {x: 300, y: 360}, {x: 300, y: 400}
    ];
    const BUMPER_COLORS = ['#ff0000', '#00ff00', '#0088ff', '#ff00ff', '#ff8800'];

    const SAUCER_X = CENTER_X;
    const SAUCER_Y = 200;
    const SAUCER_RADIUS = 10;
    const SAUCER_CAPTURE_SPEED = 0.15;
    const SAUCER_HOLD_TIME = 120;
    const SAUCER_THRESHOLDS = [100, 500, 1000, 2000, 5000, 10000, 25000, 50000];

    const DROP_COLORS = ['#ffff00', '#ff8800', '#ff4400', '#ff00ff', '#00ffff', '#ffffff'];
    const SPOT_DARK = ['#660000', '#663300', '#666600', '#006633', '#003366', '#666666'];
    const SPOT_LIT = ['#ff3300', '#ff8800', '#ffff00', '#00ff66', '#0088ff', '#ffffff'];

    // Table 2 Constants
    const ENABLE_SAUCER_TABLE2_TRANSITION = false; // keep table 2 accessible via key "2"

    const TYPE_STANDUP_TARGET = 3;
    const TYPE_RAMP = 4;
    const TYPE_SPINNER2 = 5;
    const TYPE_SCOOP2 = 6;

    // === TABLE 3 SPECIAL FEATURE COLLECTIONS ===
    let spinners = [];
    let scoops = [];
    let standups = [];
    let lanes = []; // ramp/wireform lane assists

    // New (safe) types. Choose numbers not used by your existing TYPE_* constants.
    const TYPE_SPINNER = 901;
    const TYPE_SCOOP   = 902;
    const TYPE_STANDUP = 903;
    const TYPE_SENSOR  = 904; // generic trigger if needed

    // Ramp entry position (top left)
    const RAMP_ENTRY_X = 55;
    const RAMP_ENTRY_Y = 180;
    const RAMP_EXIT_X = 110;
    const RAMP_EXIT_Y = 130;

    // Drop target blocking ramp
    const RAMP_DROP_X = 55;
    const RAMP_DROP_Y = 200;

    // Spinner at ramp exit
    const SPINNER_X = 120;
    const SPINNER_Y = 145;
    const SPINNER_RADIUS = 12;

    // Scoop position (right side - moved left to avoid shooter lane)
    const SCOOP_X = 280;
    const SCOOP_Y = 350;
    const SCOOP_RADIUS = 15;

    // Pop bumper positions for table 2
    // Moved lower bumpers outward to prevent ball getting stuck between them
    const TABLE2_BUMPER_POSITIONS = [
        {x: CENTER_X - 50, y: 280},
        {x: CENTER_X + 50, y: 280},
        {x: CENTER_X, y: 320}
    ];

    // Standup target bank positions
    const STANDUP_LEFT_POSITIONS = [
        {x: 50, y: 420}, {x: 50, y: 450}, {x: 50, y: 480}
    ];
    const STANDUP_RIGHT_POSITIONS = [
        {x: 290, y: 420}, {x: 290, y: 450}, {x: 290, y: 480}
    ];

    const LANE_LIGHT_Y = FLIPPER_Y - 35;
    const LANE_LIGHT_POSITIONS = [
        {x: 42, y: LANE_LIGHT_Y}, {x: 73, y: LANE_LIGHT_Y},
        {x: 263, y: LANE_LIGHT_Y}, {x: 295, y: LANE_LIGHT_Y}
    ];

    // Game states
    const STATE_WELCOME = 0;
    const STATE_PLAYING = 1;
    const STATE_GAME_OVER = 2;
    const STATE_MENU = 3;
    const STATE_LEADERBOARD = 4;
    const STATE_STATS = 5;
    const STATE_CHOOSE_MODIFIER = 6;

    const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const MAX_HIGH_SCORES = 10;

    // === GAME STATE ===
    let objects = [];
    let score = 0;
    let ballCount = 3;
    let frame = 0;
    let gameStarted = false;
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;

    // DMD-style score display helper - feeds both hidden span and DMD canvas
    const _scoreEl = document.getElementById('score');
    function updateScoreDisplay(val) {
        _scoreEl.textContent = String(val).padStart(8, '0');
        if (window.dmdSetScore) window.dmdSetScore(val);
    }
    updateScoreDisplay(0);

    // =====================================================
    // === DMD DISPLAY SYSTEM (Deep Space Edition) ===
    // =====================================================
    (function() {
        const dmd = document.getElementById('dmdCanvas');
        if (!dmd) return;
        const dctx = dmd.getContext('2d');
        // Match the panel pixel dimensions used by drawDMDOnCanvas
        dmd.width  = 233;   // DMD_W - 4  (237-4)
        dmd.height = 60;    // DMD_H - 4  (64-4)

        // Color palette
        const C_ORANGE  = '#ff8800';
        const C_AMBER   = '#ffcc00';
        const C_WHITE   = '#fff8f0';
        const C_DIM     = '#442200';
        const C_MAGENTA = '#ff00cc';
        const C_CYAN    = '#40e0ff';

        // DMD modes - cycling during gameplay attract
        const MODES = ['attract','score','multiball','jackpot','bonus','warpspeed','gameover'];
        let dmdMode = 'attract';
        let modeIndex = 0;
        let lastModeSwitch = 0;
        const modeDurations = {
            attract:5000, score:4000, multiball:3000,
            jackpot:3000, bonus:3000, warpspeed:3500, gameover:3000
        };

        // Score tracking
        let dmdDisplayScore = 0;
        let dmdTargetScore = 0;

        // Scrolling text
        let scrollX = dmd.width;
        const scrollMessages = [
            'PinbALL or Nothing',
            'SHOOT THE SAUCER',
            'MULTIBALL READY',
            'EXTRA BALL BONUS',
            'HYPERSPACE JACKPOT',
            'WARP SPEED BONUS',
        ];
        let scrollMsgIndex = 0;
        let scrollMsg = scrollMessages[0];

        // Starfield
        const dmdStars = Array.from({length:55}, () => ({
            x: Math.random()*296,
            y: Math.random()*88,
            speed: 0.1 + Math.random()*0.9,
            size: Math.random() < 0.18 ? 2 : 1,
        }));

        // Warp lines
        const warpLines = Array.from({length:10}, (_,i) => ({
            angle: (i/10)*Math.PI*2,
            len: 0,
            speed: 0.3 + Math.random()*0.9,
        }));

        // Explosion particles for jackpot / callout modes
        const dmdParticles = [];

        // Blink state
        let blinkOn = true;
        let lastBlink = 0;

        // Game state mirror (read by updateDmdFromGame)
        window._dmdGameScore = 0;
        window._dmdGameBalls = 3;
        window._dmdGameState = 'idle'; // 'playing', 'gameover', 'idle'
        window._dmdTrigger = null;     // 'multiball','jackpot','levelup','ballsave','extraball'

        const callouts = [
            { mode:'multiball', lines:['MULTI','BALL!'],      colors:[C_MAGENTA, C_AMBER]  },
            { mode:'jackpot',   lines:['JACKPOT','!!!'],       colors:[C_AMBER,   C_CYAN]   },
            { mode:'bonus',     lines:['LEVEL','UP!'],         colors:[C_CYAN,    C_AMBER]  },
            { mode:'warpspeed', lines:['WARP','SPEED!'],       colors:[C_CYAN,    C_MAGENTA]},
            { mode:'gameover',  lines:['GAME','OVER'],         colors:['#ff3300', C_DIM]    },
        ];

        function dmdDrawStars(ts) {
            dmdStars.forEach(s => {
                s.x -= s.speed * (dmdMode === 'warpspeed' ? 5 : 0.55);
                if (s.x < 0) { s.x = 296; s.y = Math.random()*88; }
                const bright = dmdMode === 'warpspeed' ? 1 : 0.35 + Math.random()*0.35;
                dctx.fillStyle = `rgba(255,240,220,${bright})`;
                dctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.size, s.size);
            });
        }

        function dmdDrawWarpLines() {
            const cx = dmd.width/2, cy = dmd.height/2;
            warpLines.forEach((l, i) => {
                l.len += l.speed * 4;
                if (l.len > 200) l.len = 0;
                const x2 = cx + Math.cos(l.angle)*l.len;
                const y2 = cy + Math.sin(l.angle)*l.len;
                const alpha = Math.min(l.len/80, 1);
                dctx.beginPath();
                dctx.moveTo(cx, cy);
                dctx.lineTo(x2, y2);
                dctx.strokeStyle = i%2===0
                    ? `rgba(255,0,200,${alpha*0.8})`
                    : `rgba(64,224,255,${alpha*0.6})`;
                dctx.lineWidth = 1;
                dctx.stroke();
            });
        }

        function dmdDrawExplosion() {
            if (Math.random() < 0.3) {
                for (let i = 0; i < 3; i++) {
                    const angle = Math.random()*Math.PI*2;
                    const spd = 0.5 + Math.random()*2;
                    dmdParticles.push({
                        x:148, y:44,
                        vx:Math.cos(angle)*spd,
                        vy:Math.sin(angle)*spd,
                        life:1,
                        decay:0.02+Math.random()*0.04,
                        color:Math.random()<0.5?'255,0,200':'255,200,0',
                    });
                }
            }
            for (let i = dmdParticles.length-1; i >= 0; i--) {
                const p = dmdParticles[i];
                p.x += p.vx; p.y += p.vy; p.life -= p.decay;
                if (p.life <= 0) { dmdParticles.splice(i,1); continue; }
                dctx.fillStyle = `rgba(${p.color},${p.life})`;
                dctx.fillRect(Math.floor(p.x), Math.floor(p.y), 2, 2);
            }
        }

        function dmdDrawText(text, x, y, size, color, shadow) {
            if (shadow) { dctx.shadowBlur = 12; dctx.shadowColor = shadow; }
            dctx.fillStyle = color;
            dctx.font = `bold ${size}px 'Share Tech Mono', monospace`;
            dctx.textAlign = 'center';
            dctx.textBaseline = 'middle';
            dctx.fillText(text, x, y);
            dctx.shadowBlur = 0;
        }

        function dmdDrawScore(score) {
            const s = String(score).padStart(8,'0');
            dctx.font = "bold 26px 'Share Tech Mono'";
            dctx.textAlign = 'center';
            dctx.textBaseline = 'middle';
            dctx.shadowBlur = 18;
            dctx.shadowColor = C_AMBER;
            dctx.fillStyle = C_WHITE;
            dctx.fillText(s, dmd.width/2, dmd.height/2);
            dctx.shadowBlur = 0;
        }

        function dmdDrawDotGrid() {
            dctx.fillStyle = 'rgba(0,0,0,0.22)';
            for (let y = 1; y < 88; y += 4) {
                for (let x = 1; x < 296; x += 4) {
                    dctx.fillRect(x, y, 1, 1);
                }
            }
        }

        function dmdAnimate(ts) {
            // Check for game-driven trigger overrides
            if (window._dmdTrigger) {
                const trig = window._dmdTrigger;
                window._dmdTrigger = null;
                if (trig === 'multiball') { dmdMode = 'multiball'; lastModeSwitch = ts; }
                else if (trig === 'jackpot') { dmdMode = 'jackpot'; lastModeSwitch = ts; }
                else if (trig === 'levelup') { dmdMode = 'bonus'; lastModeSwitch = ts; }
                else if (trig === 'ballsave') { dmdMode = 'bonus'; lastModeSwitch = ts; }
                else if (trig === 'extraball') { dmdMode = 'jackpot'; lastModeSwitch = ts; }
                else if (trig === 'gameover') { dmdMode = 'gameover'; lastModeSwitch = ts; }
            }

            // Sync target score from game
            dmdTargetScore = window._dmdGameScore || 0;

            // Mode cycling (only in idle/attract; game overrides via trigger)
            if (window._dmdGameState === 'playing' && dmdMode !== 'gameover') {
                const dur = modeDurations[dmdMode] || 4000;
                if (ts - lastModeSwitch > dur) {
                    lastModeSwitch = ts;
                    // Cycle: attract -> score -> attract -> score ...
                    if (dmdMode === 'attract') {
                        dmdMode = 'score';
                        scrollX = 296;
                    } else if (dmdMode === 'score') {
                        dmdMode = 'attract';
                    } else {
                        // After callout, go back to score
                        dmdMode = 'score';
                    }
                }
            } else if (window._dmdGameState === 'idle') {
                const dur = modeDurations[dmdMode] || 5000;
                if (ts - lastModeSwitch > dur) {
                    lastModeSwitch = ts;
                    modeIndex = (modeIndex + 1) % MODES.length;
                    dmdMode = MODES[modeIndex];
                    if (dmdMode === 'attract') scrollX = dmd.width;
                }
            }

            // Smooth score counter
            if (dmdDisplayScore < dmdTargetScore) dmdDisplayScore = Math.min(dmdDisplayScore + Math.ceil((dmdTargetScore - dmdDisplayScore)/8)+1, dmdTargetScore);
            if (dmdDisplayScore > dmdTargetScore) dmdDisplayScore = dmdTargetScore;

            // Blink toggle
            if (ts - lastBlink > 500) { blinkOn = !blinkOn; lastBlink = ts; }

            // Clear & semi-transparent background so playfield shows through
            dctx.clearRect(0, 0, dmd.width, dmd.height);
            const bgGrad = dctx.createLinearGradient(0,0,0,dmd.height);
            bgGrad.addColorStop(0, 'rgba(8,0,15,0.55)');
            bgGrad.addColorStop(1, 'rgba(4,0,8,0.60)');
            dctx.fillStyle = bgGrad;
            dctx.fillRect(0, 0, dmd.width, dmd.height);

            // Stars always
            dmdDrawStars(ts);

            const pulse = 0.5 + 0.5*Math.sin(ts*0.006);

            if (dmdMode === 'attract') {
                dmdDrawWarpLines();
                // Scrolling title
                dctx.font = "bold 20px 'Orbitron', monospace";
                dctx.textAlign = 'left';
                dctx.textBaseline = 'middle';
                dctx.shadowBlur = 14;
                dctx.shadowColor = C_MAGENTA;
                dctx.fillStyle = C_MAGENTA;
                dctx.fillText(scrollMsg, scrollX, dmd.height*0.42);
                // Sub line
                dctx.shadowBlur = 8;
                dctx.shadowColor = C_CYAN;
                dctx.fillStyle = C_CYAN;
                dctx.font = "10px 'Share Tech Mono'";
                dctx.fillText('PRESS START   SHOOT THE SAUCER', scrollX + 8, dmd.height*0.72);
                dctx.shadowBlur = 0;
                scrollX -= 1.3;
                const w = dctx.measureText(scrollMsg).width;
                if (scrollX < -w - 20) {
                    scrollX = 296;
                    scrollMsgIndex = (scrollMsgIndex + 1) % scrollMessages.length;
                    scrollMsg = scrollMessages[scrollMsgIndex];
                }
                // Blinking high score
                if (blinkOn) {
                    dctx.font = "bold 9px 'Share Tech Mono'";
                    dctx.textAlign = 'center';
                    dctx.fillStyle = 'rgba(255,200,0,0.65)';
                    dctx.fillText('HIGH SCORE  ' + String(dmdDisplayScore).padStart(8,'0'), dmd.width/2, dmd.height-6);
                }

            } else if (dmdMode === 'score') {
                // Score display with PLAYER / BALL labels
                dctx.font = "9px 'Share Tech Mono'";
                dctx.textAlign = 'center';
                dctx.fillStyle = 'rgba(255,140,0,0.65)';
                dctx.fillText('PLAYER 1', dmd.width*0.25, 11);
                dctx.fillStyle = 'rgba(64,224,255,0.5)';
                dctx.fillText('PLAYER 2', dmd.width*0.75, 11);
                dmdDrawScore(dmdDisplayScore);
                // Ball count below score
                dctx.font = "9px 'Share Tech Mono'";
                dctx.textAlign = 'center';
                dctx.fillStyle = 'rgba(255,140,0,0.45)';
                const ballsRemain = window._dmdGameBalls || 3;
                dctx.fillText('BALL ' + ballsRemain + '   SHOOT THE SAUCER', dmd.width/2, dmd.height-10);
                // Pulsing score rect
                dctx.strokeStyle = `rgba(255,200,0,${pulse*0.3})`;
                dctx.lineWidth = 1;
                dctx.strokeRect(dmd.width*0.05, dmd.height*0.25, dmd.width*0.9, dmd.height*0.5);

            } else if (dmdMode === 'warpspeed') {
                dmdDrawWarpLines();
                dmdDrawWarpLines();
                const p2 = 0.7 + 0.3*Math.sin(ts*0.012);
                dctx.save();
                dctx.translate(dmd.width/2, dmd.height*0.42);
                dctx.scale(1+p2*0.08, 1+p2*0.05);
                dctx.shadowBlur = 22;
                dctx.shadowColor = C_CYAN;
                dctx.fillStyle = C_CYAN;
                dctx.font = "bold 28px 'Orbitron'";
                dctx.textAlign = 'center';
                dctx.textBaseline = 'middle';
                dctx.fillText('WARP', 0, 0);
                dctx.restore();
                dctx.shadowBlur = 18;
                dctx.shadowColor = C_MAGENTA;
                dctx.fillStyle = C_MAGENTA;
                dctx.font = "bold 22px 'Orbitron'";
                dctx.textAlign = 'center';
                dctx.textBaseline = 'middle';
                dctx.fillText('SPEED!', dmd.width/2, dmd.height*0.84);
                dctx.shadowBlur = 0;

            } else {
                // Callout modes: multiball, jackpot, bonus, gameover
                const co = callouts.find(c => c.mode === dmdMode) || callouts[0];
                dmdDrawExplosion();
                const cp = 0.6 + 0.4*Math.sin(ts*0.009);
                dctx.save();
                dctx.translate(dmd.width/2, dmd.height*0.35);
                dctx.scale(1+cp*0.13, 1+cp*0.09);
                dctx.shadowBlur = 24;
                dctx.shadowColor = co.colors[0];
                dctx.fillStyle = co.colors[0];
                dctx.font = "bold 30px 'Orbitron'";
                dctx.textAlign = 'center';
                dctx.textBaseline = 'middle';
                if (blinkOn || dmdMode === 'gameover') dctx.fillText(co.lines[0], 0, 0);
                dctx.restore();
                dctx.shadowBlur = 18;
                dctx.shadowColor = co.colors[1];
                dctx.fillStyle = co.colors[1];
                dctx.font = "bold 24px 'Orbitron'";
                dctx.textAlign = 'center';
                dctx.textBaseline = 'middle';
                dctx.fillText(co.lines[1], dmd.width/2, dmd.height*0.82);
                dctx.shadowBlur = 0;
                // bottom score
                dctx.font = "9px 'Share Tech Mono'";
                dctx.fillStyle = 'rgba(255,200,0,0.55)';
                dctx.textAlign = 'center';
                dctx.fillText(String(dmdDisplayScore).padStart(8,'0'), dmd.width/2, dmd.height-4);
            }

            // Dot grid overlay
            dmdDrawDotGrid();

            requestAnimationFrame(dmdAnimate);
        }

        requestAnimationFrame(dmdAnimate);

        // Public interface for game to drive the DMD
        window.dmdSetScore = function(s) { window._dmdGameScore = s; };
        window.dmdSetBalls = function(b) {
            window._dmdGameBalls = b;
            const el = document.getElementById('balls');
            if (el) el.textContent = b;
        };
        window.dmdSetState = function(st) { window._dmdGameState = st; };
        window.dmdTrigger = function(ev) { window._dmdTrigger = ev; };
        window.dmdSetMode = function(m) {
            dmdMode = m;
            lastModeSwitch = performance.now();
        };
    })();

    let flipperLeft = 1;
    let flipperRight = 1;
    let keys = { z: false, x: false, c: false, v: false, m: false };
    let soundMuted = false;
    try { soundMuted = localStorage.getItem('neonPinballMuted') === 'true'; } catch (e) {}

    let swipeStartY = 0;
    let isSwiping = false;

    let dropTargets = [];

    let topLaneLights = [false, false, false];
    let ballInTopLane = false;
    let flipperLeftWasPressed = false;
    let flipperRightWasPressed = false;

    let spotTargets = [false, false, false, false];
    let spotCompletions = 0;
    let scoreMultiplier = 1;

    let laneLights = [false, false, false, false];

    let saucerActive = false;
    let saucerTimer = 0;
    let saucerLevel = 0;
    let targetLevel = 0;
    let maxTableLevel = 0;

    // === SCORE POPUPS ===
    let scorePopups = [];
    let scorePopupsSpawnedThisStep = 0;

    const MAX_SCORE_POPUPS_ACTIVE = 22;
    const MAX_SCORE_POPUPS_PER_STEP = 4;     // limits spam per physics step
    const SCORE_POPUP_LIFE = 60;             // 60 frames = ~1 second
    const SCORE_POPUP_STACK_DIST = 18;       // combine nearby popups

    // UI state
    let gameState = STATE_WELCOME;
    let gameOverTimer = 0;
    let finalScore = 0;
    let isNewHighScore = false;
    let initialsChars = [0, 0, 0];
    let currentInitialPos = 0;
    let prevMenuKeys = { z: false, x: false };
    let prevVKey = false;
    let prevPlungeKey = false;
    let highScores = [];
    let onlineScores = [];
    let showOnlineScores = false;
    let particles = [];
    let dsParticles = [];  // Deep space style magenta/cyan burst particles

    function createDsBurst(x, y, count, isMag) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const spd = 0.8 + Math.random() * 3.5;
            const useMag = isMag !== undefined ? isMag : Math.random() < 0.5;
            dsParticles.push({
                x, y,
                vx: Math.cos(angle) * spd,
                vy: Math.sin(angle) * spd,
                life: 1,
                decay: 0.025 + Math.random() * 0.04,
                size: 1.2 + Math.random() * 2.2,
                color: useMag ? [255, 0, 200] : [64, 224, 255],
                trail: 0,
            });
        }
    }
    let overlayTap = null;
    let levelUpTimer = 0;
    let saucerLevelUpDone = false;
    let ballSaveAvailable = true;
    let ballStartScore = 0;
    let ballSaveTimer = 0;
    let extraBallTimer = 0;

    // Session state
    let sessionInitials = null;
    let playerStats = null;

    // Modifier system
    let targetValueMultiplier = 1;
    let allOrNothingActive = false;
    let allOrNothingScoreBackup = 0;
    let extraBallSave3 = false;
    let modifierChoiceLeft = null;
    let modifierChoiceRight = null;
    let modifierScreenTimer = 0;
    let ballsLost = 0;
    let safetyPinActive = false;

    // === MULTI-TABLE SYSTEM ===
    let currentTable = 1;  // 1 = original table, 2 = advanced table
    let tableTransitioning = false;
    let tableTransitionTimer = 0;

    // Table 2 specific elements
    let rampDropTargetActive = true;  // Drop target blocking the ramp
    let spinnerAngle = 0;
    let spinnerSpeed = 0;  // Degrees per frame for continuous spin
    let spinnerHits = 0;
    let spinnerActive = false;  // Whether spinner just activated (triggers drop target reset)

    // Scoop and ball lock system
    let scoopBallLocked = false;
    let lockedBallX = 0;
    let lockedBallY = 0;
    let multiballActive = false;
    let balls = [];  // For multiball - array of ball objects
    let multiballReady = false;  // Ramp+spinner combo activates multiball launch

    // Standup target banks (2 banks of 3 targets each)
    let standupBankLeft = [false, false, false];
    let standupBankRight = [false, false, false];
    let standupBankLeftCompletions = 0;
    let standupBankRightCompletions = 0;

    // Table 2 object references
    let table2DropTarget = null;
    let table2Spinner = null;
    let table2Scoop = null;
    let table2PopBumpers = [];
    let table2StandupTargetsLeft = [];
    let table2StandupTargetsRight = [];
    let table2RampWalls = [];

    // === HIGH SCORE FUNCTIONS ===
    function loadHighScores() {
        try {
            const saved = localStorage.getItem('neonPinballHighScores');
            if (saved) highScores = JSON.parse(saved);
        } catch (e) { highScores = []; }
    }

    function saveHighScores() {
        try {
            localStorage.setItem('neonPinballHighScores', JSON.stringify(highScores));
        } catch (e) {}
    }

    function checkHighScore(s) {
        if (s <= 0) return false;
        if (highScores.length < MAX_HIGH_SCORES) return true;
        return s > highScores[highScores.length - 1].score;
    }

    function addHighScore(initials, s, tableLevel) {
        highScores.push({ initials: initials, score: s, date: new Date().toISOString(), maxTableLevel: tableLevel || 0 });
        highScores.sort((a, b) => b.score - a.score);
        if (highScores.length > MAX_HIGH_SCORES) highScores = highScores.slice(0, MAX_HIGH_SCORES);
        saveHighScores();
    }

    function loadSavedInitials() {
        try {
            const saved = localStorage.getItem('neonPinballInitials');
            if (saved) {
                const parsed = JSON.parse(saved);
                if (Array.isArray(parsed) && parsed.length === 3) return parsed;
            }
        } catch (e) {}
        return [0, 0, 0];
    }

    function saveSavedInitials(chars) {
        try {
            localStorage.setItem('neonPinballInitials', JSON.stringify(chars));
        } catch (e) {}
    }

    // === PLAYER STATS ===
    function defaultStats() {
        return { allTargetsCleared: 0, colorBumperHits: 0, saucerCaptures: 0, extraBallsEarned: 0, maxMultiplier: 1, gamesPlayed: 0, totalScore: 0, modPicks: {} };
    }

    function loadPlayerStats(initials) {
        try {
            const saved = localStorage.getItem('neonPinballStats_' + initials);
            if (saved) return JSON.parse(saved);
        } catch (e) {}
        return defaultStats();
    }

    function savePlayerStats(initials, stats) {
        try {
            localStorage.setItem('neonPinballStats_' + initials, JSON.stringify(stats));
        } catch (e) {}
    }

    function trackStat(key, value) {
        if (!sessionInitials || !playerStats) return;
        if (key === 'maxMultiplier') {
            playerStats.maxMultiplier = Math.max(playerStats.maxMultiplier || 1, value);
        } else {
            playerStats[key] = (playerStats[key] || 0) + (value || 1);
        }
        savePlayerStats(sessionInitials, playerStats);
    }

    // === MODIFIERS ===
    const MODIFIERS = [
        { id: 'double_mult', name: 'DOUBLE', name2: 'MULTIPLIER', desc: 'Doubles your current multiplier' },
        { id: 'upgrade_table', name: 'UPGRADE', name2: 'TABLE', desc: 'Level up the table' },
        { id: 'ball_save_3', name: 'EXTRA BALL', name2: 'SAVE', desc: 'Ball save on last ball' },
        { id: 'light_outlanes', name: 'LIGHT', name2: 'OUTLANES', desc: 'Light outlane lanes' },
        { id: 'extra_ball', name: 'EXTRA', name2: 'BALL', desc: 'Gain one extra ball' },
        { id: 'double_down', name: 'DOUBLE', name2: 'DOWN', desc: 'Targets 2x, lose 1 ball', minBalls: 2 },
        { id: 'double_double', name: 'DOUBLE', name2: 'DOUBLE DOWN', desc: 'Targets 2x, score 2x, last ball', minBalls: 2 },
        { id: 'all_or_nothing', name: 'ALL OR', name2: 'NOTHING', desc: 'Saucer = 3x, drain = 0' },
        { id: 'mulligan', name: 'MULLIGAN', name2: '', desc: 'Get that ball back, keep score', condition: () => ballsLost === 1 && score < 150 },
        { id: 'practice_shot', name: 'PRACTICE', name2: 'SHOT', desc: 'Get that ball back, keep score', condition: () => ballsLost === 1 && score < 50 },
        { id: 'rewind', name: 'REWIND', name2: '', desc: 'Back to 3 balls, score resets to 0', condition: () => ballsLost === 1 && score < 300 },
        { id: 'buy_in', name: 'BUY IN', name2: '-1000', desc: 'Pay 1000 for an extra ball', condition: () => score > 1000 && score <= 5000 },
        { id: 'pay_up', name: 'PAY UP', name2: '-5000', desc: 'Pay 5000 for an extra ball', condition: () => score > 5000 },
        { id: 'income_tax', name: 'INCOME', name2: 'TAX', desc: 'Pay 25% score for ball save', condition: () => score > 1000 },
        { id: 'tax_avoidance', name: 'TAX', name2: 'AVOIDANCE', desc: 'Pay 25% score for extra ball', condition: () => score > 5000 },
        { id: 'all_in', name: 'ALL IN', name2: '', desc: 'Pay 100% score, back to 3 balls', condition: () => score > 5000 },
        { id: 'safety_pin', name: 'SAFETY', name2: 'PIN', desc: 'Center pin Blocks drain for 1 ball', condition: () => score < 1000 }
    ];

    function generateModifierChoices() {
        const valid = MODIFIERS.filter(m => {
            if (m.minBalls && ballCount < m.minBalls) return false;
            if (m.condition && !m.condition()) return false;
            return true;
        });

        const conflicts = (a, b) => {
            if (!a || !b) return false;
            const A = a.id, B = b.id;

            const downSet = new Set(['double_down', 'double_double']);
            const allOrNothing = 'all_or_nothing';

            // Never offer Double Down and Double Double together
            if (downSet.has(A) && downSet.has(B)) return true;

            // Never offer All Or Nothing with either "down" modifier
            if ((A === allOrNothing && downSet.has(B)) || (B === allOrNothing && downSet.has(A))) return true;

            return false;
        };

        const shuffled = valid.slice().sort(() => Math.random() - 0.5);

        modifierChoiceLeft = shuffled[0] || null;

        // pick the first non-conflicting option for right
        modifierChoiceRight = null;
        for (let i = 1; i < shuffled.length; i++) {
            if (!modifierChoiceLeft) break;
            if (shuffled[i].id === modifierChoiceLeft.id) continue;
            if (conflicts(modifierChoiceLeft, shuffled[i])) continue;
            modifierChoiceRight = shuffled[i];
            break;
        }

        // fallback if nothing found (rare): just pick a different one
        if (!modifierChoiceRight) {
            modifierChoiceRight = shuffled.find(m => !modifierChoiceLeft || m.id !== modifierChoiceLeft.id) || null;
        }

        modifierScreenTimer = 0;
    }


    function applyModifier(mod) {
        if (!mod) return;
        switch (mod.id) {
            case 'double_mult':
                scoreMultiplier *= 2;
                trackStat('maxMultiplier', scoreMultiplier);
                break;
            case 'upgrade_table':
                targetLevel++;
                maxTableLevel = Math.max(maxTableLevel, targetLevel);
                dropTargets.forEach(dt => { dt.active = true; });
                break;
            case 'ball_save_3':
                extraBallSave3 = true;
                break;
            case 'light_outlanes':
                laneLights[0] = true;
                laneLights[3] = true;
                if (laneLights.every(l => l)) {
                    ballCount++;
                    document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
                    trackStat('extraBallsEarned');
                    laneLights = [false, false, false, false];
                    extraBallTimer = 120;
                if (window.dmdTrigger) window.dmdTrigger('extraball');
                    createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 2, 40);
                    createFirework(TABLE_WIDTH / 2, TABLE_HEIGHT / 3);
                }
                break;
            case 'extra_ball':
                ballCount++;
                document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
                break;
            case 'double_down':
                targetValueMultiplier *= 2;
                ballCount--;
                document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
                break;
            case 'double_double':
                targetValueMultiplier *= 2;
                score *= 2;
                updateScoreDisplay(score);
                ballCount = 1;
                document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
                break;
            case 'all_or_nothing':
                allOrNothingActive = true;
                allOrNothingScoreBackup = score;
                break;
            case 'mulligan':
            case 'practice_shot':
                ballCount++;
                document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
                break;
            case 'rewind':
                ballCount = 3;
                score = 0;
                updateScoreDisplay(score);
                document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
                break;
            case 'buy_in':
                score -= 1000;
                ballCount++;
                updateScoreDisplay(score);
                document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
                break;
            case 'pay_up':
                score -= 5000;
                ballCount++;
                updateScoreDisplay(score);
                document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
                break;
            case 'income_tax':
                score -= Math.floor(score * 0.25);
                updateScoreDisplay(score);
                ballSaveAvailable = true;
                break;
            case 'tax_avoidance':
                score -= Math.floor(score * 0.25);
                ballCount++;
                updateScoreDisplay(score);
                document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
                break;
            case 'all_in':
                score = 0;
                ballCount = 3;
                updateScoreDisplay(score);
                document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
                break;
            case 'safety_pin':
                safetyPinActive = true;
                for (const o of objects) {
                    if (o.isCenterPin) {
                        o.radius = 18;  // Bigger center pin
                        o.y = FLIPPER_Y + 25;  // Move up between flippers
                        o.color = '#ffff00';  // Yellow to show active
                        break;
                    }
                }
                break;
        }
        // Track modifier pick count
        if (sessionInitials && playerStats) {
            if (!playerStats.modPicks) playerStats.modPicks = {};
            playerStats.modPicks[mod.id] = (playerStats.modPicks[mod.id] || 0) + 1;
            savePlayerStats(sessionInitials, playerStats);
        }
    }

    // === PARTICLES ===
    function createParticles(x, y, count) {
        const colors = ['#ff00ff', '#00ffff', '#ffff00', '#ff0000', '#00ff00', '#ff8800'];
        for (let i = 0; i < count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5 - 1,
                life: 40 + Math.random() * 80,
                color: colors[Math.floor(Math.random() * colors.length)],
                radius: 1 + Math.random() * 3
            });
        }
    }

    function createFirework(x, y) {
        const colors = ['#ff00ff', '#00ffff', '#ffff00', '#ff0000', '#00ff00'];
        for (let i = 0; i < 20; i++) {
            const angle = (Math.PI * 2 * i) / 20;
            const speed = 1 + Math.random() * 2;
            particles.push({
                x: x, y: y,
                vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                life: 30 + Math.random() * 40,
                color: colors[Math.floor(Math.random() * colors.length)],
                radius: 1 + Math.random() * 2
            });
        }
    }

    // === RESET GAME ===
    function resetGame() {
        score = 0;
        ballCount = 3;
        scoreMultiplier = 1;
        spotCompletions = 0;
        spotTargets = [false, false, false, false];
        laneLights = [false, false, false, false];
        saucerActive = false;
        saucerTimer = 0;
        saucerLevel = 0;
        targetLevel = 0;
        maxTableLevel = 0;
        topLaneLights = [false, false, false];
        particles = [];
        ballSaveAvailable = true;
        ballStartScore = 0;
        ballSaveTimer = 0;
        levelUpTimer = 0;
        extraBallTimer = 0;
        saucerLevelUpDone = false;
        targetValueMultiplier = 1;
        allOrNothingActive = false;
        allOrNothingScoreBackup = 0;
        extraBallSave3 = false;
        modifierChoiceLeft = null;
        modifierChoiceRight = null;
        ballsLost = 0;
        safetyPinActive = false;

        // Reset multi-table state
        currentTable = 1;
        tableTransitioning = false;
        tableTransitionTimer = 0;
        rampDropTargetActive = true;
        spinnerAngle = 0;
        spinnerSpeed = 0;
        spinnerHits = 0;
        spinnerActive = false;
        scoopBallLocked = false;
        multiballActive = false;
        multiballReady = false;
        balls = [];
        standupBankLeft = [false, false, false];
        standupBankRight = [false, false, false];
        standupBankLeftCompletions = 0;
        standupBankRightCompletions = 0;

        // Rebuild table 1
        buildTable();

        for (const obj of objects) {
            if (obj.isCenterPin) {
                obj.radius = safetyPinActive ? 18 : 5;
                obj.color = safetyPinActive ? '#ffff00' : '#00ffff';
                break;
            }
        }

        const ball = objects[0];
        ball.x = SHOOTER_X;
        ball.y = SHOOTER_Y - 20;
        ball.vx = 0;
        ball.vy = 0;

        const goStart = 1 + FLIPPER_SEGMENTS * 2;
        for (let si = 0; si < FLIPPER_SEGMENTS; si++) {
            const seg = objects[goStart + si];
            if (seg && seg.isShooter) {
                seg.y = SHOOTER_Y + si;
                seg.vy = 0;
            }
        }

        dropTargets.forEach(dt => { dt.active = true; });

        updateScoreDisplay(score);
        document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
        document.getElementById('instructions').classList.remove('hidden');

        gameStarted = false;
        gameState = STATE_PLAYING;
        if (window.dmdSetState) window.dmdSetState('playing');
        if (window.dmdSetMode) window.dmdSetMode('attract');
        keys.z = false;
        keys.x = false;
        keys.c = false;
        keys.v = false;
    }

    function setupNewBall() {
        // Safety: if modifier reduced ballCount to 0, go to game over
        if (ballCount <= 0) {
            finalScore = score;
            isNewHighScore = checkHighScore(score);
            gameState = STATE_GAME_OVER;
            if (window.dmdSetState) window.dmdSetState('idle');
            if (window.dmdTrigger) window.dmdTrigger('gameover');
            gameOverTimer = 90;
            trackStat('gamesPlayed');
            trackStat('totalScore', finalScore);
            if (isNewHighScore && sessionInitials) {
                addHighScore(sessionInitials, finalScore, maxTableLevel);
                submitScoreToFirebase(sessionInitials, finalScore, maxTableLevel);
            }
            return;
        }
        const ball = objects[0];
        ball.x = CENTER_X + DOME_RADIUS - BALL_RADIUS;
        ball.y = SHOOTER_Y - 20;
        ball.vx = 0;
        ball.vy = 0;
        const rstStart = 1 + FLIPPER_SEGMENTS * 2;
        for (let si = 0; si < FLIPPER_SEGMENTS; si++) {
            const seg = objects[rstStart + si];
            if (seg && seg.isShooter) {
                seg.y = SHOOTER_Y + si;
                seg.vy = 0;
            }
        }
        // Reset ball save for new ball
        ballSaveAvailable = true;
        // Extra ball save on last ball (ball 3 modifier)
        if (extraBallSave3 && ballCount === 1) {
            ballSaveAvailable = true;
        }
        // Reset Safety Pin modifier (only lasts 1 ball)
        if (safetyPinActive) {
            safetyPinActive = false;
            for (const obj of objects) {
                if (obj.isCenterPin) {
                    obj.radius = 5;  // Back to normal size
                    obj.color = '#00ffff';  // Back to cyan
                    break;
                }
            }
        }
        ballStartScore = score;
        // Reset key states to prevent stuck flippers from menu selection
        keys.z = false;
        keys.x = false;
        keys.c = false;
        gameState = STATE_PLAYING;
    }

    // === OBJECT CREATION ===
    function createObject(x, y, type = TYPE_WALL, radius = WALL_RADIUS) {
        objects.push({
            x: x, y: y, type: type, radius: radius,
            vx: 0, vy: 0, bounce: 0,
            color: type === TYPE_BUMPER ? '#ff00ff' : type === TYPE_DROP_TARGET ? '#ffff00' : '#00ffff'
        });
        return objects[objects.length - 1];
    }

    // table 3 helpers
    function createSpinner(x, y, length = 48) {
        const s = {
            type: TYPE_SPINNER,
            x, y,
            length,
            angle: 0,
            angVel: 0,
            // trigger radius used for “hit detect”
            radius: 12,
            cooldown: 0,
            color: '#ffffff',
            value: 25
        };
        spinners.push(s);
        return s;
    }

    function createScoop(x, y, radius = 16) {
        const sc = {
            type: TYPE_SCOOP,
            x, y,
            radius,
            holdTimer: 0,
            cooldown: 0,
            color: '#ffaa00',
            value: 150
        };
        scoops.push(sc);
        return sc;
    }

    function createStandup(x, y, radius = 7, value = 40, color = '#00ffff') {
        const st = {
            type: TYPE_STANDUP,
            x, y,
            radius,
            cooldown: 0,
            color,
            value
        };
        standups.push(st);
        return st;
    }

    // “Lane assist” for ramps/wireforms: if ball is inside a capsule region, apply a gentle push
    function createLaneAssist(name, x1, y1, x2, y2, radius = 18, boost = 0.12) {
    const lane = { name, x1, y1, x2, y2, radius, boost };
    lanes.push(lane);
    return lane;
    }


    // === BUILD TABLE ===
    function buildTable() {
        objects = [];
        dropTargets = [];

        const ball = createObject(CENTER_X + DOME_RADIUS - BALL_RADIUS, SHOOTER_Y - 20);
        ball.radius = BALL_RADIUS;
        ball.color = '#ffffff';
        ball.isBall = true;

        for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
            createObject(0, 0, TYPE_WALL, FLIPPER_RADIUS - i / 6);
            createObject(0, 0, TYPE_WALL, FLIPPER_RADIUS - i / 6);
        }

        for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
            const shooter = createObject(CENTER_X + DOME_RADIUS - BALL_RADIUS, TABLE_HEIGHT - 10 + i, TYPE_WALL, 5);
            shooter.isShooter = true;
            shooter.shooterIndex = i;
        }

        const DOME_BOTH = DOME_RADIUS + WALL_RADIUS;

        // Center pin below flippers (drain blocker for Safety Pin modifier)
        // Normal position: well below flippers so game is still challenging
        // Safety pin active: moves up between flippers for easy saves
        const centerPinY = safetyPinActive ? FLIPPER_Y + 25 : FLIPPER_Y + 54;
        const centerPin = createObject(FLIPPER_CENTER, centerPinY, TYPE_WALL, safetyPinActive ? 18 : 5);
        centerPin.isCenterPin = true;
        centerPin.color = safetyPinActive ? '#ffff00' : '#00ffff';  // Yellow when active, cyan when normal

        for (let side = 0; side < 2; side++) {
            const dir = side * 2 - 1;

            for (let i = 0; i < 90; i++) {
                createObject(CENTER_X + dir * DOME_BOTH, TABLE_HEIGHT - 7 * i);
            }

            for (let i = 0; i < 55; i++) {
                createObject(
                    CENTER_X + dir * DOME_BOTH * Math.cos(i / 35),
                    DOME_BOTH - DOME_BOTH * Math.sin(i / 35)
                );
            }

            for (let i = 0; i < 12; i++) {
                createObject(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55), FLIPPER_Y - 50 - i * 7);
            }

            for (let i = 0; i < 19; i++) {
                createObject(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55 - i * 3), FLIPPER_Y - 50 + i * 3);
            }

            const slingInnerX = FLIPPER_CENTER + dir * FLIPPER_SPREAD;
            const slingOuterX = FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 25);
            const slingTopY = FLIPPER_Y - 120;
            const slingBottomY = FLIPPER_Y - 70;
            const slingBottomInnerY = slingBottomY + 25;

            for (let i = 0; i <= 7; i++) {
                const t = i / 7;
                createObject(slingOuterX, slingTopY + t * (slingBottomY - slingTopY));
            }

            for (let i = 0; i <= 12; i++) {
                const t = i / 12;
                const sObj = createObject(
                    slingOuterX + (slingInnerX - slingOuterX) * t,
                    slingTopY + (slingBottomInnerY - slingTopY) * t,
                    TYPE_BUMPER, 4
                );
                sObj.isSlingshot = true;
            }

            for (let i = 0; i <= 5; i++) {
                const t = i / 5;
                createObject(
                    slingOuterX + (slingInnerX - slingOuterX) * t,
                    slingBottomY + (slingBottomInnerY - slingBottomY) * t
                );
            }
        }

        const bumperY = 160;
        const centerBumper = createObject(CENTER_X, bumperY, TYPE_BUMPER, 12);
        centerBumper.isHighValue = true;
        centerBumper.isCenterBumper = true;
        centerBumper.color = '#ff0000';

        createObject(CENTER_X - 45, bumperY - 45, TYPE_BUMPER, 24);
        createObject(CENTER_X + 45, bumperY - 45, TYPE_BUMPER, 24);
        createObject(CENTER_X - 45, bumperY + 93, TYPE_BUMPER, 24);
        createObject(CENTER_X + 45, bumperY + 93, TYPE_BUMPER, 24);

        createObject(FLIPPER_CENTER - 150, DOME_RADIUS + 90, TYPE_BUMPER, 25);
        createObject(FLIPPER_CENTER + 162, DOME_RADIUS + 90, TYPE_BUMPER, 25);

        createObject(FLIPPER_CENTER - 130, 470, TYPE_BUMPER, 12);
        createObject(FLIPPER_CENTER + 130, 470, TYPE_BUMPER, 12);

        const gridStartY = bumperY + 170;
        for (let side = 0; side < 2; side++) {
        const dir = side * 2 - 1; // -1, +1

        for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 3; col++) {

            // Avoid double-spawning the center pin (col 0 is CENTER_X on both sides)
            if (col === 0 && side === 1) continue;

            // VISUAL TOP row is row === 2  -> XX0XX (keep center only)
            if (row === 2 && col !== 0) continue;

            // VISUAL BOTTOM row is row === 0 -> X000X (remove outer corners only)
            if (row === 0 && col === 2) continue;

            const pin = createObject(
                CENTER_X + col * 26 * dir,
                gridStartY - row * 28,
                TYPE_BUMPER,
                4
            );

            // Optional: keep your existing special-case (this is the MIDDLE row visually)
            if (col === 0 && row === 1) { pin.isHighValue = true; pin.color = '#ff0000'; }
            }
        }
        }



        const dtBaseX = 38;
        const dtBaseY = 300;
        for (let row = 0; row < 4; row++) {
            for (let j = 0; j < 2; j++) {
                const dt = createObject(dtBaseX, dtBaseY + row * 32 + j * 11, TYPE_DROP_TARGET, 5);
                dt.isDropTarget = true;
                dt.active = true;
                dt.dropGroup = row;
                dt.color = '#ffff00';
                dropTargets.push(dt);
            }
        }

        for (let i = 0; i < 4; i++) {
            const pin = createObject(TOP_LANE_PINS[i], TOP_LANE_Y, TYPE_WALL, 5);
            pin.isTopLanePin = true;  // Flag to render this pin
        }

        const shooterWallX = CENTER_X + DOME_RADIUS - BALL_RADIUS * 2 - WALL_RADIUS;
        for (let i = 0; i < 65; i++) {
            createObject(shooterWallX, TABLE_HEIGHT - 7 * i);
        }
    }

    // === BUILD TABLE 2 (Advanced Table) ===
    function buildTable2() {
        // Save ball state before rebuilding
        const oldBall = objects[0];
        const savedBallState = {
            x: SHOOTER_X,  // Reset to shooter position
            y: SHOOTER_Y - 20,
            vx: 0,
            vy: 0
        };

        objects = [];
        dropTargets = [];
        table2PopBumpers = [];
        table2StandupTargetsLeft = [];
        table2StandupTargetsRight = [];
        table2RampWalls = [];

        // Create ball
        const ball = createObject(savedBallState.x, savedBallState.y);
        ball.radius = BALL_RADIUS;
        ball.color = '#ffffff';
        ball.isBall = true;
        ball.vx = savedBallState.vx;
        ball.vy = savedBallState.vy;

        // Create flippers (same as table 1)
        for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
            createObject(0, 0, TYPE_WALL, FLIPPER_RADIUS - i / 6);
            createObject(0, 0, TYPE_WALL, FLIPPER_RADIUS - i / 6);
        }

        // Create shooter lane
        for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
            const shooter = createObject(CENTER_X + DOME_RADIUS - BALL_RADIUS, TABLE_HEIGHT - 10 + i, TYPE_WALL, 5);
            shooter.isShooter = true;
            shooter.shooterIndex = i;
        }

        const DOME_BOTH = DOME_RADIUS + WALL_RADIUS;

        // Center pin below flippers (drain blocker for Safety Pin modifier)
        const centerPinY = safetyPinActive ? FLIPPER_Y + 25 : FLIPPER_Y + 54;
        const centerPin = createObject(FLIPPER_CENTER, centerPinY, TYPE_WALL, safetyPinActive ? 18 : 5);
        centerPin.isCenterPin = true;
        centerPin.color = safetyPinActive ? '#ffff00' : '#00ffff';  // Yellow when active, cyan when normal

        // Create walls, outlanes, and slingshots (same structure as table 1)
        for (let side = 0; side < 2; side++) {
            const dir = side * 2 - 1;

            // Side walls
            for (let i = 0; i < 90; i++) {
                createObject(CENTER_X + dir * DOME_BOTH, TABLE_HEIGHT - 7 * i);
            }

            // Dome curve
            for (let i = 0; i < 55; i++) {
                createObject(
                    CENTER_X + dir * DOME_BOTH * Math.cos(i / 35),
                    DOME_BOTH - DOME_BOTH * Math.sin(i / 35)
                );
            }

            // Outlane walls
            for (let i = 0; i < 12; i++) {
                createObject(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55), FLIPPER_Y - 50 - i * 7);
            }

            for (let i = 0; i < 19; i++) {
                createObject(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55 - i * 3), FLIPPER_Y - 50 + i * 3);
            }

            // Slingshots
            const slingInnerX = FLIPPER_CENTER + dir * FLIPPER_SPREAD;
            const slingOuterX = FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 25);
            const slingTopY = FLIPPER_Y - 120;
            const slingBottomY = FLIPPER_Y - 70;
            const slingBottomInnerY = slingBottomY + 25;

            for (let i = 0; i <= 7; i++) {
                const t = i / 7;
                createObject(slingOuterX, slingTopY + t * (slingBottomY - slingTopY));
            }

            for (let i = 0; i <= 12; i++) {
                const t = i / 12;
                const sObj = createObject(
                    slingOuterX + (slingInnerX - slingOuterX) * t,
                    slingTopY + (slingBottomInnerY - slingTopY) * t,
                    TYPE_BUMPER, 4
                );
                sObj.isSlingshot = true;
            }

            for (let i = 0; i <= 5; i++) {
                const t = i / 5;
                createObject(
                    slingOuterX + (slingInnerX - slingOuterX) * t,
                    slingBottomY + (slingBottomInnerY - slingBottomY) * t
                );
            }
        }

        // === TABLE 2 UNIQUE FEATURES ===

        // Top lane pins (same position)
        for (let i = 0; i < 4; i++) {
            const pin = createObject(TOP_LANE_PINS[i], TOP_LANE_Y, TYPE_WALL, 5);
            pin.isTopLanePin = true;  // Flag to render this pin
        }

        // Shooter wall
        const shooterWallX = CENTER_X + DOME_RADIUS - BALL_RADIUS * 2 - WALL_RADIUS;
        for (let i = 0; i < 65; i++) {
            createObject(shooterWallX, TABLE_HEIGHT - 7 * i);
        }

        // --- LOOP RAMP (Top Left) ---
        // Ramp entrance walls (curved path from left side to top)
        const rampEntranceX = 45;
        const rampEntranceY = 220;

        // Left wall of ramp entrance
        for (let i = 0; i < 15; i++) {
            const wall = createObject(rampEntranceX - 15, rampEntranceY - i * 8, TYPE_WALL, 4);
            wall.isRampWall = true;
            table2RampWalls.push(wall);
        }

        // Right wall of ramp entrance curving to exit
        for (let i = 0; i < 20; i++) {
            const angle = (Math.PI / 2) * (i / 20);
            const wall = createObject(
                rampEntranceX + 25 + 30 * Math.sin(angle),
                rampEntranceY - 20 - 30 * (1 - Math.cos(angle)),
                TYPE_WALL, 4
            );
            wall.isRampWall = true;
            table2RampWalls.push(wall);
        }

        // Ramp exit (curves back down toward playfield)
        for (let i = 0; i < 12; i++) {
            const wall = createObject(
                rampEntranceX + 55 + i * 5,
                rampEntranceY - 60 + i * 3,
                TYPE_WALL, 4
            );
            wall.isRampWall = true;
            table2RampWalls.push(wall);
        }

        // --- DROP TARGET blocking ramp ---
        // Made smaller (radius 5) to prevent ball getting stuck behind
        table2DropTarget = createObject(rampEntranceX + 5, rampEntranceY + 10, TYPE_DROP_TARGET, 5);
        table2DropTarget.isRampDropTarget = true;
        table2DropTarget.active = rampDropTargetActive;
        table2DropTarget.color = '#ff8800';

        // Second drop target segment for wider blocking
        const dt2 = createObject(rampEntranceX + 18, rampEntranceY + 10, TYPE_DROP_TARGET, 5);
        dt2.isRampDropTarget = true;
        dt2.active = rampDropTargetActive;
        dt2.color = '#ff8800';
        dropTargets.push(table2DropTarget);
        dropTargets.push(dt2);

        // Back wall behind drop targets to prevent ball getting stuck
        for (let i = 0; i < 5; i++) {
            createObject(rampEntranceX - 5, rampEntranceY + 5 + i * 5, TYPE_WALL, 3);
        }

        // --- SPINNER at ramp exit ---
        table2Spinner = createObject(SPINNER_X, SPINNER_Y, TYPE_SPINNER, SPINNER_RADIUS);
        table2Spinner.isSpinner = true;
        table2Spinner.color = '#00ff88';
        table2Spinner.spinAngle = 0;

        // --- 3 SMALL POP BUMPERS ---
        for (let i = 0; i < TABLE2_BUMPER_POSITIONS.length; i++) {
            const pos = TABLE2_BUMPER_POSITIONS[i];
            const bumper = createObject(pos.x, pos.y, TYPE_BUMPER, 15);
            bumper.isSmallBumper = true;
            bumper.color = BUMPER_COLORS[i % BUMPER_COLORS.length];
            table2PopBumpers.push(bumper);
        }

        // Center small bumper (like table 1's safety pin target)
        const centerBumper = createObject(CENTER_X, 360, TYPE_BUMPER, 12);
        centerBumper.isHighValue = true;
        centerBumper.isCenterBumper = true;
        centerBumper.color = '#ff0000';

        // --- SCOOP (Ball Lock) ---
        table2Scoop = createObject(SCOOP_X, SCOOP_Y, TYPE_SCOOP, SCOOP_RADIUS);
        table2Scoop.isScoop = true;
        table2Scoop.color = '#8800ff';

        // Scoop entrance guide walls
        for (let i = 0; i < 8; i++) {
            createObject(SCOOP_X - 20, SCOOP_Y - 30 + i * 4, TYPE_WALL, 3);
            createObject(SCOOP_X + 20, SCOOP_Y - 30 + i * 4, TYPE_WALL, 3);
        }

        // Small pop bumpers above outlanes (same as Table 1)
        const smallBumperLeft = createObject(FLIPPER_CENTER - 130, 470, TYPE_BUMPER, 12);
        smallBumperLeft.color = '#ff8800';
        const smallBumperRight = createObject(FLIPPER_CENTER + 130, 470, TYPE_BUMPER, 12);
        smallBumperRight.color = '#ff8800';

        // Lane lights area (same positions as table 1)
        // These are handled in rendering, not as objects
    }

    // build table 3
    function buildTable3() {
        objects = [];
        dropTargets = [];

        // reset feature arrays
        spinners = [];
        scoops = [];
        standups = [];
        lanes = [];

        // Ball
        const ball = createObject(CENTER_X + DOME_RADIUS - BALL_RADIUS, SHOOTER_Y - 20);
        ball.radius = BALL_RADIUS;
        ball.color = '#ffffff';
        ball.isBall = true;

        // Flipper segment placeholders
        for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
            createObject(0, 0, TYPE_WALL, FLIPPER_RADIUS - i / 6);
            createObject(0, 0, TYPE_WALL, FLIPPER_RADIUS - i / 6);
        }

        // Shooter lane “plunger wall”
        for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
            const shooter = createObject(CENTER_X + DOME_RADIUS - BALL_RADIUS, TABLE_HEIGHT - 10 + i, TYPE_WALL, 5);
            shooter.isShooter = true;
            shooter.shooterIndex = i;
        }

        const DOME_BOTH = DOME_RADIUS + WALL_RADIUS;

        // Center pin
        const centerPinY = safetyPinActive ? FLIPPER_Y + 25 : FLIPPER_Y + 54;
        const centerPin = createObject(FLIPPER_CENTER, centerPinY, TYPE_WALL, safetyPinActive ? 18 : 5);
        centerPin.isCenterPin = true;
        centerPin.color = safetyPinActive ? '#ffff00' : '#00ffff';

        // Outer walls + dome
        for (let side = 0; side < 2; side++) {
            const dir = side * 2 - 1;

            for (let i = 0; i < 90; i++) {
            createObject(CENTER_X + dir * DOME_BOTH, TABLE_HEIGHT - 7 * i);
            }
            for (let i = 0; i < 55; i++) {
            createObject(
                CENTER_X + dir * DOME_BOTH * Math.cos(i / 35),
                DOME_BOTH - DOME_BOTH * Math.sin(i / 35)
            );
            }

            // Upper guides near flippers
            for (let i = 0; i < 12; i++) {
            createObject(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55), FLIPPER_Y - 50 - i * 7);
            }
            for (let i = 0; i < 19; i++) {
            createObject(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55 - i * 3), FLIPPER_Y - 50 + i * 3);
            }

            // Slings
            const slingInnerX = FLIPPER_CENTER + dir * FLIPPER_SPREAD;
            const slingOuterX = FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 25);
            const slingTopY = FLIPPER_Y - 120;
            const slingBottomY = FLIPPER_Y - 70;
            const slingBottomInnerY = slingBottomY + 25;

            for (let i = 0; i <= 7; i++) {
            const t = i / 7;
            createObject(slingOuterX, slingTopY + t * (slingBottomY - slingTopY));
            }
            for (let i = 0; i <= 12; i++) {
            const t = i / 12;
            const sObj = createObject(
                slingOuterX + (slingInnerX - slingOuterX) * t,
                slingTopY + (slingBottomInnerY - slingTopY) * t,
                TYPE_BUMPER, 4
            );
            sObj.isSlingshot = true;
            }
            for (let i = 0; i <= 5; i++) {
            const t = i / 5;
            createObject(
                slingOuterX + (slingInnerX - slingOuterX) * t,
                slingBottomY + (slingBottomInnerY - slingBottomY) * t
            );
            }
        }

        // Shooter wall on right
        const shooterWallX = CENTER_X + DOME_RADIUS - BALL_RADIUS * 2 - WALL_RADIUS;
        for (let i = 0; i < 65; i++) {
            createObject(shooterWallX, TABLE_HEIGHT - 7 * i);
        }

        // === Screenshot-inspired features ===

        // A) Central 3-pop bumper cluster
        const cx = CENTER_X, cy = 250;
        const b1 = createObject(cx, cy - 38, TYPE_BUMPER, 22); b1.color = '#ff00ff'; b1.isHighValue = true;
        const b2 = createObject(cx - 34, cy + 20, TYPE_BUMPER, 22); b2.color = '#ff00ff';
        const b3 = createObject(cx + 34, cy + 20, TYPE_BUMPER, 22); b3.color = '#ff00ff';

        // B) Top lanes (standups as rollovers for now)
        createStandup(CENTER_X - 70, 90, 7, 35, '#ffaa00');
        createStandup(CENTER_X,      80, 7, 35, '#ffaa00');
        createStandup(CENTER_X + 70, 90, 7, 35, '#ffaa00');

        // C) Left wireform / orbit lane (two rails)
        for (let i = 0; i <= 46; i++) {
            const t = i / 46;
            const xOuter = 40 + 85 * Math.sin(t * Math.PI * 0.92);
            const yOuter = 300 - 220 * t;
            createObject(xOuter, yOuter, TYPE_WALL, WALL_RADIUS);

            const xInner = 68 + 68 * Math.sin(t * Math.PI * 0.92);
            const yInner = 300 - 220 * t;
            createObject(xInner, yInner, TYPE_WALL, WALL_RADIUS);
        }
        // Lane assist along that orbit (helps it feel like a wireform/ramp)
        createLaneAssist('left_orbit', 70, 300, 120, 90, 20, 0.14);

        // D) Right orbit “star lane” with standups + rail
        for (let i = 0; i <= 40; i++) {
            const t = i / 40;
            const xOuter = TABLE_WIDTH - 38 - 70 * Math.sin(t * Math.PI * 0.9);
            const yOuter = 135 + 270 * t;
            createObject(xOuter, yOuter, TYPE_WALL, WALL_RADIUS);

            const xInner = TABLE_WIDTH - 62 - 55 * Math.sin(t * Math.PI * 0.9);
            const yInner = 135 + 270 * t;
            createObject(xInner, yInner, TYPE_WALL, WALL_RADIUS);
        }
        for (let i = 0; i < 6; i++) {
            const t = i / 5;
            createStandup(TABLE_WIDTH - 85 - 40 * Math.sin(t * Math.PI * 0.9), 155 + 230 * t, 6, 30, '#ffffff');
        }
        createLaneAssist('right_orbit', TABLE_WIDTH - 80, 360, TABLE_WIDTH - 105, 140, 20, 0.13);

        // E) Spinner (mid-left)
        createSpinner(CENTER_X - 95, 360, 54).value = 20;

        // F) Scoop (top-right)
        createScoop(TABLE_WIDTH - 70, 105, 16).value = 180;

        // G) “Ramp entrance” (right mid) using rails + assist
        // Two short parallel rails creating a ramp mouth
        for (let i = 0; i <= 18; i++) {
            const t = i / 18;
            createObject(TABLE_WIDTH - 110 + t * 55, 420 - t * 90, TYPE_WALL, WALL_RADIUS);
            createObject(TABLE_WIDTH - 125 + t * 55, 420 - t * 90, TYPE_WALL, WALL_RADIUS);
        }
        createLaneAssist('right_ramp', TABLE_WIDTH - 120, 420, TABLE_WIDTH - 70, 330, 18, 0.18);

        // H) Left drop-target bank (classic)
        const dtX = 60;
        const dtY = 325;
        for (let i = 0; i < 5; i++) {
            const dt = createObject(dtX, dtY + i * 24, TYPE_DROP_TARGET, 5);
            dt.isDropTarget = true;
            dt.active = true;
            dt.dropGroup = 300;
            dt.color = '#ffff00';
            dropTargets.push(dt);
        }

        // I) Extra standups around center (to feel like inserts)
        createStandup(CENTER_X - 120, 410, 7, 45, '#00ffff');
        createStandup(CENTER_X + 120, 410, 7, 45, '#00ffff');
        createStandup(CENTER_X,       455, 7, 55, '#00ffff');
    }

    //hotkey transition to table 3
    function transitionToTable3() {
        tableTransitioning = true;
        tableTransitionTimer = 120;
        currentTable = 3;
        buildTable3();

        if (typeof createParticles === 'function') createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 2, 60);
        if (typeof createFirework === 'function') createFirework(TABLE_WIDTH / 2, TABLE_HEIGHT / 4);
    }



    // === TRANSITION TO TABLE 2 ===
    function transitionToTable2() {
        tableTransitioning = true;
        tableTransitionTimer = 120;  // 2 seconds of transition animation
        currentTable = 2;

        // Reset table 2 specific states
        rampDropTargetActive = true;
        spinnerAngle = 0;
        spinnerSpeed = 0;
        spinnerHits = 0;
        spinnerActive = false;
        scoopBallLocked = false;
        multiballReady = false;
        standupBankLeft = [false, false, false];
        standupBankRight = [false, false, false];

        // Build the new table
        buildTable2();

        createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 2, 60);
        createFirework(TABLE_WIDTH / 4, TABLE_HEIGHT / 4);
        createFirework(TABLE_WIDTH * 3 / 4, TABLE_HEIGHT / 4);
    }

    // === OVERLAY BUTTON HIT TEST ===
    function checkOverlayButtonHit(gameX, gameY) {
        if (gameState === STATE_WELCOME) {
            const boxW = 50;
            const boxGap = 14;
            const totalW = boxW * 3 + boxGap * 2;
            const startLetterX = OX - totalW / 2;
            const boxY = TABLE_HEIGHT * 0.14 + 78;
            const boxH = 60;
            // Up arrows
            if (gameY >= boxY - 25 && gameY <= boxY) {
                const activeBoxX = startLetterX + currentInitialPos * (boxW + boxGap);
                if (gameX >= activeBoxX && gameX <= activeBoxX + boxW) return 'scroll_up';
            }
            // Down arrows
            if (gameY >= boxY + boxH && gameY <= boxY + boxH + 25) {
                const activeBoxX = startLetterX + currentInitialPos * (boxW + boxGap);
                if (gameX >= activeBoxX && gameX <= activeBoxX + boxW) return 'scroll_down';
            }
            // BACK button
            const backBtnX = OX - 86;
            const btnRowY = boxY + boxH + 26;
            if (gameX >= backBtnX && gameX <= backBtnX + 74 && gameY >= btnRowY && gameY <= btnRowY + 34) {
                return 'back';
            }
            // CONFIRM button
            const cfmBtnX = OX + 12;
            if (gameX >= cfmBtnX && gameX <= cfmBtnX + 74 && gameY >= btnRowY && gameY <= btnRowY + 34) {
                return 'confirm';
            }
            // START button
            const startBtnY = btnRowY + 50;
            const startBtnX = OX - 80;
            if (gameX >= startBtnX && gameX <= startBtnX + 160 && gameY >= startBtnY && gameY <= startBtnY + 48) {
                return 'start';
            }
        }

        if (gameState === STATE_MENU) {
            const mbY = TABLE_HEIGHT*0.14 + 48 + 75 + 28;
            const mbW = 120;
            const mbH = 46;
            const mGap = 14;
            const leftBX = OX - mbW - mGap / 2;
            const rightBX = OX + mGap / 2;
            if (gameY >= mbY && gameY <= mbY + mbH) {
                if (gameX >= leftBX && gameX <= leftBX + mbW) return 'scores';
                if (gameX >= rightBX && gameX <= rightBX + mbW) return 'play';
            }
            // Change player button
            const cpW = 160;
            const cpX = OX - cpW / 2;
            const cpY = mbY + mbH + 42;
            if (gameX >= cpX && gameX <= cpX + cpW && gameY >= cpY && gameY <= cpY + 36) {
                return 'change_player';
            }
            // Stats button
            const stBtnW = 110;
            const stBtnX = OX - stBtnW / 2;
            const stBtnY = cpY + 52;
            if (gameX >= stBtnX && gameX <= stBtnX + stBtnW && gameY >= stBtnY && gameY <= stBtnY + 32) {
                return 'stats';
            }
        }

        if (gameState === STATE_LEADERBOARD) {
            // BACK button
            const lbBX = OX - 55;
            const lbBY = TABLE_HEIGHT - 68;
            if (gameX >= lbBX && gameX <= lbBX + 110 && gameY >= lbBY && gameY <= lbBY + 38) {
                return 'back_to_menu';
            }
            // LOCAL/ONLINE toggle
            const togX = OX - 55;
            const togY = 86;
            if (gameX >= togX && gameX <= togX + 110 && gameY >= togY && gameY <= togY + 22) {
                return 'toggle_scores';
            }
        }

        if (gameState === STATE_STATS) {
            const bkX = OX - 55;
            const bkY = TABLE_HEIGHT - 70;
            if (gameX >= bkX && gameX <= bkX + 110 && gameY >= bkY && gameY <= bkY + 38) {
                return 'back_to_menu';
            }
        }

        if (gameState === STATE_CHOOSE_MODIFIER) {
            const boxW = 158;
            const boxH = 195;
            const modHdrY = TABLE_HEIGHT * 0.18;
            const boxY = modHdrY + 50;
            const leftBoxX = OX - boxW - 8;
            const rightBoxX = OX + 8;
            if (gameX >= leftBoxX && gameX <= leftBoxX + boxW && gameY >= boxY && gameY <= boxY + boxH) {
                return 'mod_left';
            }
            if (gameX >= rightBoxX && gameX <= rightBoxX + boxW && gameY >= boxY && gameY <= boxY + boxH) {
                return 'mod_right';
            }
        }

        return null;
    }

    // score pop up
    function addScorePopup(x, y, amount, color = '#00ffff') {
        if (!amount || amount === 0) return;

        // Throttle per physics step
        if (scorePopupsSpawnedThisStep >= MAX_SCORE_POPUPS_PER_STEP) return;
        scorePopupsSpawnedThisStep++;

        const text = (amount > 0 ? '+' : '') + Math.floor(amount).toString();

        // Stack/combine with an existing popup near the same place (prevents spam)
        for (let i = scorePopups.length - 1; i >= 0; i--) {
            const p = scorePopups[i];
            if (p.life < 20) continue; // only stack with "fresh" popups
            const dx = p.x - x;
            const dy = p.y - y;
            if (dx * dx + dy * dy <= SCORE_POPUP_STACK_DIST * SCORE_POPUP_STACK_DIST) {
            p.amount += amount;
            p.text = (p.amount > 0 ? '+' : '') + Math.floor(p.amount).toString();
            p.life = Math.min(SCORE_POPUP_LIFE, p.life + 12); // give it a little refresh
            return;
            }
        }

        // Cap total active
        if (scorePopups.length >= MAX_SCORE_POPUPS_ACTIVE) {
            scorePopups.shift();
        }

        scorePopups.push({
            x, y,
            vy: -0.55,          // upward speed
            life: SCORE_POPUP_LIFE,
            amount,
            text,
            color
        });
        }

        function updateScorePopups() {
        scorePopups = scorePopups.filter(p => {
            p.y += p.vy;
            p.vy *= 0.98;       // gentle easing
            p.life--;
            return p.life > 0;
        });
        }

        function drawScorePopups() {
        if (scorePopups.length === 0) return;

        ctx.save();
        ctx.font = "bold 12px 'Orbitron', monospace";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        for (const p of scorePopups) {
            const t = p.life / SCORE_POPUP_LIFE;
            const alpha = Math.min(1, t * 1.2); // fade-out mostly near end

            ctx.globalAlpha = alpha;
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 12;

            ctx.fillStyle = p.color;
            ctx.fillText(p.text, p.x, p.y);

            // subtle white core for readability
            ctx.shadowBlur = 0;
            ctx.globalAlpha = alpha * 0.55;
            ctx.fillStyle = '#ffffff';
            ctx.fillText(p.text, p.x, p.y);
        }

        ctx.restore();
        ctx.globalAlpha = 1;
        }

        // Use this instead of manual score += ... + DOM update
        function awardScore(points, x, y, color) {
        if (!points) return;
        score += points;
        updateScoreDisplay(score);
        addScorePopup(x, y, points, color);
    }

    //table 3 collision code
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function pointSegmentDistanceSq(px, py, x1, y1, x2, y2) {
        const vx = x2 - x1, vy = y2 - y1;
        const wx = px - x1, wy = py - y1;
        const c1 = vx * wx + vy * wy;
        if (c1 <= 0) return (px - x1) ** 2 + (py - y1) ** 2;
        const c2 = vx * vx + vy * vy;
        if (c2 <= c1) return (px - x2) ** 2 + (py - y2) ** 2;
        const t = c1 / c2;
        const projx = x1 + t * vx, projy = y1 + t * vy;
        return (px - projx) ** 2 + (py - projy) ** 2;
    }

    function handleTable3Features(ball) {
        // Cooldowns
        for (const s of spinners) if (s.cooldown > 0) s.cooldown--;
        for (const sc of scoops)  if (sc.cooldown > 0) sc.cooldown--;
        for (const st of standups)if (st.cooldown > 0) st.cooldown--;

        // === Lane assists (ramps/wireforms) ===
        // If inside lane region, push ball forward along the lane direction (subtle)
        for (const lane of lanes) {
            const d2 = pointSegmentDistanceSq(ball.x, ball.y, lane.x1, lane.y1, lane.x2, lane.y2);
            if (d2 <= lane.radius * lane.radius) {
                const dx = lane.x2 - lane.x1;
                const dy = lane.y2 - lane.y1;
                const mag = Math.hypot(dx, dy) || 1;
                const ux = dx / mag, uy = dy / mag;
                ball.vx += ux * lane.boost;
                ball.vy += uy * lane.boost;
            }
        }

        // === Standup targets ===
        for (const st of standups) {
            const dx = ball.x - st.x, dy = ball.y - st.y;
            const rr = (ball.radius + st.radius + 2);
            if (dx*dx + dy*dy <= rr*rr && st.cooldown <= 0) {
                st.cooldown = 10;

            // bounce the ball away a bit (feels like a rubber standup)
            const mag = Math.hypot(dx, dy) || 1;
            const nx = dx / mag, ny = dy / mag;
            const speed = Math.hypot(ball.vx, ball.vy);
            ball.vx = ball.vx * 0.7 + nx * (0.9 + speed * 0.12);
            ball.vy = ball.vy * 0.7 + ny * (0.9 + speed * 0.12);

            // score
            const pts = st.value * scoreMultiplier * targetValueMultiplier;
            awardScore(pts, st.x, st.y, st.color);

            // little particles if you like
            if (typeof createParticles === 'function') createParticles(st.x, st.y, 6);
        }
    }

    // === Spinners ===
    // Detect a “pass through” near the spinner center; spin faster when hit
    for (const s of spinners) {
        // Update spin decay
        s.angVel *= 0.985;
        s.angle += s.angVel;

        const dx = ball.x - s.x, dy = ball.y - s.y;
        const rr = (ball.radius + s.radius);
        if (dx*dx + dy*dy <= rr*rr && s.cooldown <= 0) {
            s.cooldown = 8;

            // Convert ball velocity into spinner rotation
            const tangential = (-dx * ball.vy + dy * ball.vx) * 0.02;
            s.angVel += clamp(tangential, -0.35, 0.35);

            // Give the ball a tiny “deflect” so it feels like a real spinner
            ball.vx *= 0.985;
            ball.vy *= 0.985;

            const pts = s.value * scoreMultiplier * targetValueMultiplier;
            awardScore(pts, s.x, s.y, '#ffffff');
        }
    }

    // === Scoops ===
    // Capture ball if moving slowly enough and inside scoop radius
    for (const sc of scoops) {
        if (sc.holdTimer > 0) {
        sc.holdTimer--;

        // keep ball “locked”
        ball.x = sc.x;
        ball.y = sc.y;
        ball.vx *= 0.2;
        ball.vy *= 0.2;

        // eject at end
        if (sc.holdTimer === 0) {
            const ejectAngle = -Math.PI / 2 + (Math.random() * 0.6 - 0.3);
            const ejectSpeed = 7.0;
            ball.vx = Math.cos(ejectAngle) * ejectSpeed;
            ball.vy = Math.sin(ejectAngle) * ejectSpeed;
            sc.cooldown = 25;
        }
        continue;
        }

        const dx = ball.x - sc.x, dy = ball.y - sc.y;
        const rr = (ball.radius + sc.radius);
        const speed = Math.hypot(ball.vx, ball.vy);

        if (dx*dx + dy*dy <= rr*rr && sc.cooldown <= 0 && speed < 9.5) {
            // “capture”
            sc.holdTimer = 40; // ~0.6 sec hold
            ball.vx *= 0.15;
            ball.vy *= 0.15;

            const pts = sc.value * scoreMultiplier * targetValueMultiplier;
            awardScore(pts, sc.x, sc.y, sc.color);

            // Example: small “bonus” chance or modifier trigger later
            if (typeof createParticles === 'function') createParticles(sc.x, sc.y, 18);
            }
        }
    }



    // === PHYSICS UPDATE ===
    function updatePhysics() {
        scorePopupsSpawnedThisStep = 0;
        const ball = objects[0];

        const leftJustPressed = keys.z && !flipperLeftWasPressed;
        const rightJustPressed = keys.x && !flipperRightWasPressed;

        if (leftJustPressed) playRandomSound('Flipper', 3);
        if (rightJustPressed) playRandomSound('Flipper', 3);

        if (leftJustPressed && topLaneLights.some(l => l)) {
            topLaneLights = [topLaneLights[1], topLaneLights[2], topLaneLights[0]];
        }
        if (rightJustPressed && topLaneLights.some(l => l)) {
            topLaneLights = [topLaneLights[2], topLaneLights[0], topLaneLights[1]];
        }

        flipperLeftWasPressed = keys.z;
        flipperRightWasPressed = keys.x;

        for (let substep = 0; substep < PHYSICS_SUBSTEPS; substep++) {

            flipperLeft = Math.max(-1, Math.min(1, flipperLeft + (keys.z ? -0.07 : 0.05)));
            flipperRight = Math.max(-1, Math.min(1, flipperRight + (keys.x ? -0.07 : 0.05)));

            for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
                const leftObj = objects[1 + i];
                const prevLeftX = leftObj.x;
                const prevLeftY = leftObj.y;
                leftObj.x = FLIPPER_CENTER + (-1) * (FLIPPER_SPREAD - i * Math.cos(flipperLeft / 2));
                leftObj.y = FLIPPER_Y_ACTUAL + i * Math.sin(flipperLeft / 2);
                leftObj.vx = leftObj.x - prevLeftX;
                leftObj.vy = leftObj.y - prevLeftY;
                leftObj.radius = FLIPPER_RADIUS - i / 7;

                const rightObj = objects[1 + FLIPPER_SEGMENTS + i];
                const prevRightX = rightObj.x;
                const prevRightY = rightObj.y;
                rightObj.x = FLIPPER_CENTER + (1) * (FLIPPER_SPREAD - i * Math.cos(flipperRight / 2));
                rightObj.y = FLIPPER_Y_ACTUAL + i * Math.sin(flipperRight / 2);
                rightObj.vx = rightObj.x - prevRightX;
                rightObj.vy = rightObj.y - prevRightY;
                rightObj.radius = FLIPPER_RADIUS - i / 7;
            }

            const shooterStart = 1 + FLIPPER_SEGMENTS * 2;
            const SHOOTER_MAX = TABLE_HEIGHT - 10;
            for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
                const shooter = objects[shooterStart + i];
                if (shooter && shooter.isShooter) {
                    const prevY = shooter.y;
                    shooter.y = Math.min(SHOOTER_MAX + i,
                        shooter.y + (shooter.vy = keys.c ? 0.05 :
                        Math.sin(frame) / 99 + (SHOOTER_Y + i - shooter.y) / 19));
                    shooter.vy = shooter.y - prevY;
                }
            }

            if (saucerActive) {
                ball.x = SAUCER_X;
                ball.y = SAUCER_Y;
                ball.vx = 0;
                ball.vy = 0;
                continue;
            }

            ball.x += ball.vx;
            ball.y += ball.vy;
            ball.vy += GRAVITY;

            const inLaneZone = Math.abs(ball.y - TOP_LANE_Y) < BALL_RADIUS + 15;
            if (inLaneZone && !ballInTopLane) {
                ballInTopLane = true;
                for (let g = 0; g < 3; g++) {
                    const gapLeft = TOP_LANE_PINS[g] + 6;
                    const gapRight = TOP_LANE_PINS[g + 1] - 6;
                    if (ball.x > gapLeft && ball.x < gapRight) {
                        topLaneLights[g] = true;
                        if (topLaneLights.every(l => l)) {
                            score += 50 * scoreMultiplier * targetValueMultiplier;
                            updateScoreDisplay(score);
                            topLaneLights = [false, false, false];
                        }
                        break;
                    }
                }
            } else if (!inLaneZone) {
                ballInTopLane = false;
            }

            for (let i = 0; i < 4; i++) {
                if (!spotTargets[i]) {
                    const stx = SPOT_TARGET_POSITIONS[i].x;
                    const sty = SPOT_TARGET_POSITIONS[i].y;
                    const sdx = ball.x - stx;
                    const sdy = ball.y - sty;
                    if (Math.sqrt(sdx * sdx + sdy * sdy) < BALL_RADIUS + 8) {
                        spotTargets[i] = true;
                        const pts = (3 + targetLevel * 2) * scoreMultiplier * targetValueMultiplier;
                        awardScore(pts, stx, sty, '#ffaa00');
                        updateScoreDisplay(score);
                        if (spotTargets.every(s => s)) {
                            spotCompletions++;
                            scoreMultiplier *= 2;
                            trackStat('maxMultiplier', scoreMultiplier);
                            spotTargets = [false, false, false, false];
                        }
                    }
                }
            }

            for (let i = 0; i < 4; i++) {
                if (!laneLights[i]) {
                    const llx = LANE_LIGHT_POSITIONS[i].x;
                    const lly = LANE_LIGHT_POSITIONS[i].y;
                    const ldx = ball.x - llx;
                    const ldy = ball.y - lly;
                    if (Math.abs(ldx) < 18 && Math.abs(ldy) < 18) {
                        laneLights[i] = true;
                        if (laneLights.every(l => l)) {
                            ballCount++;
                            document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
                            trackStat('extraBallsEarned');
                            laneLights = [false, false, false, false];
                            extraBallTimer = 120;
                            createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 2, 40);
                            createFirework(TABLE_WIDTH / 2, TABLE_HEIGHT / 3);
                        }
                    }
                }
            }

            // Check if ball is lost
            if (ball.y > TABLE_HEIGHT + 50) {
                if (ballSaveAvailable && ((score - ballStartScore) < 20 || (extraBallSave3 && ballCount === 1))) {
                    // Ball save!
                    ballSaveAvailable = false;
                    ballSaveTimer = 120;
                    if (window.dmdTrigger) window.dmdTrigger('ballsave');
                    playSound('BallSave');
                    ball.x = SHOOTER_X;
                    ball.y = SHOOTER_Y - 20;
                    ball.vx = 0;
                    ball.vy = 0;
                    const bsStart = 1 + FLIPPER_SEGMENTS * 2;
                    for (let si = 0; si < FLIPPER_SEGMENTS; si++) {
                        const seg = objects[bsStart + si];
                        if (seg && seg.isShooter) {
                            seg.y = SHOOTER_Y + si;
                            seg.vy = 0;
                        }
                    }
                    createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 2, 30);
                } else if (ballCount > 0) {
                    ballCount--;
                    ballsLost++;
                    document.getElementById('balls').textContent = ballCount; if(window.dmdSetBalls) window.dmdSetBalls(ballCount);
                    playSound('BallDrain');

                    if (ballCount > 0) {
                        // Handle All or Nothing drain penalty
                        if (allOrNothingActive) {
                            score = 0;
                            updateScoreDisplay(score);
                            allOrNothingActive = false;
                        }
                        // Move ball off-screen to prevent re-triggering in substep loop
                        ball.x = -100;
                        ball.y = -100;
                        ball.vx = 0;
                        ball.vy = 0;
                        // Show modifier choice before next ball
                        generateModifierChoices();
                        gameState = STATE_CHOOSE_MODIFIER;
                        window._modStars = null; // reset stars for fresh layout
                    } else {
                        // Game over
                        if (allOrNothingActive) {
                            score = 0;
                            updateScoreDisplay(score);
                            allOrNothingActive = false;
                        }
                        finalScore = score;
                        isNewHighScore = checkHighScore(score);
                        gameState = STATE_GAME_OVER;
                        gameOverTimer = 90;
                        ball.x = -100;
                        ball.y = -100;
                        ball.vx = 0;
                        ball.vy = 0;
                        // Track stats
                        trackStat('gamesPlayed');
                        trackStat('totalScore', finalScore);
                        // Auto-submit score with session initials
                        if (isNewHighScore && sessionInitials) {
                            addHighScore(sessionInitials, finalScore, maxTableLevel);
                            submitScoreToFirebase(sessionInitials, finalScore, maxTableLevel);
                            createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 3, 60);
                        }
                    }
                }
            }

            // Collision detection
            for (let i = 1; i < objects.length; i++) {
                const obj = objects[i];
                if (obj.isDropTarget && !obj.active) continue;
                // Skip scoop in normal collision - handled separately for ball lock
                if (obj.isScoop) continue;
                // Skip standup targets for now - disabled for testing
                if (obj.isStandupTarget) continue;

                const dx = ball.x - obj.x;
                const dy = ball.y - obj.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = ball.radius + obj.radius;

                if (dist < minDist && dist > 0) {
                    const relVx = obj.vx - ball.vx;
                    const relVy = obj.vy - ball.vy;
                    const dotProduct = relVx * dx + relVy * dy;

                    if (dotProduct > 0 && !(obj.type && !ball.vx)) {
                        const overlap = minDist - dist;
                        ball.x += (dx / dist) * overlap;
                        ball.y += (dy / dist) * overlap;

                        const tangent = dist * dist / (relVy * dx - relVx * dy);
                        let restitution;

                        if (obj.isDropTarget && obj.active && !obj.bounce) {
                            obj.bounce = 10;

                            // Table 2: Ramp drop target special handling
                            if (currentTable === 2 && obj.isRampDropTarget) {
                                // Deactivate ramp drop targets
                                dropTargets.forEach(dt => {
                                    if (dt.isRampDropTarget) { dt.active = false; dt.bounce = 10; }
                                });
                                rampDropTargetActive = false;
                                score += 25 * scoreMultiplier * targetValueMultiplier;
                                updateScoreDisplay(score);
                                createParticles(obj.x, obj.y, 15);
                            } else {
                                // Normal drop target handling (Table 1)
                                dropTargets.forEach(dt => {
                                    if (dt.dropGroup === obj.dropGroup) { dt.active = false; dt.bounce = 10; }
                                });
                                score += (5 + targetLevel * 3) * scoreMultiplier * targetValueMultiplier;
                                updateScoreDisplay(score);
                                if (dropTargets.every(dt => !dt.active)) {
                                    score += (25 + targetLevel * 10) * scoreMultiplier * targetValueMultiplier;
                                    updateScoreDisplay(score);
                                    trackStat('allTargetsCleared');
                                    setTimeout(() => { dropTargets.forEach(dt => { dt.active = true; }); }, 1500);
                                }
                            }
                            restitution = BUMPER_RESTITUTION;
                        }

                        // Table 2: Standup target handling
                        if (currentTable === 2 && obj.isStandupTarget && !obj.bounce) {
                            obj.bounce = 15;
                            const bank = obj.standupBank;
                            const idx = obj.standupIndex;

                            if (bank === 'left' && !standupBankLeft[idx]) {
                                standupBankLeft[idx] = true;
                                obj.color = '#00ff00';
                                score += 10 * scoreMultiplier * targetValueMultiplier;
                                updateScoreDisplay(score);
                                playRandomSound('PopBumper', 5);
                                createParticles(obj.x, obj.y, 10);

                                // Check for bank completion
                                if (standupBankLeft.every(t => t)) {
                                    scoreMultiplier++;
                                    standupBankLeftCompletions++;
                                    trackStat('maxMultiplier', scoreMultiplier);
                                    score += 50 * scoreMultiplier * targetValueMultiplier;
                                    updateScoreDisplay(score);
                                    createParticles(70, 450, 30);
                                    createFirework(70, 420);
                                    // Reset bank after delay
                                    setTimeout(() => {
                                        standupBankLeft = [false, false, false];
                                        table2StandupTargetsLeft.forEach(t => { t.color = '#006600'; });
                                    }, 2000);
                                }
                            } else if (bank === 'right' && !standupBankRight[idx]) {
                                standupBankRight[idx] = true;
                                obj.color = '#00ff00';
                                score += 10 * scoreMultiplier * targetValueMultiplier;
                                updateScoreDisplay(score);
                                playRandomSound('PopBumper', 5);
                                createParticles(obj.x, obj.y, 10);

                                // Check for bank completion
                                if (standupBankRight.every(t => t)) {
                                    scoreMultiplier++;
                                    standupBankRightCompletions++;
                                    trackStat('maxMultiplier', scoreMultiplier);
                                    score += 50 * scoreMultiplier * targetValueMultiplier;
                                    updateScoreDisplay(score);
                                    createParticles(330, 450, 30);
                                    createFirework(330, 420);
                                    // Reset bank after delay
                                    setTimeout(() => {
                                        standupBankRight = [false, false, false];
                                        table2StandupTargetsRight.forEach(t => { t.color = '#006600'; });
                                    }, 2000);
                                }
                            }
                            restitution = BUMPER_RESTITUTION;
                        }

                        // Table 2: Spinner handling
                        if (currentTable === 2 && obj.isSpinner && !obj.bounce) {
                            obj.bounce = 5;
                            spinnerHits++;
                            // Add spin speed based on ball velocity for realistic spinning
                            const ballSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                            spinnerSpeed += ballSpeed * 10;  // Harder hit = more spins
                            score += 5 * scoreMultiplier * targetValueMultiplier;
                            updateScoreDisplay(score);
                            playRandomSound('SlingShot', 3);

                            // Spinner reactivates the drop target after enough hits
                            if (spinnerHits >= 3) {
                                spinnerActive = true;
                                spinnerHits = 0;
                                // Reactivate ramp drop target
                                rampDropTargetActive = true;
                                dropTargets.forEach(dt => {
                                    if (dt.isRampDropTarget) { dt.active = true; }
                                });
                                createParticles(SPINNER_X, SPINNER_Y, 20);

                                // If ball is locked in scoop, prepare for multiball
                                if (scoopBallLocked) {
                                    multiballReady = true;
                                    createFirework(SCOOP_X, SCOOP_Y);
                                }
                            }
                            restitution = RESTITUTION;
                        } else if (obj.type === TYPE_BUMPER && !obj.bounce) {
                            obj.bounce = 10;
                            // Sound: slingshot vs pop bumper
                            if (obj.isSlingshot) {
                                playRandomSound('SlingShot', 3);
                                createDsBurst(obj.x, obj.y, 5, Math.random() < 0.5);
                            } else {
                                playRandomSound('PopBumper', 5);
                                if (obj.isCenterBumper) trackStat('colorBumperHits');
                                createDsBurst(obj.x, obj.y, obj.radius >= 20 ? 14 : 8, Math.random() < 0.5);
                            }
                            if (obj.y < FLIPPER_Y - 80) {
                                const pts = (obj.isHighValue ? 15 : 3) * scoreMultiplier * targetValueMultiplier;
                                awardScore(pts, obj.x, obj.y, obj.isHighValue ? '#ff4444' : '#00ffff');
                            }
                            restitution = BUMPER_RESTITUTION;
                        } else {
                            restitution = RESTITUTION;
                            // Wall sound with cooldown - only on hard impacts
                            const impactSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                            if (!obj.isShooter && i > FLIPPER_SEGMENTS * 2 && audioCtx && impactSpeed > 2) {
                                const now = audioCtx.currentTime;
                                if (now - lastWallSoundTime > 0.25) {
                                    lastWallSoundTime = now;
                                    playRandomSound('Wall', 3);
                                }
                            }
                        }

                        ball.vx += (relVx + dy / tangent) * restitution;
                        ball.vy += (relVy - dx / tangent) * restitution;
                        gameStarted = true;
                    }
                }
                if (obj.bounce > 0) { obj.bounce--; }
            }

            // Saucer capture check
            if (!saucerActive) {
                const sdx = ball.x - SAUCER_X;
                const sdy = ball.y - SAUCER_Y;
                const sDist = Math.sqrt(sdx * sdx + sdy * sdy);
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (sDist < SAUCER_RADIUS + BALL_RADIUS) {
                    if (speed < SAUCER_CAPTURE_SPEED) {
                        saucerActive = true;
                        trackStat('saucerCaptures');
                        saucerTimer = SAUCER_HOLD_TIME;
                        saucerLevelUpDone = false;
                        ball.x = SAUCER_X;
                        ball.y = SAUCER_Y;
                        ball.vx = 0;
                        ball.vy = 0;
                    } else if (sDist > 0) {
                        ball.vx += (sdx / sDist) * 0.003;
                        ball.vy += (sdy / sDist) * 0.003;
                    }
                }
            }

            // Table 2: Scoop (ball lock) check
            if (currentTable === 2 && !scoopBallLocked && !multiballActive) {
                const scx = ball.x - SCOOP_X;
                const scy = ball.y - SCOOP_Y;
                const scDist = Math.sqrt(scx * scx + scy * scy);
                const scSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);

                if (scDist < SCOOP_RADIUS + BALL_RADIUS) {
                    if (scSpeed < 0.2) {
                        // Ball captured in scoop - lock it!
                        scoopBallLocked = true;
                        lockedBallX = ball.x;
                        lockedBallY = ball.y;
                        score += 100 * scoreMultiplier * targetValueMultiplier;
                        updateScoreDisplay(score);
                        createParticles(SCOOP_X, SCOOP_Y, 25);
                        playSound('TableLevelUp');

                        // Spawn a new ball in the shooter lane
                        ball.x = SHOOTER_X;
                        ball.y = SHOOTER_Y - 20;
                        ball.vx = 0;
                        ball.vy = 0;

                        // Reset shooter position
                        const rstStart = 1 + FLIPPER_SEGMENTS * 2;
                        for (let si = 0; si < FLIPPER_SEGMENTS; si++) {
                            const seg = objects[rstStart + si];
                            if (seg && seg.isShooter) {
                                seg.y = SHOOTER_Y + si;
                                seg.vy = 0;
                            }
                        }
                    } else if (scDist > 0) {
                        // Gentle attraction toward scoop
                        ball.vx -= (scx / scDist) * 0.002;
                        ball.vy -= (scy / scDist) * 0.002;
                    }
                }
            }

            // Table 2: Multiball launch check
            if (currentTable === 2 && scoopBallLocked && multiballReady && !multiballActive) {
                // Launch multiball!
                multiballActive = true;
                multiballReady = false;
                score += 500 * scoreMultiplier * targetValueMultiplier;
                updateScoreDisplay(score);

                // Release locked ball from scoop with upward velocity
                // We'll simulate this by creating a second ball effect
                // For simplicity, we'll just eject the current ball faster
                // and give bonus points
                scoopBallLocked = false;

                createParticles(SCOOP_X, SCOOP_Y, 40);
                createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 2, 40);
                createFirework(TABLE_WIDTH / 2, TABLE_HEIGHT / 3);
                createFirework(TABLE_WIDTH / 4, TABLE_HEIGHT / 3);
                createFirework(TABLE_WIDTH * 3 / 4, TABLE_HEIGHT / 3);
                playSound('TableLevelUp');

                // Multiball mode: double scoring for a period
                const originalMultiplier = scoreMultiplier;
                scoreMultiplier *= 2;

                // End multiball after 30 seconds
                setTimeout(() => {
                    multiballActive = false;
                    scoreMultiplier = originalMultiplier;
                }, 30000);
            }

            if (currentTable === 3) {
                handleTable3Features(objects[0]); // assuming ball is objects[0] like your build functions
            }

            




        }

        // Plunge sound detection
        if (!keys.c && prevPlungeKey && gameState === STATE_PLAYING) {
            playSound('Plunge');
        }

        // Saucer timer (per frame)
        if (saucerActive) {
            saucerTimer--;
            if (saucerTimer <= 0) {
                if (saucerLevelUpDone) {
                    saucerActive = false;
                    saucerLevelUpDone = false;
                    const ball = objects[0];
                    ball.vy = -0.4;
                    ball.vx = (Math.random() - 0.5) * 0.15;
                } else {
                    const threshold = saucerLevel < SAUCER_THRESHOLDS.length
                        ? SAUCER_THRESHOLDS[saucerLevel]
                        : SAUCER_THRESHOLDS[SAUCER_THRESHOLDS.length - 1] * 2;
                    if (score >= threshold) {
                        targetLevel++;
                        saucerLevel++;
                        maxTableLevel = Math.max(maxTableLevel, targetLevel);
                        score += 50 * scoreMultiplier * targetValueMultiplier;
                        updateScoreDisplay(score);
                        if (allOrNothingActive) {
                            score *= 3;
                            updateScoreDisplay(score);
                            allOrNothingActive = false;
                            createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 3, 50);
                        }
                        saucerLevelUpDone = true;
                        levelUpTimer = 90;
                        saucerTimer = 90;
                        if (window.dmdTrigger) window.dmdTrigger('levelup');
                        createParticles(SAUCER_X, SAUCER_Y - 20, 40);
                        createFirework(TABLE_WIDTH / 2, TABLE_HEIGHT / 4);
                        playSound('TableLevelUp');

                        // Transition to Table 2 on first successful saucer capture
                        if (ENABLE_SAUCER_TABLE2_TRANSITION && currentTable === 1) {
                        saucerTimer = 150;  // Extra time for transition
                        setTimeout(() => {
                            transitionToTable2();
                        }, 1500);
                        }
                    } else {
                        score += 15 * scoreMultiplier * targetValueMultiplier;
                        updateScoreDisplay(score);
                        if (allOrNothingActive) {
                            score *= 3;
                            updateScoreDisplay(score);
                            allOrNothingActive = false;
                            createParticles(TABLE_WIDTH / 2, TABLE_HEIGHT / 3, 50);
                        }
                        saucerActive = false;
                        const ball = objects[0];
                        ball.vy = -0.4;
                        ball.vx = (Math.random() - 0.5) * 0.15;
                    }
                }
            }
        }

        // Update display timers and particles during gameplay
        if (levelUpTimer > 0) {
            levelUpTimer--;
            if (levelUpTimer > 0 && levelUpTimer % 15 === 0) {
                createFirework(
                    60 + Math.random() * (TABLE_WIDTH - 120),
                    80 + Math.random() * (TABLE_HEIGHT / 4)
                );
            }
        }
        if (ballSaveTimer > 0) ballSaveTimer--;
        if (extraBallTimer > 0) {
            extraBallTimer--;
            if (extraBallTimer > 0 && extraBallTimer % 20 === 0) {
                createFirework(
                    60 + Math.random() * (TABLE_WIDTH - 120),
                    80 + Math.random() * (TABLE_HEIGHT / 3)
                );
            }
        }

        // Table 2 specific updates
        if (currentTable === 2) {
            // Update spinner rotation continuously
            if (spinnerSpeed > 0.5) {
                spinnerAngle += spinnerSpeed;  // Continuous rotation
                spinnerSpeed *= 0.97;  // Friction decay
                // Award points for each rotation
                if (Math.floor((spinnerAngle - spinnerSpeed) / 360) < Math.floor(spinnerAngle / 360)) {
                    score += 5 * scoreMultiplier * targetValueMultiplier;
                    updateScoreDisplay(score);
                }
            } else {
                spinnerSpeed = 0;
            }
        }

        // Table transition timer
        if (tableTransitioning && tableTransitionTimer > 0) {
            tableTransitionTimer--;
            if (tableTransitionTimer <= 0) {
                tableTransitioning = false;
            }
        }

        particles = particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.03;
            p.life--;
            return p.life > 0;
        });

        dsParticles = dsParticles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vx *= 0.96;
            p.vy *= 0.96;
            p.life -= p.decay;
            return p.life > 0;
        });

        prevPlungeKey = keys.c;

        updateScorePopups();
    }

    // === MENU STATE UPDATE ===
    function updateMenuState() {
        // Update particles
        particles = particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.03;
            p.life--;
            return p.life > 0;
        });

        const leftJust = keys.z && !prevMenuKeys.z;
        const rightJust = keys.x && !prevMenuKeys.x;
        const vJust = keys.v && !prevVKey;
        const plungeJust = keys.c && !prevPlungeKey;

        if (gameState === STATE_WELCOME) {
            if (vJust || overlayTap === 'confirm' || overlayTap === 'start') {
                if (overlayTap === 'start') {
                    // Quick start with current initials
                    sessionInitials = ALPHABET[initialsChars[0]] + ALPHABET[initialsChars[1]] + ALPHABET[initialsChars[2]];
                    saveSavedInitials([initialsChars[0], initialsChars[1], initialsChars[2]]);
                    playerStats = loadPlayerStats(sessionInitials);
                    resetGame();
                } else {
                    currentInitialPos++;
                    if (currentInitialPos >= 3) {
                        sessionInitials = ALPHABET[initialsChars[0]] + ALPHABET[initialsChars[1]] + ALPHABET[initialsChars[2]];
                        saveSavedInitials([initialsChars[0], initialsChars[1], initialsChars[2]]);
                        playerStats = loadPlayerStats(sessionInitials);
                        resetGame();
                    }
                }
            } else if (plungeJust || overlayTap === 'back') {
                if (currentInitialPos > 0) currentInitialPos--;
            } else if (leftJust && !keys.x) {
                initialsChars[currentInitialPos] = (initialsChars[currentInitialPos] + 25) % 26;
            } else if (rightJust && !keys.z) {
                initialsChars[currentInitialPos] = (initialsChars[currentInitialPos] + 1) % 26;
            } else if (overlayTap === 'scroll_up') {
                initialsChars[currentInitialPos] = (initialsChars[currentInitialPos] + 25) % 26;
            } else if (overlayTap === 'scroll_down') {
                initialsChars[currentInitialPos] = (initialsChars[currentInitialPos] + 1) % 26;
            }
        }

        else if (gameState === STATE_GAME_OVER) {
            gameOverTimer--;
            if (gameOverTimer <= 0) {
                gameState = STATE_MENU;
            }
        }

        else if (gameState === STATE_MENU) {
            // Menu input handled by tap zones + key detection below
            if (leftJust || overlayTap === 'scores') {
                gameState = STATE_LEADERBOARD;
                showOnlineScores = false;
            } else if (rightJust || vJust || overlayTap === 'play') {
                resetGame();
            } else if (overlayTap === 'change_player') {
                gameState = STATE_WELCOME;
                currentInitialPos = 0;
            } else if (overlayTap === 'stats') {
                gameState = STATE_STATS;
            }
        }
        else if (gameState === STATE_LEADERBOARD) {
            if (leftJust || rightJust || vJust || plungeJust || overlayTap === 'back') {
                gameState = STATE_MENU;
            } else if (overlayTap === 'toggle_online') {
                showOnlineScores = !showOnlineScores;
            }
        }
        else if (gameState === STATE_CHOOSE_MODIFIER) {
            modifierScreenTimer++;
            if (modifierScreenTimer > 30) {
                if (leftJust || overlayTap === 'mod_left') {
                    applyModifier(modifierChoiceLeft);
                    setupNewBall();
                } else if (rightJust || overlayTap === 'mod_right') {
                    applyModifier(modifierChoiceRight);
                    setupNewBall();
                }
            }
        }

        else if (gameState === STATE_STATS) {
            if (leftJust || rightJust || plungeJust || vJust || overlayTap === 'back_to_menu') {
                gameState = STATE_MENU;
            }
        }

        prevMenuKeys = { z: keys.z, x: keys.x };
        prevVKey = keys.v;
        prevPlungeKey = keys.c;
        overlayTap = null;
    }

    //draw table helpers
    function drawTable3Features() {
        // Scoops
        for (const sc of scoops) {
            ctx.save();
            ctx.strokeStyle = sc.color;
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(sc.x, sc.y, sc.radius + 4, 0, Math.PI * 2);
            ctx.stroke();

            ctx.globalAlpha = 0.25;
            ctx.fillStyle = sc.color;
            ctx.beginPath();
            ctx.arc(sc.x, sc.y, sc.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // Spinners (draw as a bar between two posts)
        for (const s of spinners) {
            const half = s.length * 0.5;
            const ax = Math.cos(s.angle), ay = Math.sin(s.angle);

            const x1 = s.x - ax * half, y1 = s.y - ay * half;
            const x2 = s.x + ax * half, y2 = s.y + ay * half;

            ctx.save();
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#ffffff';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 10;

            // posts
            ctx.beginPath(); ctx.arc(x1, y1, 5, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.arc(x2, y2, 5, 0, Math.PI*2); ctx.stroke();

            // blade
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
        }

        // Standups
        for (const st of standups) {
            ctx.save();
            ctx.fillStyle = st.color;
            ctx.globalAlpha = 0.95;
            ctx.beginPath();
            ctx.arc(st.x, st.y, st.radius, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }
    }


    // === SCI-FI OVERLAY HELPERS ===
    // Shared starfield + bg for all overlay screens
    function drawSciFiBg(alpha=0.88) {
        const t = performance.now() * 0.001;
        ctx.fillStyle = `rgba(2,0,10,${alpha})`;
        ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);
        // Stars
        if (!window._overlayStars) {
            window._overlayStars = Array.from({length:65}, () => ({
                x: Math.random()*TABLE_WIDTH, y: Math.random()*TABLE_HEIGHT,
                sz: Math.random()<0.15 ? 1.5 : 0.8,
                ph: Math.random()*Math.PI*2,
                sp: 0.015+Math.random()*0.04,
                mag: Math.random()<0.28,
            }));
        }
        for (const s of window._overlayStars) {
            const op = 0.08 + 0.5*(0.5+0.5*Math.sin(t*s.sp*6.28+s.ph));
            ctx.fillStyle = s.mag ? `rgba(255,120,240,${op})` : `rgba(240,240,255,${op})`;
            ctx.fillRect(s.x, s.y, s.sz, s.sz);
        }
        // Warp rings
        ctx.save();
        const wcx=OX, wcy=TABLE_HEIGHT*0.42;
        for (let r=0;r<6;r++) {
            const rt=((t*0.28+r*0.18)%1);
            const e=rt*rt;
            ctx.globalAlpha=(1-e)*0.09;
            ctx.beginPath();
            ctx.ellipse(wcx,wcy,e*TABLE_WIDTH*0.92,e*TABLE_HEIGHT*0.58,0,0,Math.PI*2);
            ctx.strokeStyle=r%2===0?'rgba(255,0,200,1)':'rgba(64,224,255,1)';
            ctx.lineWidth=0.8; ctx.stroke();
        }
        ctx.globalAlpha=1; ctx.restore();
        // Scanlines
        for (let sy=0;sy<TABLE_HEIGHT;sy+=3) {
            ctx.fillStyle=`rgba(0,0,0,${0.03+0.015*Math.sin(sy*0.3+t*8)})`;
            ctx.fillRect(0,sy,TABLE_WIDTH,1);
        }
    }
    // Sci-fi neon button
    function drawSciFiBtn(x,y,w,h,label,col,glowCol,active=true) {
        const t=performance.now()*0.001;
        const pulse=active?(0.55+0.35*Math.sin(t*3.2)):0.3;
        // Halo
        ctx.save();
        ctx.shadowColor=glowCol; ctx.shadowBlur=active?22:8;
        const halo=ctx.createRadialGradient(x+w/2,y+h/2,0,x+w/2,y+h/2,w*0.7);
        halo.addColorStop(0,`${glowCol}${active?'28':'10'}`);
        halo.addColorStop(1,'transparent');
        ctx.fillStyle=halo; ctx.fillRect(x-8,y-8,w+16,h+16);
        ctx.restore();
        // Background
        ctx.save();
        const bg=ctx.createLinearGradient(x,y,x,y+h);
        bg.addColorStop(0,'rgba(20,0,35,0.92)');
        bg.addColorStop(1,'rgba(8,0,18,0.96)');
        ctx.fillStyle=bg;
        ctx.beginPath(); ctx.roundRect(x,y,w,h,4); ctx.fill();
        ctx.restore();
        // Corner marks
        ctx.save();
        ctx.strokeStyle=`${col}${active?'cc':'44'}`; ctx.lineWidth=1.2;
        const cm=7;
        [[x,y,1,1],[x+w,y,-1,1],[x,y+h,1,-1],[x+w,y+h,-1,-1]].forEach(([cx,cy,dx,dy])=>{
            ctx.beginPath(); ctx.moveTo(cx+dx*cm,cy); ctx.lineTo(cx,cy); ctx.lineTo(cx,cy+dy*cm); ctx.stroke();
        });
        ctx.restore();
        // Border
        ctx.save();
        ctx.shadowColor=glowCol; ctx.shadowBlur=active?16:6;
        ctx.strokeStyle=`${col}${active?Math.round(pulse*255).toString(16).padStart(2,'0'):'33'}`;
        ctx.lineWidth=1.2;
        ctx.beginPath(); ctx.roundRect(x,y,w,h,4); ctx.stroke();
        ctx.restore();
        // Shine sweep
        if (active) {
            const sf=(t*0.65)%1;
            const sy=y+sf*h;
            ctx.save();
            ctx.beginPath(); ctx.roundRect(x,y,w,h,4); ctx.clip();
            const sg=ctx.createLinearGradient(0,sy-10,0,sy+10);
            sg.addColorStop(0,'transparent'); sg.addColorStop(0.5,'rgba(255,255,255,0.09)'); sg.addColorStop(1,'transparent');
            ctx.fillStyle=sg; ctx.fillRect(x,sy-10,w,20);
            ctx.restore();
        }
        // Label with pixel shadow
        ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.font=`bold 14px 'Orbitron', monospace`;
        if (active) { ctx.fillStyle=`${col}55`; ctx.fillText(label,x+w/2+1.5,y+h/2+1.5); }
        ctx.shadowColor=glowCol; ctx.shadowBlur=active?12:4;
        ctx.fillStyle=active?col:`${col}55`; ctx.fillText(label,x+w/2,y+h/2);
        ctx.restore();
    }
    // Sci-fi section header
    function drawSciFiHeader(text, y, size=22, col='#ff00cc', sub=null) {
        const t=performance.now()*0.001;
        ctx.save(); ctx.textAlign='center';
        ctx.font=`bold ${size}px 'Orbitron', monospace`;
        // Pixel shadow stack
        ['rgba(255,0,200,0.12)','rgba(255,0,200,0.22)','rgba(255,0,200,0.45)'].forEach((c,i)=>{
            ctx.fillStyle=c; ctx.fillText(text,OX+(2-i)*1.2,y+(2-i)*1.2);
        });
        ctx.shadowColor=col; ctx.shadowBlur=18;
        ctx.fillStyle='#ffffff'; ctx.fillText(text,OX,y);
        ctx.restore();
        if (sub) {
            ctx.save(); ctx.textAlign='center';
            ctx.font=`10px 'Share Tech Mono', monospace`;
            ctx.shadowColor='#40e0ff'; ctx.shadowBlur=6;
            ctx.fillStyle=`rgba(64,224,255,${0.5+0.2*Math.sin(t*2)})`;
            ctx.fillText(sub,OX,y+20);
            ctx.restore();
        }
        // Separator
        const sg=ctx.createLinearGradient(20,0,TABLE_WIDTH-20,0);
        const p=0.35+0.25*Math.sin(performance.now()*0.0025);
        sg.addColorStop(0,'transparent');
        sg.addColorStop(0.35,`rgba(255,0,200,${p})`);
        sg.addColorStop(0.65,`rgba(64,224,255,${p})`);
        sg.addColorStop(1,'transparent');
        ctx.strokeStyle=sg; ctx.lineWidth=0.8;
        ctx.beginPath(); ctx.moveTo(OX-TABLE_WIDTH*0.46,y+28); ctx.lineTo(OX+TABLE_WIDTH*0.46,y+28); ctx.stroke();
    }

    // === DRAW OVERLAY ===
    function drawOverlay() {
        if (gameState === STATE_WELCOME) {
            const wt = performance.now() * 0.001;
            drawSciFiBg(0.90);

            // ── Title ────────────────────────────────────────────────────
            const titleY = TABLE_HEIGHT * 0.14;
            ctx.save(); ctx.textAlign = 'center';
            ctx.font = "bold 38px 'Orbitron', monospace";
            // Pixel shadow
            ['rgba(255,0,200,0.12)','rgba(255,0,200,0.25)','rgba(255,0,200,0.5)'].forEach((c,i) => {
                ctx.fillStyle=c; ctx.fillText('PinB'+'ALL',OX+(2-i)*1.5,titleY+(2-i)*1.5);
            });
            ctx.shadowColor='#ff00cc'; ctx.shadowBlur=22;
            ctx.fillStyle='#ff00cc'; ctx.fillText('PinB',OX-50,titleY);
            ctx.shadowColor='#40e0ff'; ctx.shadowBlur=22;
            ctx.fillStyle='#40e0ff'; ctx.fillText('ALL',OX+24,titleY);
            ctx.restore();

            ctx.save(); ctx.textAlign='center';
            ctx.font="bold 18px 'Orbitron', monospace";
            ctx.shadowColor='rgba(255,255,255,0.4)'; ctx.shadowBlur=10;
            ctx.fillStyle='rgba(255,255,255,0.82)';
            ctx.fillText('or Nothing',OX,titleY+32);
            ctx.restore();

            // Separator
            const sg0=ctx.createLinearGradient(20,0,TABLE_WIDTH-20,0);
            const pp=0.3+0.2*Math.sin(wt*2);
            sg0.addColorStop(0,'transparent'); sg0.addColorStop(0.4,`rgba(255,0,200,${pp})`);
            sg0.addColorStop(0.6,`rgba(64,224,255,${pp})`); sg0.addColorStop(1,'transparent');
            ctx.strokeStyle=sg0; ctx.lineWidth=0.8;
            ctx.beginPath(); ctx.moveTo(20,titleY+46); ctx.lineTo(TABLE_WIDTH-20,titleY+46); ctx.stroke();

            // ── Sub header ────────────────────────────────────────────────
            ctx.save(); ctx.textAlign='center';
            ctx.font="10px 'Share Tech Mono', monospace";
            ctx.fillStyle=`rgba(64,224,255,${0.45+0.2*Math.sin(wt*2.2)})`;
            ctx.fillText('── ENTER YOUR INITIALS ──',OX,titleY+62);
            ctx.restore();

            // ── Letter boxes ─────────────────────────────────────────────
            const boxW=50, boxH=60, boxGap=14;
            const totalW=boxW*3+boxGap*2;
            const startX=(TABLE_WIDTH-totalW)/2;
            const boxY=titleY+78;

            for (let i=0;i<3;i++) {
                const bx=startX+i*(boxW+boxGap);
                const isActive=i===currentInitialPos;
                const isDone=i<currentInitialPos;
                const col=isActive?'#40e0ff':(isDone?'#ff00cc':'rgba(80,60,100,0.6)');
                const gcol=isActive?'#40e0ff':(isDone?'#ff00cc':'rgba(60,40,80,0.4)');

                // Glow halo
                if (isActive||isDone) {
                    ctx.save();
                    ctx.shadowColor=gcol; ctx.shadowBlur=20;
                    ctx.fillStyle=`${gcol}18`;
                    ctx.beginPath(); ctx.roundRect(bx-4,boxY-4,boxW+8,boxH+8,6); ctx.fill();
                    ctx.restore();
                }
                // BG fill
                ctx.save();
                const bgg=ctx.createLinearGradient(bx,boxY,bx,boxY+boxH);
                bgg.addColorStop(0,'rgba(20,0,35,0.92)'); bgg.addColorStop(1,'rgba(6,0,16,0.96)');
                ctx.fillStyle=bgg; ctx.beginPath(); ctx.roundRect(bx,boxY,boxW,boxH,5); ctx.fill();
                ctx.restore();
                // Corner marks
                ctx.save(); ctx.strokeStyle=`${col}`; ctx.lineWidth=1.5;
                const cm=8;
                [[bx,boxY,1,1],[bx+boxW,boxY,-1,1],[bx,boxY+boxH,1,-1],[bx+boxW,boxY+boxH,-1,-1]].forEach(([cx,cy,dx,dy])=>{
                    ctx.beginPath(); ctx.moveTo(cx+dx*cm,cy); ctx.lineTo(cx,cy); ctx.lineTo(cx,cy+dy*cm); ctx.stroke();
                });
                ctx.restore();
                // Border
                ctx.save();
                ctx.shadowColor=gcol; ctx.shadowBlur=isActive?16:isDone?10:4;
                ctx.strokeStyle=col; ctx.lineWidth=isActive?2:1.2;
                ctx.beginPath(); ctx.roundRect(bx,boxY,boxW,boxH,5); ctx.stroke();
                ctx.restore();
                // Shine (active)
                if (isActive) {
                    const sf=(wt*0.7)%1, sy2=boxY+sf*boxH;
                    ctx.save(); ctx.beginPath(); ctx.roundRect(bx,boxY,boxW,boxH,5); ctx.clip();
                    const shg=ctx.createLinearGradient(0,sy2-12,0,sy2+12);
                    shg.addColorStop(0,'transparent'); shg.addColorStop(0.5,'rgba(255,255,255,0.10)'); shg.addColorStop(1,'transparent');
                    ctx.fillStyle=shg; ctx.fillRect(bx,sy2-12,boxW,24); ctx.restore();
                }
                // Letter
                const letter=(isDone||isActive)?ALPHABET[initialsChars[i]]:'_';
                ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.font="bold 30px 'Orbitron', monospace";
                if (isActive||isDone) { ctx.fillStyle=`${col}44`; ctx.fillText(letter,bx+boxW/2+1.5,boxY+boxH/2+1.5); }
                ctx.shadowColor=gcol; ctx.shadowBlur=isActive?14:8;
                ctx.fillStyle=col; ctx.fillText(letter,bx+boxW/2,boxY+boxH/2);
                ctx.restore();
                // Arrows
                if (isActive) {
                    const ab=0.6+0.4*Math.sin(wt*4);
                    ctx.save(); ctx.textAlign='center';
                    ctx.font="13px 'Share Tech Mono', monospace";
                    ctx.fillStyle=`rgba(255,0,200,${ab})`;
                    ctx.shadowColor='#ff00cc'; ctx.shadowBlur=8*ab;
                    ctx.fillText('▲',bx+boxW/2,boxY-10);
                    ctx.fillText('▼',bx+boxW/2,boxY+boxH+12);
                    ctx.restore();
                }
            }

            // ── Buttons ───────────────────────────────────────────────────
            const btnRowY=boxY+boxH+26;
            drawSciFiBtn(OX-86,btnRowY,74,34,'BACK','#ff8800','#ff8800',true);
            drawSciFiBtn(OX+12,btnRowY,74,34,'CONFIRM','#40e0ff','#40e0ff',true);

            const startBtnY=btnRowY+50;
            drawSciFiBtn(OX-80,startBtnY,160,48,'START','#ff00cc','#ff00cc',true);

            // Hint
            ctx.save(); ctx.textAlign='center';
            ctx.font="9px 'Share Tech Mono', monospace";
            ctx.fillStyle='rgba(80,60,100,0.7)';
            ctx.fillText('L/R SCROLL  ·  V NEXT  ·  SPACE BACK',OX,startBtnY+62);
            ctx.restore();
        }

        else if (gameState === STATE_GAME_OVER) {
            const got = performance.now() * 0.001;
            drawSciFiBg(0.82);
            const cy = TABLE_HEIGHT * 0.30;
            drawSciFiHeader('GAME OVER', cy, 32, '#ff00cc', '── SESSION ENDED ──');

            // Score panel
            ctx.save();
            const spX=OX-90, spY=cy+50, spW=180, spH=80;
            const spBg=ctx.createLinearGradient(spX,spY,spX,spY+spH);
            spBg.addColorStop(0,'rgba(20,0,35,0.9)'); spBg.addColorStop(1,'rgba(6,0,16,0.95)');
            ctx.fillStyle=spBg; ctx.shadowColor='#ff00cc'; ctx.shadowBlur=18;
            ctx.beginPath(); ctx.roundRect(spX,spY,spW,spH,6); ctx.fill();
            ctx.strokeStyle='rgba(255,0,200,0.7)'; ctx.lineWidth=1.2;
            ctx.beginPath(); ctx.roundRect(spX,spY,spW,spH,6); ctx.stroke();
            ctx.restore();
            // Score label
            ctx.save(); ctx.textAlign='center';
            ctx.font="8px 'Share Tech Mono', monospace";
            ctx.fillStyle='rgba(255,0,200,0.6)'; ctx.fillText('FINAL SCORE',OX,spY+16);
            ctx.restore();
            // Score value – pixel shadow
            ctx.save(); ctx.textAlign='center';
            ctx.font="bold 28px 'Orbitron', monospace";
            ctx.fillStyle='rgba(255,200,0,0.25)'; ctx.fillText(String(finalScore).padStart(8,'0'),OX+2,spY+46+2);
            ctx.shadowColor='#ffcc00'; ctx.shadowBlur=16;
            ctx.fillStyle='#ffcc00'; ctx.fillText(String(finalScore).padStart(8,'0'),OX,spY+46);
            ctx.restore();
            if (sessionInitials) {
                ctx.save(); ctx.textAlign='center';
                ctx.font="12px 'Share Tech Mono', monospace";
                ctx.shadowColor='#40e0ff'; ctx.shadowBlur=8;
                ctx.fillStyle='rgba(64,224,255,0.85)';
                ctx.fillText('── '+sessionInitials+' ──',OX,spY+68);
                ctx.restore();
            }
            let extraY = spY+spH+18;
            if (maxTableLevel > 0) {
                ctx.save(); ctx.textAlign='center';
                ctx.font="11px 'Share Tech Mono', monospace";
                ctx.shadowColor='#ff8800'; ctx.shadowBlur=8;
                ctx.fillStyle='rgba(255,136,0,0.85)';
                ctx.fillText('TABLE LEVEL  '+maxTableLevel,OX,extraY);
                ctx.restore(); extraY+=20;
            }
            if (isNewHighScore && (Math.floor(got*2)%2===0)) {
                ctx.save(); ctx.textAlign='center';
                ctx.font="bold 16px 'Orbitron', monospace";
                ctx.shadowColor='#ffff00'; ctx.shadowBlur=20;
                ctx.fillStyle='#ffff00';
                ctx.fillText('★ NEW HIGH SCORE ★',OX,extraY+4);
                ctx.restore();
            }
        }

        else if (gameState === STATE_MENU) {
            drawSciFiBg(0.88);
            drawSciFiHeader('GAME OVER', TABLE_HEIGHT*0.14, 28, '#ff00cc', '── POST-GAME ──');
            const spX2=OX-95, spY2=TABLE_HEIGHT*0.14+48, spW2=190, spH2=75;
            ctx.save();
            const spg2=ctx.createLinearGradient(spX2,spY2,spX2,spY2+spH2);
            spg2.addColorStop(0,'rgba(20,0,35,0.92)'); spg2.addColorStop(1,'rgba(6,0,16,0.96)');
            ctx.fillStyle=spg2; ctx.shadowColor='#ffcc00'; ctx.shadowBlur=16;
            ctx.beginPath(); ctx.roundRect(spX2,spY2,spW2,spH2,6); ctx.fill();
            ctx.strokeStyle='rgba(255,200,0,0.55)'; ctx.lineWidth=1.2;
            ctx.beginPath(); ctx.roundRect(spX2,spY2,spW2,spH2,6); ctx.stroke(); ctx.restore();
            ctx.save(); ctx.textAlign='center';
            ctx.font="8px 'Share Tech Mono', monospace"; ctx.fillStyle='rgba(255,200,0,0.55)';
            ctx.fillText('FINAL SCORE',OX,spY2+14); ctx.restore();
            ctx.save(); ctx.textAlign='center';
            ctx.font="bold 26px 'Orbitron', monospace";
            ctx.fillStyle='rgba(255,200,0,0.22)'; ctx.fillText(String(finalScore).padStart(8,'0'),OX+2,spY2+42+2);
            ctx.shadowColor='#ffcc00'; ctx.shadowBlur=14; ctx.fillStyle='#ffcc00';
            ctx.fillText(String(finalScore).padStart(8,'0'),OX,spY2+42); ctx.restore();
            if (sessionInitials) {
                ctx.save(); ctx.textAlign='center'; ctx.font="11px 'Share Tech Mono', monospace";
                ctx.shadowColor='#40e0ff'; ctx.shadowBlur=8; ctx.fillStyle='rgba(64,224,255,0.8)';
                ctx.fillText('Player · '+sessionInitials,OX,spY2+62); ctx.restore();
            }
            const mBtnY=spY2+spH2+28, mBtnW=120, mBtnH=46, mGap=14;
            drawSciFiBtn(OX-mBtnW-mGap/2, mBtnY, mBtnW, mBtnH, 'SCORES', '#ff00cc', '#ff00cc');
            drawSciFiBtn(OX+mGap/2, mBtnY, mBtnW, mBtnH, 'PLAY', '#40e0ff', '#40e0ff');
            ctx.save(); ctx.textAlign='center'; ctx.font="9px 'Share Tech Mono', monospace";
            ctx.fillStyle='rgba(80,60,100,0.65)';
            ctx.fillText('LEFT: SCORES  ·  RIGHT/V: PLAY AGAIN',OX,mBtnY+mBtnH+18); ctx.restore();
            const s2Y2=mBtnY+mBtnH+42;
            drawSciFiBtn(OX-80, s2Y2, 160, 36, 'CHANGE PLAYER', '#ff8800', '#ff8800');
            drawSciFiBtn(OX-55, s2Y2+52, 110, 32, 'STATS', '#40e040', '#40e040');
        }

        else if (gameState === STATE_LEADERBOARD) {
            drawSciFiBg(0.92);
            drawSciFiHeader('HIGH SCORES', 52, 24, '#ff00cc', '── RANKINGS ──');
            const lTogY=94;
            [[OX-45,'LOCAL',!showOnlineScores],[OX+45,'ONLINE',showOnlineScores]].forEach(([tx,lbl,active])=>{
                const tw=44,th=16;
                const tBg=ctx.createLinearGradient(tx-tw/2,lTogY-2,tx-tw/2,lTogY+th-2);
                tBg.addColorStop(0,active?'rgba(30,0,50,0.9)':'rgba(10,0,20,0.6)');
                tBg.addColorStop(1,active?'rgba(10,0,25,0.95)':'rgba(4,0,12,0.7)');
                ctx.save(); ctx.fillStyle=tBg; ctx.shadowColor=active?'#40e0ff':'rgba(80,60,100,0.4)'; ctx.shadowBlur=active?10:3;
                ctx.beginPath(); ctx.roundRect(tx-tw/2,lTogY-2,tw,th,3); ctx.fill();
                ctx.strokeStyle=active?'rgba(64,224,255,0.8)':'rgba(60,40,80,0.3)'; ctx.lineWidth=0.8;
                ctx.beginPath(); ctx.roundRect(tx-tw/2,lTogY-2,tw,th,3); ctx.stroke();
                ctx.fillStyle=active?'#40e0ff':'rgba(80,60,100,0.6)';
                ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font="11px 'Share Tech Mono', monospace";
                ctx.fillText(lbl,tx,lTogY+th/2-2); ctx.restore();
            });
            const lbScores=showOnlineScores?onlineScores:highScores;
            if (lbScores.length===0) {
                ctx.save(); ctx.textAlign='center'; ctx.font="14px 'Share Tech Mono', monospace";
                ctx.fillStyle='rgba(80,60,100,0.6)';
                ctx.fillText(showOnlineScores?'NO ONLINE SCORES':'NO SCORES YET',OX,200); ctx.restore();
            } else {
                for (let i=0; i<lbScores.length && i<8; i++) {
                    const hs=lbScores[i], lbRy=120+i*52, isTop=i<3;
                    const rc=i===0?'#ffcc00':i===1?'rgba(180,180,200,0.9)':i===2?'rgba(200,140,80,0.9)':'rgba(120,100,140,0.7)';
                    ctx.save();
                    const rbg2=ctx.createLinearGradient(16,lbRy-4,TABLE_WIDTH-16,lbRy-4);
                    rbg2.addColorStop(0,'rgba(0,0,0,0)'); rbg2.addColorStop(0.1,`rgba(15,0,28,${isTop?0.85:0.6})`);
                    rbg2.addColorStop(0.9,`rgba(8,0,18,${isTop?0.85:0.6})`); rbg2.addColorStop(1,'rgba(0,0,0,0)');
                    ctx.fillStyle=rbg2; ctx.beginPath(); ctx.roundRect(16,lbRy-6,TABLE_WIDTH-32,40,4); ctx.fill();
                    if(isTop){ctx.strokeStyle=`${rc}33`;ctx.lineWidth=0.8;ctx.beginPath();ctx.roundRect(16,lbRy-6,TABLE_WIDTH-32,40,4);ctx.stroke();}
                    ctx.restore();
                    ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle';
                    ctx.font=`bold ${isTop?14:12}px 'Orbitron', monospace`; ctx.shadowColor=rc; ctx.shadowBlur=isTop?10:4;
                    ctx.fillStyle=rc; ctx.fillText(i+1,36,lbRy+14); ctx.restore();
                    ctx.save(); ctx.textAlign='left'; ctx.textBaseline='middle';
                    ctx.font=`bold ${isTop?15:13}px 'Orbitron', monospace`; ctx.shadowColor='#40e0ff'; ctx.shadowBlur=isTop?10:5;
                    ctx.fillStyle='#40e0ff'; ctx.fillText(hs.initials||'???',58,lbRy+14); ctx.restore();
                    ctx.save(); ctx.textAlign='right'; ctx.textBaseline='middle';
                    ctx.font=`bold ${isTop?15:13}px 'Share Tech Mono', monospace`; ctx.shadowColor=rc; ctx.shadowBlur=isTop?8:3;
                    ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillText(String(hs.score).padStart(8,'0'),TABLE_WIDTH-50,lbRy+10); ctx.restore();
                    if(hs.maxTableLevel){ctx.save();ctx.textAlign='right';ctx.textBaseline='top';ctx.font="9px 'Share Tech Mono', monospace";ctx.fillStyle='rgba(255,136,0,0.7)';ctx.fillText('Lv'+hs.maxTableLevel,TABLE_WIDTH-50,lbRy+22);ctx.restore();}
                    const dd=new Date(hs.date); ctx.save();ctx.textAlign='left';ctx.textBaseline='top';ctx.font="8px 'Share Tech Mono', monospace";ctx.fillStyle='rgba(80,60,100,0.55)';ctx.fillText(dd.toLocaleDateString(),58,lbRy+22);ctx.restore();
                    if(i<Math.min(lbScores.length,8)-1){ctx.strokeStyle='rgba(60,0,80,0.3)';ctx.lineWidth=0.6;ctx.beginPath();ctx.moveTo(30,lbRy+38);ctx.lineTo(TABLE_WIDTH-30,lbRy+38);ctx.stroke();}
                }
            }
            drawSciFiBtn(OX-55, TABLE_HEIGHT-68, 110, 38, 'BACK', '#ff00cc', '#ff00cc');
        }

        else if (gameState === STATE_CHOOSE_MODIFIER) {
            const mt = performance.now() * 0.001;
            const ready = modifierScreenTimer > 30;

            // ── 1. Semi-transparent deep space bg ────────────────────────
            ctx.fillStyle = 'rgba(2,0,10,0.88)';
            ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

            // ── 2. Starfield ──────────────────────────────────────────────
            if (!window._modStars) {
                window._modStars = Array.from({length:55}, () => ({
                    x: Math.random()*TABLE_WIDTH,
                    y: Math.random()*TABLE_HEIGHT,
                    size: Math.random() < 0.15 ? 1.5 : 0.8,
                    phase: Math.random()*Math.PI*2,
                    speed: 0.015 + Math.random()*0.04,
                    mag: Math.random() < 0.3,
                }));
            }
            for (const s of window._modStars) {
                const op = 0.1 + 0.55*(0.5+0.5*Math.sin(mt*s.speed*6.28+s.phase));
                ctx.fillStyle = s.mag ? `rgba(255,140,240,${op})` : `rgba(255,248,240,${op})`;
                ctx.fillRect(s.x, s.y, s.size, s.size);
            }

            // ── 3. Warp tunnel rings ──────────────────────────────────────
            ctx.save();
            const wcx = OX, wcy = TABLE_HEIGHT*0.42;
            for (let ring = 0; ring < 6; ring++) {
                const rt = (mt*0.0003*1000 + ring*0.18) % 1;
                const eased = rt*rt;
                ctx.globalAlpha = (1-eased)*0.10;
                ctx.beginPath();
                ctx.ellipse(wcx, wcy, eased*TABLE_WIDTH*0.9, eased*TABLE_HEIGHT*0.55, 0, 0, Math.PI*2);
                ctx.strokeStyle = ring%2===0 ? 'rgba(255,0,200,1)' : 'rgba(64,224,255,1)';
                ctx.lineWidth = 0.8;
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();

            // ── 4. Scanlines ──────────────────────────────────────────────
            ctx.save();
            for (let sy = 0; sy < TABLE_HEIGHT; sy += 3) {
                ctx.fillStyle = `rgba(0,0,0,${0.04 + 0.02*Math.sin(sy*0.3+mt*8)})`;
                ctx.fillRect(0, sy, TABLE_WIDTH, 1);
            }
            ctx.restore();

            // ── 5. Header ─────────────────────────────────────────────────
            const headerY = TABLE_HEIGHT * 0.18;

            // "CHOOSE A BONUS" with DMD pixel glow
            ctx.save();
            ctx.textAlign = 'center';
            // Pixel-shadow stack (DMD effect)
            ctx.font = "bold 22px 'Orbitron', monospace";
            ['rgba(255,0,200,0.15)','rgba(255,0,200,0.25)','rgba(255,0,200,0.5)'].forEach((c,i) => {
                ctx.fillStyle = c;
                ctx.fillText('CHOOSE A BONUS', OX + (2-i)*1.5, headerY + (2-i)*1.5);
            });
            ctx.shadowColor = '#ff00cc'; ctx.shadowBlur = 20;
            ctx.fillStyle = '#ffffff';
            ctx.fillText('CHOOSE A BONUS', OX, headerY);
            ctx.restore();

            // Subtitle line
            ctx.save();
            ctx.textAlign = 'center';
            ctx.shadowColor = '#40e0ff'; ctx.shadowBlur = 8;
            ctx.fillStyle = 'rgba(64,224,255,0.7)';
            ctx.font = "11px 'Share Tech Mono', monospace";
            ctx.fillText('── SELECT YOUR POWER-UP ──', OX, headerY + 22);
            ctx.restore();

            // Animated separator line
            const sepPulse = 0.4 + 0.3*Math.sin(mt*2.5);
            const sepGrad = ctx.createLinearGradient(20, 0, TABLE_WIDTH-20, 0);
            sepGrad.addColorStop(0, 'transparent');
            sepGrad.addColorStop(0.3, `rgba(255,0,200,${sepPulse})`);
            sepGrad.addColorStop(0.7, `rgba(64,224,255,${sepPulse})`);
            sepGrad.addColorStop(1, 'transparent');
            ctx.strokeStyle = sepGrad;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(20, headerY+30); ctx.lineTo(TABLE_WIDTH-20, headerY+30);
            ctx.stroke();

            // ── 6. Modifier boxes ─────────────────────────────────────────
            const boxW = 158, boxH = 195;
            const boxY = headerY + 50;
            const leftBoxX  = OX - boxW - 8;
            const rightBoxX = OX + 8;

            function drawModBox(bx, choice, col, glowCol, side) {
                if (!choice) return;
                const picks = (playerStats && playerStats.modPicks) ? (playerStats.modPicks[choice.id] || 0) : 0;
                const boxPulse = ready ? (0.6 + 0.4*Math.sin(mt*3.0 + side*Math.PI)) : 0.25;

                // ── Outer glow halo ───────────────────────────────────────
                ctx.save();
                ctx.shadowColor = glowCol;
                ctx.shadowBlur  = ready ? 30 : 10;
                const halo = ctx.createRadialGradient(bx+boxW/2, boxY+boxH/2, 0, bx+boxW/2, boxY+boxH/2, boxW*0.8);
                halo.addColorStop(0, `rgba(${side===0?'255,0,200':'64,224,255'},${boxPulse*0.15})`);
                halo.addColorStop(1, 'transparent');
                ctx.fillStyle = halo;
                ctx.fillRect(bx-20, boxY-20, boxW+40, boxH+40);
                ctx.restore();

                // ── Background fill ───────────────────────────────────────
                ctx.save();
                const bgG = ctx.createLinearGradient(bx, boxY, bx, boxY+boxH);
                bgG.addColorStop(0, 'rgba(15,0,30,0.9)');
                bgG.addColorStop(1, 'rgba(5,0,15,0.95)');
                ctx.fillStyle = bgG;
                ctx.beginPath(); ctx.roundRect(bx, boxY, boxW, boxH, 6); ctx.fill();
                ctx.restore();

                // ── Corner accent marks ───────────────────────────────────
                ctx.save();
                ctx.strokeStyle = `rgba(${side===0?'255,0,200':'64,224,255'},${boxPulse*0.8})`;
                ctx.lineWidth = 1.5;
                const cm = 12;
                [[bx,boxY],[bx+boxW,boxY],[bx,boxY+boxH],[bx+boxW,boxY+boxH]].forEach(([cx2,cy2], ci) => {
                    const dx = ci%2===0 ? 1 : -1, dy = ci<2 ? 1 : -1;
                    ctx.beginPath();
                    ctx.moveTo(cx2+dx*cm, cy2); ctx.lineTo(cx2, cy2); ctx.lineTo(cx2, cy2+dy*cm);
                    ctx.stroke();
                });
                ctx.restore();

                // ── Border ────────────────────────────────────────────────
                ctx.save();
                ctx.shadowColor = glowCol; ctx.shadowBlur = ready ? 18 : 6;
                ctx.strokeStyle = `${col}${ready ? 'cc' : '55'}`;
                ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.roundRect(bx, boxY, boxW, boxH, 6); ctx.stroke();
                ctx.restore();

                // ── Icon area – spinning conic ring ───────────────────────
                const iconCX = bx + boxW/2, iconCY = boxY + 36;
                const iconR = 18;
                ctx.save();
                ctx.beginPath(); ctx.arc(iconCX, iconCY, iconR+4, 0, Math.PI*2); ctx.clip();
                const numSteps = 32;
                for (let si = 0; si < numSteps; si++) {
                    const a0 = mt*(ready?2.5:1.0) + si/numSteps * Math.PI*2;
                    const a1 = a0 + Math.PI*2/numSteps * 1.05;
                    const frac = si/numSteps;
                    const r2 = side===0
                        ? [255, Math.round(frac*80), Math.round(frac*200)]
                        : [Math.round(frac*64), Math.round(200+frac*24), 255];
                    ctx.strokeStyle = `rgba(${r2[0]},${r2[1]},${r2[2]},${ready?0.9:0.4})`;
                    ctx.lineWidth = iconR*0.32;
                    ctx.beginPath();
                    ctx.arc(iconCX, iconCY, iconR*0.84, a0, a1);
                    ctx.stroke();
                }
                ctx.restore();
                // Inner dark cap
                ctx.save();
                ctx.shadowColor = glowCol; ctx.shadowBlur = 10;
                const capG = ctx.createRadialGradient(iconCX-4, iconCY-4, 0, iconCX, iconCY, iconR*0.68);
                capG.addColorStop(0, 'rgba(240,240,255,0.95)');
                capG.addColorStop(0.3, col+'cc');
                capG.addColorStop(1, 'rgba(0,0,20,0.95)');
                ctx.fillStyle = capG;
                ctx.beginPath(); ctx.arc(iconCX, iconCY, iconR*0.68, 0, Math.PI*2); ctx.fill();
                ctx.restore();

                // ── Name text with pixel DMD shadow ──────────────────────
                ctx.save(); ctx.textAlign = 'center';
                ctx.font = `bold ${ready?17:15}px 'Orbitron', monospace`;
                // Pixel shadow stack
                if (ready) {
                    ctx.fillStyle = `${col}44`;
                    ctx.fillText(choice.name, bx+boxW/2+2, boxY+70+2);
                    ctx.fillText(choice.name2||'', bx+boxW/2+2, boxY+90+2);
                }
                ctx.shadowColor = glowCol; ctx.shadowBlur = ready ? 12 : 4;
                ctx.fillStyle = ready ? col : '#553355';
                ctx.fillText(choice.name, bx+boxW/2, boxY+70);
                if (choice.name2) ctx.fillText(choice.name2, bx+boxW/2, boxY+90);
                ctx.restore();

                // ── Separator ─────────────────────────────────────────────
                ctx.save();
                ctx.strokeStyle = `rgba(${side===0?'255,0,200':'64,224,255'},0.2)`;
                ctx.lineWidth = 0.8; ctx.setLineDash([4,3]);
                ctx.beginPath();
                ctx.moveTo(bx+14, boxY+103); ctx.lineTo(bx+boxW-14, boxY+103);
                ctx.stroke(); ctx.setLineDash([]);
                ctx.restore();

                // ── Description ───────────────────────────────────────────
                ctx.save(); ctx.textAlign = 'center';
                ctx.font = "10px 'Share Tech Mono', monospace";
                ctx.fillStyle = ready ? 'rgba(200,200,220,0.85)' : '#444455';
                // Word-wrap simple version
                const words = (choice.desc||'').split(' ');
                let line = '', lineY = boxY+120;
                for (const w of words) {
                    const test = line + w + ' ';
                    if (ctx.measureText(test).width > boxW-20 && line) {
                        ctx.fillText(line.trim(), bx+boxW/2, lineY);
                        line = w + ' '; lineY += 14;
                    } else { line = test; }
                }
                if (line.trim()) ctx.fillText(line.trim(), bx+boxW/2, lineY);
                ctx.restore();

                // ── Picks / data row ──────────────────────────────────────
                ctx.save();
                ctx.textAlign = 'center';
                ctx.font = "9px 'Share Tech Mono', monospace";
                ctx.fillStyle = 'rgba(100,80,120,0.7)';
                ctx.fillText('PICKED ' + picks + 'x', bx+boxW/2, boxY+boxH-12);
                ctx.restore();

                // ── Shine sweep ───────────────────────────────────────────
                if (ready) {
                    const sf2 = (mt*0.7 + side*0.5) % 1;
                    const sy2 = boxY + sf2 * boxH;
                    ctx.save();
                    ctx.beginPath(); ctx.roundRect(bx, boxY, boxW, boxH, 6); ctx.clip();
                    const sg2 = ctx.createLinearGradient(0, sy2-15, 0, sy2+15);
                    sg2.addColorStop(0, 'transparent');
                    sg2.addColorStop(0.5, `rgba(255,255,255,0.10)`);
                    sg2.addColorStop(1, 'transparent');
                    ctx.fillStyle = sg2;
                    ctx.fillRect(bx, sy2-15, boxW, 30);
                    ctx.restore();
                }
            }

            drawModBox(leftBoxX,  modifierChoiceLeft,  '#ff00cc', '#ff00cc', 0);
            drawModBox(rightBoxX, modifierChoiceRight, '#40e0ff', '#40e0ff', 1);

            // ── 7. Centre divider ─────────────────────────────────────────
            ctx.save();
            ctx.strokeStyle = `rgba(255,255,255,${0.06 + 0.04*Math.sin(mt*3)})`;
            ctx.lineWidth = 1; ctx.setLineDash([3,6]);
            ctx.beginPath();
            ctx.moveTo(OX, boxY+10);
            ctx.lineTo(OX, boxY+boxH-10);
            ctx.stroke(); ctx.setLineDash([]);
            ctx.restore();

            // ── 8. Prompt text ────────────────────────────────────────────
            const promptY = boxY + boxH + 28;
            ctx.save();
            ctx.textAlign = 'center';
            ctx.font = "bold 11px 'Share Tech Mono', monospace";
            if (ready) {
                const pb = 0.5 + 0.5*Math.sin(mt*3.5);
                ctx.shadowColor = '#40e0ff'; ctx.shadowBlur = 8*pb;
                ctx.fillStyle = `rgba(64,224,255,${0.6+0.4*pb})`;
                ctx.fillText('◄ LEFT FLIPPER  ·  RIGHT FLIPPER ►', OX, promptY);
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(100,80,120,0.5)';
                ctx.font = "9px 'Share Tech Mono', monospace";
                ctx.fillText('TO SELECT YOUR BONUS', OX, promptY+16);
            } else {
                ctx.fillStyle = '#443355';
                ctx.fillText('PREPARING BONUS SELECTION...', OX, promptY);
                // Loading dots
                const dots = Math.floor(mt*3) % 4;
                ctx.fillStyle = 'rgba(255,0,200,0.4)';
                for (let d = 0; d < dots; d++) {
                    ctx.beginPath();
                    ctx.arc(OX - 18 + d*12, promptY+18, 2, 0, Math.PI*2);
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        else if (gameState === STATE_STATS) {
            const stt = performance.now() * 0.001;
            drawSciFiBg(0.92);
            drawSciFiHeader('PLAYER STATS', 52, 22, '#40e0ff', sessionInitials ? ('── ' + sessionInitials + ' ──') : '── STATISTICS ──');

            const stats = playerStats || (sessionInitials ? loadPlayerStats(sessionInitials) : null);
            const statLines = stats ? [
                ['Games Played',    stats.gamesPlayed || 0,       '#40e0ff'],
                ['Total Score',     stats.totalScore || 0,         '#ffcc00'],
                ['Targets Cleared', stats.allTargetsCleared || 0,  '#ff00cc'],
                ['Bumper Hits',     stats.colorBumperHits || 0,    '#40e0ff'],
                ['Saucer Captures', stats.saucerCaptures || 0,     '#ff00cc'],
                ['Extra Balls',     stats.extraBallsEarned || 0,   '#40e040'],
                ['Max Multiplier',  ((stats.maxMultiplier||1)+'x'),'#ff8800'],
            ] : null;

            if (statLines) {
                for (let i=0; i<statLines.length; i++) {
                    const [label, val, col] = statLines[i];
                    const ry = 108 + i * 42;
                    // Row bg
                    ctx.save();
                    const rbg = ctx.createLinearGradient(16,ry-6,TABLE_WIDTH-16,ry-6);
                    rbg.addColorStop(0,'rgba(0,0,0,0)');
                    rbg.addColorStop(0.1,'rgba(15,0,28,0.75)');
                    rbg.addColorStop(0.9,'rgba(8,0,18,0.75)');
                    rbg.addColorStop(1,'rgba(0,0,0,0)');
                    ctx.fillStyle=rbg;
                    ctx.beginPath(); ctx.roundRect(16,ry-8,TABLE_WIDTH-32,34,4); ctx.fill();
                    ctx.strokeStyle=`${col}22`; ctx.lineWidth=0.6;
                    ctx.beginPath(); ctx.roundRect(16,ry-8,TABLE_WIDTH-32,34,4); ctx.stroke();
                    ctx.restore();
                    // Label
                    ctx.save(); ctx.textAlign='left'; ctx.textBaseline='middle';
                    ctx.font="11px 'Share Tech Mono', monospace";
                    ctx.fillStyle='rgba(160,140,180,0.75)';
                    ctx.fillText(label.toUpperCase(), 32, ry+9);
                    ctx.restore();
                    // Value
                    ctx.save(); ctx.textAlign='right'; ctx.textBaseline='middle';
                    ctx.font="bold 14px 'Orbitron', monospace";
                    ctx.shadowColor=col; ctx.shadowBlur=10;
                    ctx.fillStyle=col;
                    ctx.fillText(val.toString(), TABLE_WIDTH-32, ry+9);
                    ctx.restore();
                    // Separator dot-line
                    if (i < statLines.length-1) {
                        ctx.strokeStyle='rgba(60,0,80,0.3)'; ctx.lineWidth=0.5;
                        ctx.setLineDash([2,4]);
                        ctx.beginPath(); ctx.moveTo(30,ry+26); ctx.lineTo(TABLE_WIDTH-30,ry+26); ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            } else {
                ctx.save(); ctx.textAlign='center';
                ctx.font="13px 'Share Tech Mono', monospace";
                ctx.fillStyle='rgba(80,60,100,0.6)';
                ctx.fillText('NO STATS YET', OX, 200);
                ctx.restore();
            }

            drawSciFiBtn(OX-55, TABLE_HEIGHT-70, 110, 38, 'BACK', '#ff8800', '#ff8800');
        }
    }

    // === DRAWING ===
    // === ENHANCED VISUAL RENDERING SYSTEM ===

    // =====================================================
    // === DEEP SPACE PLAYFIELD ANIMATION SYSTEM ===
    // =====================================================
    const pf = (() => {
        // Shooting stars
        const shootingStars = [];
        function spawnShootingStar() {
            const isMag = Math.random() < 0.45;
            return {
                x: Math.random() * TABLE_WIDTH * 1.1 - TABLE_WIDTH * 0.05,
                y: Math.random() * TABLE_HEIGHT * 0.35,
                vx: 1.2 + Math.random() * 2.8,
                vy: 0.6 + Math.random() * 1.8,
                len: 28 + Math.random() * 55,
                life: 1,
                decay: 0.010 + Math.random() * 0.016,
                color: isMag ? [255,0,200] : (Math.random() < 0.5 ? [64,224,255] : [180,80,255]),
            };
        }

        // Rising energy particles (from bottom drain area)
        const energyParticles = [];
        function spawnEnergyParticle() {
            const isMag = Math.random() < 0.5;
            return {
                x: TABLE_WIDTH * 0.15 + Math.random() * TABLE_WIDTH * 0.7,
                y: TABLE_HEIGHT - 40 + Math.random() * 30,
                vy: -(0.25 + Math.random() * 0.65),
                vx: (Math.random() - 0.5) * 0.35,
                life: 1,
                decay: 0.004 + Math.random() * 0.007,
                size: 1 + Math.random() * 1.8,
                color: isMag ? [255,0,200] : [64,224,255],
            };
        }

        // Twinkling CSS-style stars (static positions, drawn each frame with sin brightness)
        const staticStars = Array.from({length: 70}, () => ({
            x: Math.random() * TABLE_WIDTH,
            y: Math.random() * TABLE_HEIGHT,
            size: Math.random() < 0.15 ? 1.5 : 0.8,
            phase: Math.random() * Math.PI * 2,
            speed: 0.02 + Math.random() * 0.04,
            minOp: 0.08 + Math.random() * 0.22,
            isMag: Math.random() < 0.28,
        }));

        let orbitalAngle = 0;

        // Table 1 main bumper positions (computed from constants)
        // CENTER_X=180, bumperY=160
        const BUMPER_POS = [
            { x: 135, y: 115, r: 24, col: '255,0,200'  },
            { x: 225, y: 115, r: 24, col: '64,224,255' },
            { x: 135, y: 253, r: 24, col: '64,224,255' },
            { x: 225, y: 253, r: 24, col: '255,0,200'  },
            { x: 30,  y: 250, r: 25, col: '255,0,200'  },
            { x: 342, y: 250, r: 25, col: '64,224,255' },
        ];

        return {
            shootingStars, energyParticles, staticStars,
            spawnShootingStar, spawnEnergyParticle,
            BUMPER_POS,
            getOrbitalAngle: () => orbitalAngle,
            setOrbitalAngle: (v) => { orbitalAngle = v; },
        };
    })();

    function drawAnimatedGrid() {
        const time = performance.now();
        const t = time * 0.001;

        // ── 1. DEEP DARK BACKGROUND ──────────────────────────────────
        const bg = ctx.createRadialGradient(TABLE_WIDTH/2, 0, 0, TABLE_WIDTH/2, TABLE_HEIGHT*0.4, TABLE_WIDTH);
        bg.addColorStop(0, 'rgba(15,0,25,0.92)');
        bg.addColorStop(0.5, 'rgba(5,0,15,0.82)');
        bg.addColorStop(1, 'rgba(0,0,8,0.95)');
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

        // ── 2. NEBULA CLOUDS ─────────────────────────────────────────
        const nb1 = ctx.createRadialGradient(
            TABLE_WIDTH * 0.38 + Math.sin(t * 0.18) * 18, TABLE_HEIGHT * 0.32 + Math.cos(t * 0.12) * 12, 0,
            TABLE_WIDTH * 0.38, TABLE_HEIGHT * 0.32, TABLE_WIDTH * 0.85
        );
        nb1.addColorStop(0, 'rgba(255,0,180,0.085)');
        nb1.addColorStop(0.5, 'rgba(255,0,180,0.02)');
        nb1.addColorStop(1, 'transparent');
        ctx.fillStyle = nb1;
        ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

        const nb2 = ctx.createRadialGradient(
            TABLE_WIDTH * 0.68 + Math.cos(t * 0.14) * 22, TABLE_HEIGHT * 0.65 + Math.sin(t * 0.10) * 16, 0,
            TABLE_WIDTH * 0.68, TABLE_HEIGHT * 0.65, TABLE_WIDTH * 0.9
        );
        nb2.addColorStop(0, 'rgba(0,80,200,0.075)');
        nb2.addColorStop(0.5, 'rgba(0,80,200,0.018)');
        nb2.addColorStop(1, 'transparent');
        ctx.fillStyle = nb2;
        ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

        const nb3 = ctx.createRadialGradient(
            TABLE_WIDTH * 0.28 + Math.sin(t * 0.22) * 16, TABLE_HEIGHT * 0.78, 0,
            TABLE_WIDTH * 0.28, TABLE_HEIGHT * 0.78, TABLE_WIDTH * 0.6
        );
        nb3.addColorStop(0, 'rgba(180,0,255,0.055)');
        nb3.addColorStop(1, 'transparent');
        ctx.fillStyle = nb3;
        ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

        // ── 3. WARP TUNNEL RINGS ─────────────────────────────────────
        const cx = TABLE_WIDTH / 2, cy = TABLE_HEIGHT * 0.32;
        ctx.save();
        for (let ring = 0; ring < 8; ring++) {
            const rt = (time * 0.0003 + ring * 0.15) % 1;
            const eased = rt * rt;
            const rr = eased * TABLE_WIDTH * 0.88;
            const alpha = (1 - eased) * 0.11;
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.ellipse(cx, cy, rr, rr * 0.52, 0, 0, Math.PI * 2);
            const col = ring % 2 === 0 ? '255,0,200' : '64,224,255';
            ctx.strokeStyle = `rgba(${col},1)`;
            ctx.lineWidth = 0.8;
            ctx.stroke();
        }
        ctx.restore();

        // ── 4. GALAXY SMEAR ──────────────────────────────────────────
        ctx.save();
        ctx.globalAlpha = 0.038;
        const gx = ctx.createRadialGradient(TABLE_WIDTH/2, TABLE_HEIGHT*0.43, 0, TABLE_WIDTH/2, TABLE_HEIGHT*0.43, 130);
        gx.addColorStop(0, 'rgba(255,0,180,0.55)');
        gx.addColorStop(0.5, 'rgba(100,0,200,0.32)');
        gx.addColorStop(1, 'rgba(0,0,60,0)');
        ctx.fillStyle = gx;
        ctx.save();
        ctx.translate(TABLE_WIDTH/2, TABLE_HEIGHT*0.43);
        ctx.rotate(Math.sin(time * 0.0001) * 0.08);
        ctx.scale(1, 0.42);
        ctx.beginPath();
        ctx.arc(0, 0, 130, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        ctx.restore();

        // ── 5. TWINKLING STATIC STARS ────────────────────────────────
        for (const s of pf.staticStars) {
            const op = s.minOp + (1 - s.minOp) * 0.5 * (1 + Math.sin(t * s.speed * 6.28 + s.phase));
            ctx.fillStyle = s.isMag
                ? `rgba(255,140,240,${op})`
                : `rgba(255,248,240,${op})`;
            ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.size, s.size);
        }

        // ── 6. SHOOTING STARS ────────────────────────────────────────
        if (Math.random() < 0.018) pf.shootingStars.push(pf.spawnShootingStar());
        ctx.save();
        for (let i = pf.shootingStars.length - 1; i >= 0; i--) {
            const s = pf.shootingStars[i];
            s.x += s.vx; s.y += s.vy; s.life -= s.decay;
            if (s.life <= 0 || s.y > TABLE_HEIGHT) { pf.shootingStars.splice(i, 1); continue; }
            const spd = Math.hypot(s.vx, s.vy);
            const grad = ctx.createLinearGradient(
                s.x, s.y,
                s.x - s.vx * (s.len / spd), s.y - s.vy * (s.len / spd)
            );
            const [r,g,b] = s.color;
            grad.addColorStop(0, `rgba(${r},${g},${b},${s.life * 0.88})`);
            grad.addColorStop(0.3, `rgba(${r},${g},${b},${s.life * 0.38})`);
            grad.addColorStop(1, `rgba(${r},${g},${b},0)`);
            ctx.beginPath();
            ctx.moveTo(s.x, s.y);
            ctx.lineTo(s.x - s.vx * (s.len / spd), s.y - s.vy * (s.len / spd));
            ctx.strokeStyle = grad;
            ctx.lineWidth = 1.5 * s.life;
            ctx.stroke();
            // Bright tip
            ctx.beginPath();
            ctx.arc(s.x, s.y, 1.4 * s.life, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255,255,255,${s.life * 0.82})`;
            ctx.fill();
        }
        ctx.restore();

        // ── 7. ENERGY PARTICLES (rising from drain) ──────────────────
        if (Math.random() < 0.10) pf.energyParticles.push(pf.spawnEnergyParticle());
        ctx.save();
        for (let i = pf.energyParticles.length - 1; i >= 0; i--) {
            const p = pf.energyParticles[i];
            p.x += p.vx; p.y += p.vy; p.life -= p.decay;
            if (p.life <= 0 || p.y < 0) { pf.energyParticles.splice(i, 1); continue; }
            const [r,g,b] = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${r},${g},${b},${p.life * 0.58})`;
            ctx.shadowBlur = 6;
            ctx.shadowColor = `rgba(${r},${g},${b},0.85)`;
            ctx.fill();
        }
        ctx.shadowBlur = 0;
        ctx.restore();

        // ── 8. ORBITAL TRACES AROUND POP BUMPERS ─────────────────────
        const oa = time * 0.0008;
        pf.setOrbitalAngle(oa);
        ctx.save();
        ctx.globalAlpha = 0.18;
        for (let bi = 0; bi < pf.BUMPER_POS.length; bi++) {
            const b = pf.BUMPER_POS[bi];
            const baseAngle = oa + bi * 1.1;
            const orbitR = b.r + 9;
            // Ring
            ctx.beginPath();
            ctx.ellipse(b.x, b.y, orbitR, orbitR, 0, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(${b.col},0.5)`;
            ctx.lineWidth = 0.7;
            ctx.stroke();
            // Orbiting dot
            const dotX = b.x + Math.cos(baseAngle) * orbitR;
            const dotY = b.y + Math.sin(baseAngle) * orbitR;
            ctx.beginPath();
            ctx.arc(dotX, dotY, 2.8, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${b.col},0.92)`;
            ctx.globalAlpha = 0.62;
            ctx.shadowBlur = 7;
            ctx.shadowColor = `rgba(${b.col},1)`;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.18;
        }
        ctx.restore();

        // ── 9. WARP GRID LINES ────────────────────────────────────────
        const gridSize = 25;
        for (let x = 0; x <= TABLE_WIDTH; x += gridSize) {
            const phase = (x / TABLE_WIDTH + t * 0.3) % 1;
            const brightness = 0.022 + 0.014 * Math.sin(phase * Math.PI * 2);
            ctx.strokeStyle = `rgba(255,0,200,${brightness})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, TABLE_HEIGHT);
            ctx.stroke();
        }
        const gridOff = (t * 18) % gridSize;
        for (let y = 0; y <= TABLE_HEIGHT; y += gridSize) {
            const ay = (y + gridOff) % TABLE_HEIGHT;
            const gi = 0.022 + 0.028 * Math.pow(Math.sin((1 - ay / TABLE_HEIGHT) * Math.PI), 2);
            ctx.strokeStyle = `rgba(64,224,255,${gi})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(TABLE_WIDTH, y);
            ctx.stroke();
        }

        // ── 9b. HEX GRID OVERLAY (subtle, drifts slowly) ────────────────
        {
            const hexSize = 18;
            const hexW = hexSize * Math.sqrt(3);
            const hexH = hexSize * 2;
            const hexOffX = (t * 4) % hexW;
            const hexOffY = (t * 2) % (hexH * 0.75);
            ctx.save();
            ctx.globalAlpha = 0.045 + 0.018 * Math.sin(t * 0.8);
            ctx.strokeStyle = '#ff00cc';
            ctx.lineWidth = 0.6;
            for (let row = -1; row < TABLE_HEIGHT / (hexH * 0.75) + 2; row++) {
                for (let col = -1; col < TABLE_WIDTH / hexW + 2; col++) {
                    const ox = col * hexW + (row % 2) * hexW * 0.5 + hexOffX;
                    const oy = row * hexH * 0.75 + hexOffY;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = (i * Math.PI) / 3 - Math.PI / 6;
                        const px = ox + hexSize * Math.cos(a);
                        const py = oy + hexSize * Math.sin(a);
                        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        // ── 9c. PERSPECTIVE VANISHING-POINT GRID (radiates from bottom centre) ─
        {
            const vpx = TABLE_WIDTH / 2, vpy = TABLE_HEIGHT + 40;
            const numRays = 14;
            ctx.save();
            for (let i = 0; i <= numRays; i++) {
                const frac = i / numRays;
                const ex = frac * TABLE_WIDTH;
                const ey = TABLE_HEIGHT;
                const pulse = 0.018 + 0.012 * Math.sin(t * 1.6 + frac * Math.PI * 2);
                const grad = ctx.createLinearGradient(vpx, vpy, ex, ey);
                grad.addColorStop(0, 'transparent');
                grad.addColorStop(0.45, `rgba(64,224,255,${pulse * 0.5})`);
                grad.addColorStop(0.75, `rgba(64,224,255,${pulse})`);
                grad.addColorStop(1, 'transparent');
                ctx.strokeStyle = grad;
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(vpx, vpy);
                ctx.lineTo(ex, ey);
                ctx.stroke();
            }
            // Horizontal cross-lines for the perspective grid
            for (let i = 0; i < 6; i++) {
                const fy = TABLE_HEIGHT * (0.5 + i * 0.1);
                const spread = (TABLE_HEIGHT - fy) / TABLE_HEIGHT;
                const lx = TABLE_WIDTH * 0.5 - spread * TABLE_WIDTH * 0.52;
                const rx = TABLE_WIDTH * 0.5 + spread * TABLE_WIDTH * 0.52;
                const alpha = 0.012 + 0.012 * Math.sin(t * 2 + i * 0.8);
                ctx.strokeStyle = `rgba(255,0,200,${alpha})`;
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(lx, fy);
                ctx.lineTo(rx, fy);
                ctx.stroke();
            }
            ctx.restore();
        }

        // ── 9d. DATA STREAM COLUMNS (magenta/cyan vertical light shafts) ──────
        {
            const streams = [
                { x: TABLE_WIDTH * 0.22, color: '255,0,200',  speed: 1.4, offset: 0.0  },
                { x: TABLE_WIDTH * 0.38, color: '64,224,255', speed: 1.9, offset: 0.4  },
                { x: TABLE_WIDTH * 0.62, color: '255,0,200',  speed: 1.6, offset: 0.8  },
                { x: TABLE_WIDTH * 0.78, color: '64,224,255', speed: 1.2, offset: 1.3  },
            ];
            ctx.save();
            for (const s of streams) {
                const phase = (t * s.speed + s.offset) % 1;
                const headY = phase * TABLE_HEIGHT;
                const tailLen = TABLE_HEIGHT * 0.22;
                const tailY = headY - tailLen;
                const gr = ctx.createLinearGradient(0, tailY, 0, headY);
                gr.addColorStop(0,   'transparent');
                gr.addColorStop(0.6, `rgba(${s.color},0.04)`);
                gr.addColorStop(1,   `rgba(${s.color},0.13)`);
                ctx.fillStyle = gr;
                ctx.fillRect(s.x - 1, tailY, 2, tailLen);
                // Bright head dot
                ctx.fillStyle = `rgba(${s.color},0.45)`;
                ctx.fillRect(s.x - 1, headY - 2, 2, 4);
            }
            ctx.restore();
        }

        // ── 10. TRAVELLING SCANLINES ──────────────────────────────────
        const scanY1 = TABLE_HEIGHT - (t * 180 % TABLE_HEIGHT);
        const sg1 = ctx.createLinearGradient(0, scanY1 - 3, 0, scanY1 + 3);
        sg1.addColorStop(0, 'transparent');
        sg1.addColorStop(0.5, 'rgba(255,0,200,0.18)');
        sg1.addColorStop(1, 'transparent');
        ctx.fillStyle = sg1;
        ctx.fillRect(0, scanY1 - 3, TABLE_WIDTH, 6);

        const scanY2 = TABLE_HEIGHT - ((t * 180 + TABLE_HEIGHT * 0.5) % TABLE_HEIGHT);
        const sg2 = ctx.createLinearGradient(0, scanY2 - 2, 0, scanY2 + 2);
        sg2.addColorStop(0, 'transparent');
        sg2.addColorStop(0.5, 'rgba(64,224,255,0.13)');
        sg2.addColorStop(1, 'transparent');
        ctx.fillStyle = sg2;
        ctx.fillRect(0, scanY2 - 2, TABLE_WIDTH, 4);
    }



    // Draw a bumper with deep space conic gradient spinning effect
    function drawBumper3D(x, y, radius, color, isActive) {
        const bounceScale = isActive ? 1.18 : 1;
        const r = radius * bounceScale;
        const t = frame * 0.04; // rotation time

        ctx.save();

        // Outer glow halo (pulsing)
        const pulseIntensity = isActive ? 1.0 : (0.4 + 0.3 * Math.sin(t * 2));
        const glowRadius = r * 2.2;
        const glow = ctx.createRadialGradient(x, y, r * 0.4, x, y, glowRadius);
        glow.addColorStop(0, hexWithAlpha(color, Math.floor(pulseIntensity * 80)));
        glow.addColorStop(0.5, hexWithAlpha(color, Math.floor(pulseIntensity * 25)));
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(x, y, glowRadius, 0, Math.PI * 2);
        ctx.fill();

        // Spinning smooth gradient ring — drawn as a series of thin arc strokes
        // with interpolated hue so it looks like a real conic gradient
        ctx.save();
        ctx.translate(x, y);
        const spinSpeed = isActive ? t * 3 : t;
        const ringSteps = 48;
        const stepAngle = (Math.PI * 2) / ringSteps;
        // Colour stops around the ring: magenta → cyan → violet → magenta
        const hueStops = [
            [255,  0, 204],   // #ff00cc magenta   0°
            [128, 40, 255],   // #8028ff violet    90°
            [ 64,224, 255],   // #40e0ff cyan      180°
            [255, 80, 232],   // #ff50e8 pink      270°
            [255,  0, 204],   // back to magenta   360°
        ];
        function lerpColor(stops, frac) {
            frac = ((frac % 1) + 1) % 1;
            const pos = frac * (stops.length - 1);
            const lo = Math.floor(pos), hi = Math.ceil(pos);
            const f = pos - lo;
            const a = stops[lo], b = stops[hi];
            return [a[0]+(b[0]-a[0])*f, a[1]+(b[1]-a[1])*f, a[2]+(b[2]-a[2])*f];
        }
        ctx.lineWidth = r * 0.3; // ring thickness as fraction of radius
        const ringR = r * 0.86;  // centre of the ring band
        for (let s = 0; s < ringSteps; s++) {
            const angle0 = spinSpeed + s * stepAngle;
            const angle1 = angle0 + stepAngle * 1.05; // tiny overlap prevents gaps
            const frac = s / ringSteps;
            const [cr, cg, cb] = lerpColor(hueStops, frac);
            const alpha = isActive ? 0.95 : 0.78;
            ctx.strokeStyle = `rgba(${cr|0},${cg|0},${cb|0},${alpha})`;
            ctx.shadowColor  = `rgba(${cr|0},${cg|0},${cb|0},0.6)`;
            ctx.shadowBlur   = isActive ? 8 : 4;
            ctx.beginPath();
            ctx.arc(0, 0, ringR, angle0, angle1);
            ctx.stroke();
        }
        ctx.shadowBlur = 0;
        ctx.restore();

        // Inner body with deep radial gradient (covers spinning conic, leaving only a ring)
        const innerR = r * 0.72;
        ctx.save();
        const bodyGrad = ctx.createRadialGradient(x - r * 0.28, y - r * 0.28, 0, x, y, innerR);
        bodyGrad.addColorStop(0, '#fff0f8');
        bodyGrad.addColorStop(0.25, hexWithAlpha(color, 0xa8));
        bodyGrad.addColorStop(0.6, darkenColor(color, 40) + 'cc');
        bodyGrad.addColorStop(1, '#0a0014cc');
        ctx.fillStyle = bodyGrad;
        ctx.shadowColor = isActive ? '#ffffff' : color;
        ctx.shadowBlur = isActive ? 20 : 8;
        ctx.beginPath();
        ctx.arc(x, y, innerR, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Inner depth shadow
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,30,0.45)';
        ctx.beginPath();
        ctx.arc(x, y, innerR * 0.65, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Top highlight
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.55)';
        ctx.beginPath();
        ctx.ellipse(x - r * 0.22, y - r * 0.3, r * 0.28, r * 0.14, -0.5, 0, Math.PI * 2);
        ctx.fill();
        // Specular
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.arc(x - r * 0.28, y - r * 0.35, r * 0.1, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Inner inset ring glow when active
        if (isActive) {
            ctx.save();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1.5;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.arc(x, y, r - 1, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        ctx.restore();
    }

    // Helper: hex color with alpha byte as hex string (e.g. 0x80 = 50%)
    function hexWithAlpha(hex, alpha) {
        if (typeof alpha === 'number' && alpha <= 1) alpha = Math.round(alpha * 255);
        return hex + (alpha < 16 ? '0' : '') + Math.min(255, Math.max(0, Math.round(alpha))).toString(16);
    }

    // Draw smooth walls instead of circle chains
    function drawSmoothWalls() {
        const DOME_BOTH = DOME_RADIUS + WALL_RADIUS;
        const t = performance.now() * 0.001;

        // Deep-space neon wall helper - 4 layer: deep shadow → outer glow → core gradient → shimmer pass
        function drawWallPath(path, coreColor, glowColor, lineWidth, shimmerPhase) {
            // 1. Dark drop shadow
            ctx.save();
            ctx.strokeStyle = 'rgba(0,0,0,0.55)';
            ctx.lineWidth = lineWidth + 5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.translate(2, 3);
            ctx.stroke(path);
            ctx.restore();

            // 2. Wide outer neon glow (two passes for richness)
            ctx.save();
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 28;
            ctx.strokeStyle = glowColor;
            ctx.lineWidth = lineWidth + 1;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = 0.38;
            ctx.stroke(path);
            ctx.shadowBlur = 14;
            ctx.globalAlpha = 0.55;
            ctx.stroke(path);
            ctx.restore();

            // 3. Core body - bright centre, dark edges (mimics the CSS linear-gradient look)
            ctx.save();
            ctx.strokeStyle = coreColor;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 10;
            ctx.stroke(path);
            ctx.restore();

            // 4. Bright spine highlight
            ctx.save();
            ctx.strokeStyle = 'rgba(200,248,255,0.88)';
            ctx.lineWidth = lineWidth * 0.22;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.translate(-0.8, -0.8);
            ctx.stroke(path);
            ctx.restore();

            // 5. Travelling shimmer pulse (like CSS ::after sweep)
            const shimmer = 0.5 + 0.5 * Math.sin(t * 2.8 + shimmerPhase);
            ctx.save();
            ctx.strokeStyle = `rgba(255,255,255,${shimmer * 0.55})`;
            ctx.lineWidth = lineWidth * 0.35;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = shimmer * 0.7;
            ctx.stroke(path);
            ctx.restore();
        }

        // ── SIDE WALLS (cyan, thick) ───────────────────────────────────────
        let path = new Path2D();
        path.moveTo(CENTER_X - DOME_BOTH, TABLE_HEIGHT);
        path.lineTo(CENTER_X - DOME_BOTH, DOME_BOTH);
        drawWallPath(path, '#a0f4ff', '#40e0ff', 10, 0.0);

        path = new Path2D();
        path.moveTo(CENTER_X + DOME_BOTH, TABLE_HEIGHT);
        path.lineTo(CENTER_X + DOME_BOTH, DOME_BOTH);
        drawWallPath(path, '#a0f4ff', '#40e0ff', 10, 1.2);

        // ── DOME ARC (cyan) ────────────────────────────────────────────────
        for (const dir of [-1, 1]) {
            path = new Path2D();
            for (let i = 0; i <= 55; i++) {
                const x = CENTER_X + dir * DOME_BOTH * Math.cos(i / 35);
                const y = DOME_BOTH - DOME_BOTH * Math.sin(i / 35);
                if (i === 0) path.moveTo(x, y);
                else path.lineTo(x, y);
            }
            drawWallPath(path, '#a0f4ff', '#40e0ff', 10, dir * 0.7);
        }

        // ── SHOOTER LANE WALL (cyan, thinner) ─────────────────────────────
        const shooterWallX = CENTER_X + DOME_RADIUS - BALL_RADIUS * 2 - WALL_RADIUS;
        path = new Path2D();
        path.moveTo(shooterWallX, TABLE_HEIGHT);
        path.lineTo(shooterWallX, TABLE_HEIGHT - 65 * 7);
        drawWallPath(path, '#80eeff', '#40e0ff', 8, 2.1);

        // ── OUTLANE & DIAGONAL GUIDES (magenta → cyan gradient look) ──────
        for (let side = 0; side < 2; side++) {
            const dir = side * 2 - 1;

            // Vertical outlane guide - magenta
            path = new Path2D();
            path.moveTo(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55), FLIPPER_Y - 50);
            path.lineTo(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55), FLIPPER_Y - 50 - 11 * 7);
            drawWallPath(path, '#ff80e8', '#ff00cc', 8, side * 1.6);

            // Diagonal outlane kicker guide - magenta/purple
            path = new Path2D();
            path.moveTo(FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 55), FLIPPER_Y - 50);
            path.lineTo(FLIPPER_CENTER + dir * FLIPPER_SPREAD, FLIPPER_Y - 50 + 18 * 3);
            drawWallPath(path, '#e080ff', '#8040ff', 8, side * 1.6 + 0.8);

            // Slingshot outer vertical wall - cyan (matches slingshot colour)
            const slingOuterX = FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 25);
            const slingTopY = FLIPPER_Y - 120;
            const slingBottomY = FLIPPER_Y - 70;
            path = new Path2D();
            path.moveTo(slingOuterX, slingTopY);
            path.lineTo(slingOuterX, slingBottomY);
            drawWallPath(path, '#a0f4ff', '#40e0ff', 6, side * 1.1 + 0.5);
        }
    }

    // Draw slingshot triangles – solid filled shape drawn OVER walls, flipper-style glow
    function drawSlingshots() {
        const t = performance.now() * 0.001;
        for (let side = 0; side < 2; side++) {
            const dir = side * 2 - 1;
            const slingInnerX = FLIPPER_CENTER + dir * FLIPPER_SPREAD;
            const slingOuterX = FLIPPER_CENTER + dir * (FLIPPER_SPREAD + 25);
            const slingTopY    = FLIPPER_Y - 120;
            const slingBottomY = FLIPPER_Y - 70;
            const slingBottomInnerY = slingBottomY + 25;

            // Check if bouncing
            let isBouncing = false;
            for (const obj of objects) {
                if (obj.isSlingshot && obj.bounce > 0) {
                    const dx = Math.abs(obj.x - (slingOuterX + slingInnerX) / 2);
                    if (dx < 30) { isBouncing = true; break; }
                }
            }

            const spark = isBouncing ? 1.0 : (0.5 + 0.5 * Math.sin(t * 3.14 + side * Math.PI));

            // Build triangle path
            const triPath = new Path2D();
            triPath.moveTo(slingOuterX, slingTopY);
            triPath.lineTo(slingInnerX, slingBottomInnerY);
            triPath.lineTo(slingOuterX, slingBottomY);
            triPath.closePath();

            // Hypotenuse line path (the active angled edge)
            const hypPath = new Path2D();
            hypPath.moveTo(slingOuterX, slingTopY);
            hypPath.lineTo(slingInnerX, slingBottomInnerY);

            // ── 1. Wide outer neon glow ───────────────────────────────────
            ctx.save();
            ctx.shadowColor = isBouncing ? '#ffffff' : '#ff00cc';
            ctx.shadowBlur  = isBouncing ? 40 : (14 + 16 * spark);
            ctx.fillStyle   = isBouncing ? 'rgba(255,255,255,0.2)' : `rgba(255,0,200,${0.12 + 0.1*spark})`;
            ctx.fill(triPath);
            ctx.restore();

            // ── 2. Solid body fill – magenta top-to-bottom gradient ───────
            ctx.save();
            const bodyGrad = ctx.createLinearGradient(slingOuterX, slingTopY, slingInnerX, slingBottomInnerY);
            if (isBouncing) {
                bodyGrad.addColorStop(0, 'rgba(255,255,255,0.98)');
                bodyGrad.addColorStop(1, 'rgba(220,180,255,0.85)');
            } else {
                bodyGrad.addColorStop(0,   `rgba(200,80,255,${0.75 + 0.2*spark})`);
                bodyGrad.addColorStop(0.45,`rgba(255,0,200,${0.85 + 0.12*spark})`);
                bodyGrad.addColorStop(1,   `rgba(160,40,255,${0.7 + 0.2*spark})`);
            }
            ctx.fillStyle = bodyGrad;
            ctx.shadowColor = isBouncing ? '#ffffff' : '#ff00cc';
            ctx.shadowBlur  = isBouncing ? 20 : 8;
            ctx.fill(triPath);
            ctx.restore();

            // ── 3. Bright spine highlight on top face ─────────────────────
            ctx.save();
            ctx.strokeStyle = isBouncing ? 'rgba(255,255,255,0.9)' : `rgba(255,160,255,${0.6 + 0.35*spark})`;
            ctx.lineWidth = isBouncing ? 2.5 : 1.8;
            ctx.lineCap = 'round';
            ctx.shadowColor = isBouncing ? '#ffffff' : '#ff00cc';
            ctx.shadowBlur  = isBouncing ? 14 : 8;
            ctx.stroke(hypPath);
            ctx.restore();

            // ── 4. Shimmer sweep along hypotenuse ─────────────────────────
            const shimmer = isBouncing ? 1.0 : (0.4 + 0.6 * Math.abs(Math.sin(t * 1.8 + side * 1.5)));
            ctx.save();
            ctx.strokeStyle = `rgba(255,255,255,${shimmer * (isBouncing ? 0.9 : 0.45)})`;
            ctx.lineWidth = 0.9;
            ctx.lineCap = 'round';
            ctx.translate(-0.5, -0.5);
            ctx.stroke(hypPath);
            ctx.restore();
        }
    }

    // Draw flippers with deep-space CSS-style: gradient body + outer glow + shimmer sweep
    function drawFlippers() {
        const t = performance.now() * 0.001;
        for (let side = 0; side < 2; side++) {
            const isLeft = side === 0;
            const isPressed = isLeft ? keys.z : keys.x;

            // Collect segments
            const segments = [];
            for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
                const objIndex = isLeft ? (1 + i) : (1 + FLIPPER_SEGMENTS + i);
                const obj = objects[objIndex];
                if (obj) segments.push({ x: obj.x, y: obj.y, radius: obj.radius });
            }
            if (segments.length < 2) continue;

            const lastSeg  = segments[segments.length - 1];
            const firstSeg = segments[0];
            const midIdx   = Math.floor(segments.length / 2);
            const midX = segments[midIdx].x;
            const midY = segments[midIdx].y;
            const halfH = firstSeg.radius * 0.85;

            // ── Build the flipper outline path ───────────────────────────
            const flipPath = new Path2D();
            for (let i = 0; i < segments.length; i++) {
                const s = segments[i];
                if (i === 0) flipPath.moveTo(s.x, s.y - s.radius * 0.85);
                else         flipPath.lineTo(s.x, s.y - s.radius * 0.85);
            }
            const tipCCW = !isLeft;
            flipPath.arc(lastSeg.x, lastSeg.y, lastSeg.radius * 0.85, -Math.PI/2, Math.PI/2, tipCCW);
            for (let i = segments.length - 1; i >= 0; i--) {
                flipPath.lineTo(segments[i].x, segments[i].y + segments[i].radius * 0.85);
            }
            const baseCCW = !isLeft;
            flipPath.arc(firstSeg.x, firstSeg.y, firstSeg.radius * 0.85, Math.PI/2, -Math.PI/2, baseCCW);
            flipPath.closePath();

            // ── 1. WIDE OUTER NEON GLOW ──────────────────────────────────
            ctx.save();
            ctx.shadowColor = isPressed ? '#ffffff' : '#ff00cc';
            ctx.shadowBlur  = isPressed ? 45 : 28;
            ctx.fillStyle   = isPressed ? 'rgba(255,255,255,0.25)' : 'rgba(255,0,200,0.18)';
            ctx.fill(flipPath);
            ctx.shadowBlur  = isPressed ? 22 : 14;
            ctx.fillStyle   = isPressed ? 'rgba(255,255,255,0.35)' : 'rgba(255,0,200,0.28)';
            ctx.fill(flipPath);
            ctx.restore();

            // ── 2. BODY – top-to-bottom gradient (magenta, CSS flipper::before style) ──
            ctx.save();
            const bodyGrad = ctx.createLinearGradient(midX, midY - halfH, midX, midY + halfH);
            if (isPressed) {
                bodyGrad.addColorStop(0,   'rgba(255,220,255,0.98)');
                bodyGrad.addColorStop(0.25,'rgba(255,140,255,0.95)');
                bodyGrad.addColorStop(0.65,'rgba(200,0,160,0.95)');
                bodyGrad.addColorStop(1,   'rgba(60,0,40,1)');
            } else {
                bodyGrad.addColorStop(0,   'rgba(255,200,248,0.95)');
                bodyGrad.addColorStop(0.25,'rgba(255,60,200,0.88)');
                bodyGrad.addColorStop(0.60,'rgba(160,0,120,0.92)');
                bodyGrad.addColorStop(1,   'rgba(40,0,30,1)');
            }
            ctx.fillStyle = bodyGrad;
            ctx.shadowColor = isPressed ? '#ffffff' : '#ff00cc';
            ctx.shadowBlur  = isPressed ? 18 : 10;
            ctx.fill(flipPath);
            ctx.restore();

            // ── 3. BRIGHT TOP-SPINE HIGHLIGHT ────────────────────────────
            ctx.save();
            const spineGrad = ctx.createLinearGradient(firstSeg.x, 0, lastSeg.x, 0);
            spineGrad.addColorStop(0,   'rgba(255,255,255,0.0)');
            spineGrad.addColorStop(0.25,'rgba(255,255,255,0.55)');
            spineGrad.addColorStop(0.5, 'rgba(255,255,255,0.85)');
            spineGrad.addColorStop(0.75,'rgba(255,255,255,0.55)');
            spineGrad.addColorStop(1,   'rgba(255,255,255,0.0)');
            // Clip to thin top strip
            const spinePath = new Path2D();
            for (let i = 0; i < segments.length; i++) {
                const s = segments[i];
                if (i === 0) spinePath.moveTo(s.x, s.y - s.radius * 0.85);
                else         spinePath.lineTo(s.x, s.y - s.radius * 0.85);
            }
            spinePath.arc(lastSeg.x, lastSeg.y, lastSeg.radius * 0.85, -Math.PI/2, 0, tipCCW);
            for (let i = segments.length - 1; i >= 0; i--) {
                spinePath.lineTo(segments[i].x, segments[i].y - segments[i].radius * 0.35);
            }
            spinePath.arc(firstSeg.x, firstSeg.y, firstSeg.radius * 0.35, -Math.PI/2, Math.PI/2, baseCCW);
            spinePath.closePath();
            ctx.fillStyle = spineGrad;
            ctx.fill(spinePath);
            ctx.restore();

            // ── 4. SHIMMER SWEEP PASS (CSS flipper::after style) ─────────
            //    A bright stripe travels left→right (left flipper) or R→L (right)
            const shimmerPos = isLeft
                ? ((t * 0.55 + side * 0.4) % 1.0)          // left: travels L→R
                : (1.0 - ((t * 0.55 + side * 0.4) % 1.0)); // right: travels R→L
            const fx0 = firstSeg.x;
            const fx1 = lastSeg.x;
            const fxSpan = Math.abs(fx1 - fx0);
            const shimX = Math.min(fx0, fx1) + shimmerPos * fxSpan;
            const shimW = fxSpan * 0.32;
            ctx.save();
            ctx.clip(flipPath);  // keep shimmer inside flipper shape
            const shimGrad = ctx.createLinearGradient(shimX - shimW/2, 0, shimX + shimW/2, 0);
            shimGrad.addColorStop(0,   'transparent');
            shimGrad.addColorStop(0.4, `rgba(255,255,255,${isPressed ? 0.55 : 0.35})`);
            shimGrad.addColorStop(0.6, `rgba(255,255,255,${isPressed ? 0.55 : 0.35})`);
            shimGrad.addColorStop(1,   'transparent');
            ctx.fillStyle = shimGrad;
            ctx.fillRect(shimX - shimW/2, midY - halfH * 1.2, shimW, halfH * 2.4);
            ctx.restore();

            // ── 5. EDGE STROKE ────────────────────────────────────────────
            ctx.save();
            ctx.strokeStyle = isPressed ? 'rgba(255,255,255,0.7)' : 'rgba(255,160,240,0.55)';
            ctx.lineWidth = 1.2;
            ctx.stroke(flipPath);
            ctx.restore();
        }
    }

    // Draw the ball with enhanced glow and trail
    function drawBall3D(x, y, radius, vx, vy) {
        // Motion trail
        const speed = Math.sqrt(vx * vx + vy * vy);
        const trailLength = Math.min(5, Math.floor(speed * 3));

        for (let i = trailLength; i > 0; i--) {
            const alpha = 0.1 * (1 - i / trailLength);
            const trailX = x - vx * i * 2;
            const trailY = y - vy * i * 2;
            const trailRadius = radius * (1 - i * 0.1);

            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.beginPath();
            ctx.arc(trailX, trailY, trailRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Outer glow
        ctx.save();
        const glow = ctx.createRadialGradient(x, y, radius * 0.5, x, y, radius * 2.5);
        glow.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
        glow.addColorStop(0.5, 'rgba(200, 200, 255, 0.1)');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(x, y, radius * 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(x + 2, y + 3, radius * 0.8, radius * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Main ball body
        const ballGrad = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, 0, x, y, radius);
        ballGrad.addColorStop(0, '#ffffff');
        ballGrad.addColorStop(0.3, '#e8e8ff');
        ballGrad.addColorStop(0.7, '#c0c0d0');
        ballGrad.addColorStop(1, '#808090');

        ctx.fillStyle = ballGrad;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Chrome ring
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(x, y, radius - 1, 0, Math.PI * 2);
        ctx.stroke();

        // Top highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.beginPath();
        ctx.ellipse(x - radius * 0.3, y - radius * 0.35, radius * 0.3, radius * 0.15, -0.5, 0, Math.PI * 2);
        ctx.fill();

        // Specular point
        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
        ctx.beginPath();
        ctx.arc(x - radius * 0.35, y - radius * 0.4, radius * 0.12, 0, Math.PI * 2);
        ctx.fill();
    }



    // Color utility functions
    function lightenColor(hex, percent) {
        const num = parseInt(hex.replace('#', ''), 16);
        const r = Math.min(255, (num >> 16) + percent);
        const g = Math.min(255, ((num >> 8) & 0x00FF) + percent);
        const b = Math.min(255, (num & 0x0000FF) + percent);
        return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
    }

    function darkenColor(hex, percent) {
        const num = parseInt(hex.replace('#', ''), 16);
        const r = Math.max(0, (num >> 16) - percent);
        const g = Math.max(0, ((num >> 8) & 0x00FF) - percent);
        const b = Math.max(0, (num & 0x0000FF) - percent);
        return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
    }

    // Simple circle for small elements
    function drawCircle(x, y, radius, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(x - radius * 0.2, y - radius * 0.2, radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
    }

    // Sci-fi pin with neon glow + rotating shine
    function drawPin3D(x, y, radius, color) {
        const t = performance.now() * 0.001;
        const num = parseInt(color.replace('#',''), 16);
        const cr = (num>>16)&255, cg = (num>>8)&255, cb = num&255;
        const isLit = (cr + cg + cb) > 120; // dim pins skip most FX

        // Wide glow halo (lit only)
        if (isLit) {
            ctx.save();
            ctx.shadowColor = color; ctx.shadowBlur = 18;
            const halo = ctx.createRadialGradient(x, y, radius*0.2, x, y, radius*2.8);
            halo.addColorStop(0, `rgba(${cr},${cg},${cb},0.5)`);
            halo.addColorStop(0.5, `rgba(${cr},${cg},${cb},0.15)`);
            halo.addColorStop(1, 'transparent');
            ctx.fillStyle = halo;
            ctx.beginPath(); ctx.arc(x, y, radius*2.8, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }

        // Outer bezel ring
        ctx.save();
        ctx.strokeStyle = `rgba(${cr},${cg},${cb},${isLit ? 0.9 : 0.3})`;
        ctx.lineWidth = 0.8;
        ctx.shadowColor = color; ctx.shadowBlur = isLit ? 10 : 3;
        ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI*2); ctx.stroke();
        ctx.restore();

        // Body
        ctx.save();
        const body = ctx.createRadialGradient(x - radius*0.3, y - radius*0.3, 0, x, y, radius);
        body.addColorStop(0,   isLit ? 'rgba(255,255,255,0.95)' : 'rgba(80,80,100,0.7)');
        body.addColorStop(0.35,`rgba(${cr},${cg},${cb},${isLit ? 0.9 : 0.3})`);
        body.addColorStop(1,   `rgba(${Math.max(0,cr-80)},${Math.max(0,cg-80)},${Math.max(0,cb-60)},0.95)`);
        ctx.fillStyle = body;
        ctx.shadowColor = color; ctx.shadowBlur = isLit ? 8 : 2;
        ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // Rotating shine (lit only)
        if (isLit && radius >= 4) {
            const shineAngle = (t * 1.8 + x * 0.03 + y * 0.02) % (Math.PI*2);
            const sx = x + Math.cos(shineAngle) * radius * 0.45;
            const sy = y + Math.sin(shineAngle) * radius * 0.45;
            ctx.save();
            ctx.beginPath(); ctx.arc(x, y, radius*0.92, 0, Math.PI*2); ctx.clip();
            const sg = ctx.createRadialGradient(sx, sy, 0, sx, sy, radius*0.65);
            sg.addColorStop(0,   'rgba(255,255,255,0.65)');
            sg.addColorStop(0.6, 'rgba(255,255,255,0.1)');
            sg.addColorStop(1,   'transparent');
            ctx.fillStyle = sg; ctx.fillRect(x-radius, y-radius, radius*2, radius*2);
            ctx.restore();
        }

        // Static top specular
        ctx.fillStyle = `rgba(255,255,255,${isLit ? 0.75 : 0.2})`;
        ctx.beginPath();
        ctx.arc(x - radius*0.28, y - radius*0.28, radius*0.22, 0, Math.PI*2);
        ctx.fill();
    }

    // Draw sci-fi drop target with neon glow + shine animation
    function drawDropTarget3D(x, y, radius, color, isActive) {
        const t = performance.now() * 0.001;

        if (!isActive) {
            // Inactive – dark recessed hex-shaped disc
            ctx.save();
            ctx.fillStyle = 'rgba(10,0,20,0.85)';
            ctx.strokeStyle = 'rgba(80,0,100,0.5)';
            ctx.lineWidth = 1;
            ctx.shadowColor = 'rgba(255,0,200,0.15)';
            ctx.shadowBlur = 4;
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.55, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
            // Cross-hair recess mark
            ctx.strokeStyle = 'rgba(100,0,140,0.4)';
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(x - radius*0.35, y); ctx.lineTo(x + radius*0.35, y);
            ctx.moveTo(x, y - radius*0.35); ctx.lineTo(x, y + radius*0.35);
            ctx.stroke();
            ctx.restore();
            return;
        }

        // Parse colour into rgb for rgba usage
        const num = parseInt(color.replace('#',''), 16);
        const cr = (num>>16)&255, cg = (num>>8)&255, cb = num&255;

        // 1. Wide outer glow halo
        ctx.save();
        ctx.shadowColor = color; ctx.shadowBlur = 22;
        const halo = ctx.createRadialGradient(x, y, radius*0.3, x, y, radius*2.4);
        halo.addColorStop(0, `rgba(${cr},${cg},${cb},0.45)`);
        halo.addColorStop(0.5, `rgba(${cr},${cg},${cb},0.12)`);
        halo.addColorStop(1, 'transparent');
        ctx.fillStyle = halo;
        ctx.beginPath(); ctx.arc(x, y, radius*2.4, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // 2. Outer ring (like a tech bezel)
        ctx.save();
        ctx.shadowColor = color; ctx.shadowBlur = 14;
        ctx.strokeStyle = `rgba(${cr},${cg},${cb},0.9)`;
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.arc(x, y, radius*0.95, 0, Math.PI*2); ctx.stroke();
        // Inner bezel ring
        ctx.strokeStyle = `rgba(${cr},${cg},${cb},0.4)`;
        ctx.lineWidth = 0.8;
        ctx.beginPath(); ctx.arc(x, y, radius*0.72, 0, Math.PI*2); ctx.stroke();
        ctx.restore();

        // 3. Body fill – radial gradient
        ctx.save();
        ctx.shadowColor = color; ctx.shadowBlur = 10;
        const body = ctx.createRadialGradient(x - radius*0.3, y - radius*0.3, 0, x, y, radius*0.9);
        body.addColorStop(0,   `rgba(255,255,255,0.92)`);
        body.addColorStop(0.2, `rgba(${cr},${cg},${cb},0.85)`);
        body.addColorStop(0.65,`rgba(${Math.max(0,cr-60)},${Math.max(0,cg-60)},${Math.max(0,cb-40)},0.9)`);
        body.addColorStop(1,   'rgba(0,0,20,0.92)');
        ctx.fillStyle = body;
        ctx.beginPath(); ctx.arc(x, y, radius*0.9, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // 4. Centre diamond / target cross
        ctx.save();
        ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 8;
        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        ctx.lineWidth = 0.9;
        const cd = radius * 0.3;
        ctx.beginPath();
        ctx.moveTo(x, y - cd); ctx.lineTo(x + cd, y);
        ctx.lineTo(x, y + cd); ctx.lineTo(x - cd, y);
        ctx.closePath(); ctx.stroke();
        ctx.restore();

        // 5. Rotating shine sweep
        const shineFrac = (t * 1.2 + x * 0.01 + y * 0.008) % 1;
        const shineAngle = shineFrac * Math.PI * 2;
        ctx.save();
        ctx.clip(new Path2D());
        ctx.beginPath(); ctx.arc(x, y, radius*0.88, 0, Math.PI*2);
        ctx.clip();
        const sx = x + Math.cos(shineAngle) * radius * 0.6;
        const sy = y + Math.sin(shineAngle) * radius * 0.6;
        const sg = ctx.createRadialGradient(sx, sy, 0, sx, sy, radius*0.55);
        sg.addColorStop(0,   'rgba(255,255,255,0.55)');
        sg.addColorStop(0.5, 'rgba(255,255,255,0.12)');
        sg.addColorStop(1,   'transparent');
        ctx.fillStyle = sg; ctx.fillRect(x-radius, y-radius, radius*2, radius*2);
        ctx.restore();
    }

    // =====================================================
    // === DMD DRAWN ON CANVAS (mid-playfield, behind ball) ===
    // =====================================================
    // DMD panel geometry in table-space
    const DMD_W      = 237;       // 20% smaller than original 296
    const DMD_H      = 64;        // 20% smaller than original 80
    const DMD_X      = Math.round(CENTER_X - DMD_W / 2);  // centred on visual centre (180)
    const DMD_Y      = 418;       // below spot-target grid, above 2X display
    const DMD_R      = 5;

    function drawDMDOnCanvas() {
        const t = performance.now() * 0.001;
        const dmdEl = document.getElementById('dmdCanvas');

        ctx.save();
        ctx.beginPath();
        ctx.roundRect(DMD_X, DMD_Y, DMD_W, DMD_H, DMD_R);
        ctx.clip();

        // ── 1. Tinted background — transparent enough to show playfield beneath ──
        const bgG = ctx.createLinearGradient(DMD_X, DMD_Y, DMD_X, DMD_Y + DMD_H);
        bgG.addColorStop(0, 'rgba(6,0,18,0.62)');
        bgG.addColorStop(1, 'rgba(2,0,10,0.68)');
        ctx.fillStyle = bgG;
        ctx.fillRect(DMD_X, DMD_Y, DMD_W, DMD_H);

        // ── 2. DMD canvas content (off-screen buffer blit) ────────────────
        if (dmdEl && dmdEl.width > 0) {
            ctx.globalAlpha = 0.88;
            ctx.drawImage(dmdEl, DMD_X + 2, DMD_Y + 2, DMD_W - 4, DMD_H - 4);
            ctx.globalAlpha = 1;
        }

        // ── 3. Dot-matrix pixel grid overlay ─────────────────────────────
        ctx.fillStyle = 'rgba(0,0,0,0.26)';
        for (let gx = DMD_X; gx < DMD_X + DMD_W; gx += 4) {
            ctx.fillRect(gx + 3, DMD_Y, 1, DMD_H);
        }
        for (let gy = DMD_Y; gy < DMD_Y + DMD_H; gy += 4) {
            ctx.fillRect(DMD_X, gy + 3, DMD_W, 1);
        }

        // ── 4. Scanlines ──────────────────────────────────────────────────
        const flickA = 0.05 + 0.03 * Math.sin(t * 37);
        ctx.fillStyle = `rgba(0,0,0,${flickA})`;
        for (let gy = DMD_Y; gy < DMD_Y + DMD_H; gy += 2) {
            ctx.fillRect(DMD_X, gy, DMD_W, 1);
        }

        ctx.restore(); // end clip

        // ── 5. Corner bracket accents ─────────────────────────────────────
        const bpulse = 0.5 + 0.5 * Math.sin(t * 2.2);
        ctx.save();
        ctx.strokeStyle = `rgba(64,224,255,${0.5 + 0.3 * bpulse})`;
        ctx.lineWidth = 1.5;
        ctx.shadowColor = '#40e0ff';
        ctx.shadowBlur  = 6;
        const cm = 10;
        [
            [DMD_X,           DMD_Y,          1, 1],
            [DMD_X + DMD_W,   DMD_Y,         -1, 1],
            [DMD_X,           DMD_Y + DMD_H,  1,-1],
            [DMD_X + DMD_W,   DMD_Y + DMD_H, -1,-1],
        ].forEach(([cx2, cy2, dx, dy]) => {
            ctx.beginPath();
            ctx.moveTo(cx2 + dx * cm, cy2);
            ctx.lineTo(cx2, cy2);
            ctx.lineTo(cx2, cy2 + dy * cm);
            ctx.stroke();
        });
        ctx.restore();

        // ── 6. Outer magenta border glow ──────────────────────────────────
        ctx.save();
        ctx.shadowColor = '#ff00cc';
        ctx.shadowBlur  = 22;
        ctx.strokeStyle = 'rgba(255,0,200,0.85)';
        ctx.lineWidth   = 1.5;
        ctx.beginPath();
        ctx.roundRect(DMD_X, DMD_Y, DMD_W, DMD_H, DMD_R);
        ctx.stroke();
        ctx.restore();

        // ── 7. Inner dashed cyan accent ───────────────────────────────────
        ctx.save();
        const dacePulse = 0.3 + 0.2 * Math.sin(t * 1.6);
        ctx.strokeStyle = `rgba(64,224,255,${dacePulse})`;
        ctx.lineWidth   = 0.7;
        ctx.setLineDash([5, 4]);
        ctx.beginPath();
        ctx.roundRect(DMD_X + 3, DMD_Y + 3, DMD_W - 6, DMD_H - 6, DMD_R - 1);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        // ── 8. Label tabs on top edge ─────────────────────────────────────
        function dmdTab(txt, tx, col) {
            ctx.save();
            ctx.font = "bold 6px 'Share Tech Mono', monospace";
            ctx.textAlign = 'center';
            const tw = ctx.measureText(txt).width + 8;
            const ty = DMD_Y; // sits right on top border
            ctx.fillStyle   = 'rgba(3,0,10,0.92)';
            ctx.strokeStyle = col;
            ctx.lineWidth   = 0.8;
            ctx.shadowColor = col; ctx.shadowBlur = 6;
            ctx.beginPath();
            ctx.roundRect(tx - tw/2, ty - 9, tw, 10, 2);
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = col;
            ctx.textBaseline = 'middle';
            ctx.fillText(txt, tx, ty - 4);
            ctx.restore();
        }
        dmdTab('PLAYER 1',                       DMD_X + DMD_W * 0.17, 'rgba(255,0,200,0.8)');
        dmdTab('BALL ' + (window._dmdGameBalls || 3), DMD_X + DMD_W * 0.5,  'rgba(64,224,255,0.85)');
        dmdTab('CREDITS ∞',                      DMD_X + DMD_W * 0.83, 'rgba(255,0,200,0.6)');
    }

    // Outer table border – 5-layer neon (same helper approach as drawSmoothWalls)
    function drawOuterWalls() {
        const t = performance.now() * 0.001;

        function neonRect(x, y, w, h, coreColor, glowColor, lw, phase) {
            const path = new Path2D();
            path.rect(x, y, w, h);

            // 1. Drop shadow
            ctx.save();
            ctx.strokeStyle = 'rgba(0,0,0,0.55)';
            ctx.lineWidth = lw + 5; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.translate(2, 3); ctx.stroke(path); ctx.restore();

            // 2. Wide outer glow (two passes)
            ctx.save();
            ctx.shadowColor = glowColor; ctx.shadowBlur = 30;
            ctx.strokeStyle = glowColor; ctx.lineWidth = lw + 1;
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.globalAlpha = 0.35; ctx.stroke(path);
            ctx.shadowBlur = 14; ctx.globalAlpha = 0.55; ctx.stroke(path);
            ctx.restore();

            // 3. Core body
            ctx.save();
            ctx.strokeStyle = coreColor; ctx.lineWidth = lw;
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.shadowColor = glowColor; ctx.shadowBlur = 10;
            ctx.stroke(path); ctx.restore();

            // 4. Spine highlight
            ctx.save();
            ctx.strokeStyle = 'rgba(200,248,255,0.72)';
            ctx.lineWidth = lw * 0.2; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.translate(-0.8, -0.8); ctx.stroke(path); ctx.restore();

            // 5. Shimmer pulse
            const shimmer = 0.5 + 0.5 * Math.sin(t * 2.2 + phase);
            ctx.save();
            ctx.strokeStyle = `rgba(255,255,255,${shimmer * 0.45})`;
            ctx.lineWidth = lw * 0.3; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.globalAlpha = shimmer * 0.6; ctx.stroke(path); ctx.restore();
        }

        // Outer cyan border
        neonRect(4, 4, TABLE_WIDTH - 8, TABLE_HEIGHT - 8, '#a0f4ff', '#40e0ff', 3, 0.0);
        // Inner magenta dashed accent (dashed separately)
        ctx.save();
        ctx.shadowColor = '#ff00cc'; ctx.shadowBlur = 12;
        ctx.strokeStyle = `rgba(255,0,200,${0.35 + 0.2 * Math.sin(t * 1.8)})`;
        ctx.lineWidth = 1; ctx.setLineDash([8, 5]);
        ctx.strokeRect(9, 9, TABLE_WIDTH - 18, TABLE_HEIGHT - 18);
        ctx.setLineDash([]); ctx.restore();
    }

    // Draw shooter lane – neon wall sides + magenta plunger (no black housing)
    function drawShooterLane() {
        const t = performance.now() * 0.001;
        const shooterStart = 1 + FLIPPER_SEGMENTS * 2;
        let minY = TABLE_HEIGHT, maxY = 0;
        for (let i = 0; i < FLIPPER_SEGMENTS; i++) {
            const shooter = objects[shooterStart + i];
            if (shooter && shooter.isShooter) {
                minY = Math.min(minY, shooter.y);
                maxY = Math.max(maxY, shooter.y);
            }
        }

        const plungerX    = CENTER_X + DOME_RADIUS - BALL_RADIUS;
        const plungerW    = 11;
        const laneLeft    = plungerX - plungerW / 2 - 4;
        const laneRight   = plungerX + plungerW / 2 + 4;
        const laneTop     = minY - 8;
        const laneBottom  = maxY + 8;
        const isCharging  = keys.c;

        // Helper: draw one vertical neon strip (like the CSS .rail style)
        function neonStrip(x, y1, y2, coreColor, glowColor, lw, phase) {
            const path = new Path2D();
            path.moveTo(x, y1); path.lineTo(x, y2);

            // Drop shadow
            ctx.save();
            ctx.strokeStyle = 'rgba(0,0,0,0.55)'; ctx.lineWidth = lw + 5;
            ctx.lineCap = 'round'; ctx.translate(2, 3); ctx.stroke(path); ctx.restore();

            // Wide outer glow
            ctx.save();
            ctx.shadowColor = glowColor; ctx.shadowBlur = 28;
            ctx.strokeStyle = glowColor; ctx.lineWidth = lw + 1;
            ctx.lineCap = 'round'; ctx.globalAlpha = 0.38; ctx.stroke(path);
            ctx.shadowBlur = 14; ctx.globalAlpha = 0.58; ctx.stroke(path); ctx.restore();

            // Core
            ctx.save();
            ctx.strokeStyle = coreColor; ctx.lineWidth = lw;
            ctx.lineCap = 'round'; ctx.shadowColor = glowColor; ctx.shadowBlur = 10;
            ctx.stroke(path); ctx.restore();

            // Spine
            ctx.save();
            ctx.strokeStyle = 'rgba(200,248,255,0.82)'; ctx.lineWidth = lw * 0.22;
            ctx.lineCap = 'round'; ctx.translate(-0.8, -0.8); ctx.stroke(path); ctx.restore();

            // Shimmer
            const s = 0.5 + 0.5 * Math.sin(t * 2.8 + phase);
            ctx.save();
            ctx.strokeStyle = `rgba(255,255,255,${s * 0.55})`; ctx.lineWidth = lw * 0.35;
            ctx.lineCap = 'round'; ctx.globalAlpha = s * 0.7; ctx.stroke(path); ctx.restore();
        }

        // Left and right lane walls (cyan strips)
        neonStrip(laneLeft,  laneTop, laneBottom, '#a0f4ff', '#40e0ff', 4, 0.3);
        neonStrip(laneRight, laneTop, laneBottom, '#a0f4ff', '#40e0ff', 4, 1.7);

        // ── PLUNGER – magenta rod, same flipper layered style ──────────────
        const plungerH = maxY - minY;

        // Build plunger pill path
        const pilPath = new Path2D();
        pilPath.roundRect(plungerX - plungerW/2, minY, plungerW, plungerH, plungerW/2);

        // Glow
        ctx.save();
        ctx.shadowColor = isCharging ? '#ffffff' : '#ff00cc';
        ctx.shadowBlur  = isCharging ? 40 : 22;
        ctx.fillStyle   = isCharging ? 'rgba(255,255,255,0.22)' : 'rgba(255,0,200,0.18)';
        ctx.fill(pilPath);
        ctx.shadowBlur  = isCharging ? 18 : 10;
        ctx.fillStyle   = isCharging ? 'rgba(255,255,255,0.3)' : 'rgba(255,0,200,0.28)';
        ctx.fill(pilPath); ctx.restore();

        // Body gradient top-to-bottom (same recipe as flippers)
        ctx.save();
        const pg = ctx.createLinearGradient(plungerX - plungerW/2, 0, plungerX + plungerW/2, 0);
        if (isCharging) {
            pg.addColorStop(0,   'rgba(60,0,40,1)');
            pg.addColorStop(0.2, 'rgba(200,0,160,0.95)');
            pg.addColorStop(0.5, 'rgba(255,140,255,0.98)');
            pg.addColorStop(0.8, 'rgba(200,0,160,0.95)');
            pg.addColorStop(1,   'rgba(60,0,40,1)');
        } else {
            pg.addColorStop(0,   'rgba(40,0,30,1)');
            pg.addColorStop(0.2, 'rgba(160,0,120,0.92)');
            pg.addColorStop(0.5, 'rgba(255,60,200,0.90)');
            pg.addColorStop(0.8, 'rgba(160,0,120,0.92)');
            pg.addColorStop(1,   'rgba(40,0,30,1)');
        }
        ctx.fillStyle = pg;
        ctx.shadowColor = isCharging ? '#ffffff' : '#ff00cc';
        ctx.shadowBlur  = isCharging ? 18 : 8;
        ctx.fill(pilPath); ctx.restore();

        // Spine highlight (left edge bright strip)
        ctx.save();
        const spineG = ctx.createLinearGradient(0, minY, 0, minY + plungerH);
        spineG.addColorStop(0,   'rgba(255,255,255,0.0)');
        spineG.addColorStop(0.2, 'rgba(255,200,255,0.7)');
        spineG.addColorStop(0.5, 'rgba(255,255,255,0.88)');
        spineG.addColorStop(0.8, 'rgba(255,200,255,0.7)');
        spineG.addColorStop(1,   'rgba(255,255,255,0.0)');
        ctx.save();
        ctx.clip(pilPath);
        ctx.fillStyle = spineG;
        ctx.fillRect(plungerX - plungerW/2, minY, plungerW * 0.35, plungerH);
        ctx.restore(); ctx.restore();

        // Shimmer sweep
        const shimPos = (t * 0.6) % 1.0;
        const shimY = minY + shimPos * plungerH;
        const shimH = plungerH * 0.28;
        ctx.save();
        ctx.clip(pilPath);
        const shG = ctx.createLinearGradient(0, shimY - shimH/2, 0, shimY + shimH/2);
        shG.addColorStop(0,   'transparent');
        shG.addColorStop(0.5, `rgba(255,255,255,${isCharging ? 0.55 : 0.35})`);
        shG.addColorStop(1,   'transparent');
        ctx.fillStyle = shG;
        ctx.fillRect(plungerX - plungerW/2, shimY - shimH/2, plungerW, shimH);
        ctx.restore();

        // Edge stroke
        ctx.save();
        ctx.strokeStyle = isCharging ? 'rgba(255,255,255,0.7)' : 'rgba(255,160,240,0.55)';
        ctx.lineWidth = 1.2; ctx.stroke(pilPath); ctx.restore();

        // Tip cap glow dot
        ctx.save();
        ctx.shadowColor = isCharging ? '#ffffff' : '#ff00cc';
        ctx.shadowBlur  = isCharging ? 28 : 14;
        ctx.fillStyle   = isCharging ? '#ffffff' : '#ff80e8';
        ctx.beginPath();
        ctx.arc(plungerX, minY, plungerW * 0.55, 0, Math.PI * 2);
        ctx.fill(); ctx.restore();
    }

    function draw() {
        ctx.fillStyle = '#03010e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        // Animated glowing grid background
        drawAnimatedGrid();

        // DMD panel drawn MID-PLAYFIELD, behind everything (ball goes over the top)
        drawDMDOnCanvas();

        // Draw smooth walls (aesthetic layer over physics circles)
        drawSmoothWalls();

        // Draw slingshots with glow
        drawSlingshots();

        // Draw flippers with enhanced glow
        drawFlippers();

        // Draw shooter lane
        drawShooterLane();

        // Outer table border walls – same neon style as interior walls
        drawOuterWalls();

        // Draw game objects with enhanced rendering
        const ball = objects[0];

        // First pass: Draw drop targets
        for (let i = objects.length - 1; i >= 1; i--) {
            const obj = objects[i];
            if (obj.isDropTarget) {
                let color = DROP_COLORS[targetLevel % DROP_COLORS.length];
                if (obj.isRampDropTarget) color = '#ff8800';
                if (obj.bounce > 0) color = '#ffffff';
                drawDropTarget3D(obj.x, obj.y, obj.radius + (obj.bounce || 0), color, obj.active);
            }
        }

        // Second pass: Draw bumpers (pop bumpers with 3D effect)
        for (let i = objects.length - 1; i >= 1; i--) {
            const obj = objects[i];
            if (obj.type === TYPE_BUMPER && !obj.isSlingshot) {
                let color = obj.color;
                if (obj.isCenterBumper && obj.bounce <= 0) {
                    color = BUMPER_COLORS[spotCompletions % BUMPER_COLORS.length];
                } else if (obj.isHighValue && obj.bounce <= 0) {
                    color = '#ff0000';
                }
                if (obj.bounce > 0) color = '#ffffff';

                // Use 3D bumper for larger bumpers
                if (obj.radius >= 10) {
                    drawBumper3D(obj.x, obj.y, obj.radius, color, obj.bounce > 0);
                } else {
                    // Smaller pins get simpler 3D treatment
                    drawPin3D(obj.x, obj.y, obj.radius + (obj.bounce || 0), color);
                }
            }
        }

        // Third pass: Draw standup targets
        for (let i = objects.length - 1; i >= 1; i--) {
            const obj = objects[i];
            if (obj.isStandupTarget) {
                const bank = obj.standupBank;
                const idx = obj.standupIndex;
                const isLit = bank === 'left' ? standupBankLeft[idx] : standupBankRight[idx];
                let color = obj.bounce > 0 ? '#ffffff' : (isLit ? '#ff00cc' : '#330022');
                drawPin3D(obj.x, obj.y, obj.radius + (obj.bounce || 0), color);
            }
        }

        // Fourth pass: Draw center pin and top lane pins
        for (let i = objects.length - 1; i >= 1; i--) {
            const obj = objects[i];
            // Skip flippers, shooter, bumpers, drop targets, standup targets
            if (i >= 1 && i <= FLIPPER_SEGMENTS * 2) continue;
            if (obj.isShooter) continue;
            if (obj.type === TYPE_BUMPER) continue;
            if (obj.isDropTarget) continue;
            if (obj.isStandupTarget) continue;
            if (obj.isSpinner) continue;
            if (obj.isScoop) continue;
            if (obj.isRampWall) continue;  // Walls handled by drawSmoothWalls
            // Skip all regular wall objects - they're rendered by drawSmoothWalls()
            // Keep center pin and top lane pins visible
            if (obj.type === TYPE_WALL && !obj.isCenterPin && !obj.isTopLanePin && obj.radius <= 6) continue;

            // These are decorative pins (center pin, top lane pins, etc.)
            if (obj.isCenterPin) {
                const color = safetyPinActive ? '#ffff00' : '#00ffff';
                drawPin3D(obj.x, obj.y, obj.radius, color);
            } else if (obj.radius <= 6) {
                // Small pins at top lanes
                drawPin3D(obj.x, obj.y, obj.radius, obj.color || '#00ffff');
            }
        }

        // Top lane lights – sci-fi neon with shine sweep
        const topLaneLightY = TOP_LANE_Y;
        const tlT = performance.now() * 0.001;
        for (let i = 0; i < 3; i++) {
            const lx = (TOP_LANE_PINS[i] + TOP_LANE_PINS[i + 1]) / 2;
            const isLit = topLaneLights[i];
            const litCol = isLit ? [255, 220, 0] : [50, 40, 60];
            const [lr, lg, lb] = litCol;
            const R = 10;

            if (isLit) {
                // Wide halo
                ctx.save();
                ctx.shadowColor = `rgb(${lr},${lg},${lb})`; ctx.shadowBlur = 20;
                const halo = ctx.createRadialGradient(lx, topLaneLightY, R*0.3, lx, topLaneLightY, R*2.8);
                halo.addColorStop(0, `rgba(${lr},${lg},${lb},0.55)`);
                halo.addColorStop(0.5, `rgba(${lr},${lg},${lb},0.15)`);
                halo.addColorStop(1, 'transparent');
                ctx.fillStyle = halo;
                ctx.beginPath(); ctx.arc(lx, topLaneLightY, R*2.8, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }

            // Bezel ring
            ctx.save();
            ctx.strokeStyle = `rgba(${lr},${lg},${lb},${isLit ? 0.85 : 0.22})`;
            ctx.lineWidth = 1; ctx.shadowColor = `rgb(${lr},${lg},${lb})`; ctx.shadowBlur = isLit ? 8 : 2;
            ctx.beginPath(); ctx.arc(lx, topLaneLightY, R, 0, Math.PI*2); ctx.stroke();
            ctx.restore();

            // Body
            ctx.save();
            const lg2 = ctx.createRadialGradient(lx-R*0.3, topLaneLightY-R*0.3, 0, lx, topLaneLightY, R);
            lg2.addColorStop(0,   isLit ? 'rgba(255,255,220,0.98)' : 'rgba(70,60,80,0.8)');
            lg2.addColorStop(0.4, `rgba(${lr},${lg},${lb},${isLit ? 0.9 : 0.25})`);
            lg2.addColorStop(1,   `rgba(${Math.max(0,lr-100)},${Math.max(0,lg-100)},0,0.92)`);
            ctx.fillStyle = lg2; ctx.shadowColor = `rgb(${lr},${lg},${lb})`; ctx.shadowBlur = isLit ? 10 : 0;
            ctx.beginPath(); ctx.arc(lx, topLaneLightY, R, 0, Math.PI*2); ctx.fill();
            ctx.restore();

            // Rotating shine (lit only)
            if (isLit) {
                const sa = (tlT * 2.2 + i * 2.1) % (Math.PI*2);
                const sx = lx + Math.cos(sa) * R*0.5;
                const sy = topLaneLightY + Math.sin(sa) * R*0.5;
                ctx.save();
                ctx.beginPath(); ctx.arc(lx, topLaneLightY, R*0.92, 0, Math.PI*2); ctx.clip();
                const sg = ctx.createRadialGradient(sx, sy, 0, sx, sy, R*0.7);
                sg.addColorStop(0, 'rgba(255,255,255,0.7)'); sg.addColorStop(1, 'transparent');
                ctx.fillStyle = sg; ctx.fillRect(lx-R, topLaneLightY-R, R*2, R*2);
                ctx.restore();
            }
        }

        // Spot targets – sci-fi with pulsing ring and shine
        const spT = performance.now() * 0.001;
        for (let i = 0; i < 4; i++) {
            const st = SPOT_TARGET_POSITIONS[i];
            const isLit = spotTargets[i];
            const litColor = SPOT_LIT[targetLevel % SPOT_LIT.length];
            const darkColor = SPOT_DARK[targetLevel % SPOT_DARK.length];
            const col = isLit ? litColor : darkColor;
            const num2 = parseInt(col.replace('#',''),16);
            const sr = (num2>>16)&255, sg = (num2>>8)&255, sb = num2&255;
            const R = 6;

            if (isLit) {
                // Pulsing outer ring
                const pulse = 0.5 + 0.5*Math.sin(spT*3.5 + i*1.2);
                ctx.save();
                ctx.strokeStyle = `rgba(${sr},${sg},${sb},${0.4 + 0.4*pulse})`;
                ctx.lineWidth = 1.2;
                ctx.shadowColor = col; ctx.shadowBlur = 14 + 8*pulse;
                ctx.beginPath(); ctx.arc(st.x, st.y, R*1.7 + pulse*2, 0, Math.PI*2); ctx.stroke();
                ctx.restore();
            }

            drawPin3D(st.x, st.y, R, isLit ? litColor : darkColor);
        }

        // Lane / outlane lights – sci-fi capsule style with shine
        const llT = performance.now() * 0.001;
        for (let i = 0; i < 4; i++) {
            const ll = LANE_LIGHT_POSITIONS[i];
            const isLit = laneLights[i];
            const isOutlane = i === 0 || i === 3;
            // Outlane: magenta, inlane: cyan
            const litR = isOutlane ? 255 : 64;
            const litG = isOutlane ? 0   : 224;
            const litB = isOutlane ? 200 : 255;
            const R = 5;

            if (isLit) {
                // Wide halo
                ctx.save();
                ctx.shadowBlur = 22;
                ctx.shadowColor = `rgb(${litR},${litG},${litB})`;
                const halo = ctx.createRadialGradient(ll.x, ll.y, R*0.2, ll.x, ll.y, R*3.5);
                halo.addColorStop(0,   `rgba(${litR},${litG},${litB},0.6)`);
                halo.addColorStop(0.4, `rgba(${litR},${litG},${litB},0.2)`);
                halo.addColorStop(1,   'transparent');
                ctx.fillStyle = halo;
                ctx.beginPath(); ctx.arc(ll.x, ll.y, R*3.5, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }

            // Bezel
            ctx.save();
            ctx.strokeStyle = `rgba(${litR},${litG},${litB},${isLit ? 0.9 : 0.2})`;
            ctx.lineWidth = 0.8; ctx.shadowColor = `rgb(${litR},${litG},${litB})`; ctx.shadowBlur = isLit ? 9 : 2;
            ctx.beginPath(); ctx.arc(ll.x, ll.y, R, 0, Math.PI*2); ctx.stroke();
            ctx.restore();

            // Body fill
            ctx.save();
            const bg2 = ctx.createRadialGradient(ll.x - R*0.35, ll.y - R*0.35, 0, ll.x, ll.y, R);
            bg2.addColorStop(0,   isLit ? 'rgba(255,255,255,0.95)' : 'rgba(50,40,55,0.9)');
            bg2.addColorStop(0.4, `rgba(${litR},${litG},${litB},${isLit ? 0.88 : 0.2})`);
            bg2.addColorStop(1,   `rgba(${Math.max(0,litR-80)},${Math.max(0,litG-60)},${Math.max(0,litB-60)},0.95)`);
            ctx.fillStyle = bg2; ctx.shadowColor = `rgb(${litR},${litG},${litB})`; ctx.shadowBlur = isLit ? 8 : 0;
            ctx.beginPath(); ctx.arc(ll.x, ll.y, R, 0, Math.PI*2); ctx.fill();
            ctx.restore();

            // Rotating shine
            if (isLit) {
                const sa = (llT * 2.5 + i * 1.57) % (Math.PI*2);
                const sx = ll.x + Math.cos(sa) * R*0.5;
                const sy = ll.y + Math.sin(sa) * R*0.5;
                ctx.save();
                ctx.beginPath(); ctx.arc(ll.x, ll.y, R*0.9, 0, Math.PI*2); ctx.clip();
                const sg = ctx.createRadialGradient(sx, sy, 0, sx, sy, R*0.7);
                sg.addColorStop(0, 'rgba(255,255,255,0.72)'); sg.addColorStop(1, 'transparent');
                ctx.fillStyle = sg; ctx.fillRect(ll.x-R, ll.y-R, R*2, R*2);
                ctx.restore();
            }
        }

        // Saucer with enhanced rendering
        const saucerColor = saucerActive ? (frame % 10 < 5 ? '#ffffff' : '#00ffff') : '#555555';

        if (saucerActive) {
            // Pulsing glow when active
            ctx.save();
            const pulseIntensity = 0.3 + 0.2 * Math.sin(frame * 0.1);
            const saucerGlow = ctx.createRadialGradient(SAUCER_X, SAUCER_Y, 5, SAUCER_X, SAUCER_Y, 30);
            saucerGlow.addColorStop(0, `rgba(0, 255, 255, ${pulseIntensity})`);
            saucerGlow.addColorStop(0.5, `rgba(0, 200, 255, ${pulseIntensity * 0.5})`);
            saucerGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = saucerGlow;
            ctx.beginPath();
            ctx.arc(SAUCER_X, SAUCER_Y, 30, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // Saucer body
        ctx.save();
        ctx.shadowColor = saucerColor;
        ctx.shadowBlur = saucerActive ? 15 : 5;
        ctx.strokeStyle = saucerColor;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(SAUCER_X, SAUCER_Y, SAUCER_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        // Saucer inner gradient
        const innerGrad = ctx.createRadialGradient(SAUCER_X, SAUCER_Y, 0, SAUCER_X, SAUCER_Y, SAUCER_RADIUS);
        innerGrad.addColorStop(0, 'rgba(0, 50, 100, 0.8)');
        innerGrad.addColorStop(1, 'rgba(0, 20, 40, 0.9)');
        ctx.fillStyle = innerGrad;
        ctx.beginPath();
        ctx.arc(SAUCER_X, SAUCER_Y, SAUCER_RADIUS - 2, 0, Math.PI * 2);
        ctx.fill();

        if (!saucerActive) {
            const nextThreshold = saucerLevel < SAUCER_THRESHOLDS.length
                ? SAUCER_THRESHOLDS[saucerLevel]
                : SAUCER_THRESHOLDS[SAUCER_THRESHOLDS.length - 1] * 2;
            ctx.fillStyle = '#888888';
            ctx.font = "bold 8px 'Orbitron', monospace";
            ctx.textAlign = 'center';
            ctx.fillText(nextThreshold, SAUCER_X, SAUCER_Y + 3);
        }

        // === TABLE 2 SPECIFIC RENDERING ===
        if (currentTable === 2) {
            // Draw semi-transparent pink ramp coverage area for visibility
            ctx.save();
            ctx.fillStyle = 'rgba(255, 105, 180, 0.25)';  // Semi-transparent pink
            ctx.beginPath();
            // Left edge of ramp area
            ctx.moveTo(25, 230);
            ctx.quadraticCurveTo(15, 160, 55, 90);
            ctx.quadraticCurveTo(100, 60, 130, 90);
            ctx.lineTo(155, 140);
            // Right edge of ramp area (return path)
            ctx.quadraticCurveTo(140, 100, 85, 110);
            ctx.quadraticCurveTo(45, 170, 65, 230);
            ctx.closePath();
            ctx.fill();
            // Add pink border to show ramp boundary
            ctx.strokeStyle = 'rgba(255, 105, 180, 0.6)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();

            // Draw ramp path guide with glow
            ctx.save();
            if (!rampDropTargetActive) {
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 10;
            }
            ctx.strokeStyle = rampDropTargetActive ? '#444444' : '#00ff88';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(45, 230);
            ctx.quadraticCurveTo(30, 160, 70, 100);
            ctx.quadraticCurveTo(120, 80, 140, 120);
            ctx.stroke();
            ctx.restore();

            // Ramp rails (3D look)
            if (!rampDropTargetActive) {
                ctx.strokeStyle = '#00aa66';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(40, 230);
                ctx.quadraticCurveTo(25, 160, 65, 100);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(50, 230);
                ctx.quadraticCurveTo(35, 160, 75, 100);
                ctx.stroke();
            }

            // Draw "RAMP" label with glow
            ctx.save();
            if (!rampDropTargetActive) {
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 8;
            }
            ctx.fillStyle = rampDropTargetActive ? '#666666' : '#00ff88';
            ctx.font = "bold 10px 'Orbitron', monospace";
            ctx.textAlign = 'center';
            ctx.fillText('RAMP', 55, 250);
            ctx.restore();

            // Draw spinner - realistic coin-flip style with enhanced effects
            if (table2Spinner) {
                const spinnerWidth = 30;
                const spinnerHeight = 20;
                const spinPhase = (spinnerAngle * Math.PI) / 180;
                const apparentWidth = Math.abs(Math.cos(spinPhase)) * spinnerHeight;
                const isSpinning = spinnerSpeed > 5;

                ctx.save();
                ctx.translate(SPINNER_X, SPINNER_Y);

                // Glow when spinning
                if (isSpinning) {
                    const spinGlow = ctx.createRadialGradient(0, 0, 5, 0, 0, 25);
                    spinGlow.addColorStop(0, 'rgba(0, 255, 136, 0.4)');
                    spinGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = spinGlow;
                    ctx.beginPath();
                    ctx.arc(0, 0, 25, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Axle with 3D effect
                const axleGrad = ctx.createLinearGradient(0, -2, 0, 2);
                axleGrad.addColorStop(0, '#008855');
                axleGrad.addColorStop(0.5, '#00aa66');
                axleGrad.addColorStop(1, '#006644');
                ctx.strokeStyle = axleGrad;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(-spinnerWidth / 2, 0);
                ctx.lineTo(spinnerWidth / 2, 0);
                ctx.stroke();

                // Spinning blade
                const rectWidth = Math.max(2, apparentWidth);
                const bladeGrad = ctx.createLinearGradient(-rectWidth / 2, 0, rectWidth / 2, 0);
                bladeGrad.addColorStop(0, '#00aa66');
                bladeGrad.addColorStop(0.3, '#00ffaa');
                bladeGrad.addColorStop(0.7, '#00ffaa');
                bladeGrad.addColorStop(1, '#00aa66');

                ctx.fillStyle = bladeGrad;
                ctx.fillRect(-rectWidth / 2, -spinnerWidth / 2, rectWidth, spinnerWidth);

                // Edge highlights
                ctx.strokeStyle = '#aaffdd';
                ctx.lineWidth = 1;
                ctx.strokeRect(-rectWidth / 2, -spinnerWidth / 2, rectWidth, spinnerWidth);

                ctx.restore();

                // Spinner label
                ctx.save();
                if (isSpinning) {
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 8;
                }
                ctx.fillStyle = '#00ff88';
                ctx.font = "bold 8px 'Orbitron', monospace";
                ctx.textAlign = 'center';
                ctx.fillText('SPIN', SPINNER_X, SPINNER_Y + 22);
                ctx.restore();
            }

            // Draw scoop with enhanced 3D effect
            if (table2Scoop) {
                const scoopColor = scoopBallLocked ? '#ff00ff' : '#8800ff';

                // Glow when ball locked
                if (scoopBallLocked) {
                    ctx.save();
                    const scoopGlow = ctx.createRadialGradient(SCOOP_X, SCOOP_Y, 5, SCOOP_X, SCOOP_Y, 30);
                    scoopGlow.addColorStop(0, 'rgba(255, 0, 255, 0.5)');
                    scoopGlow.addColorStop(0.5, 'rgba(255, 0, 255, 0.2)');
                    scoopGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = scoopGlow;
                    ctx.beginPath();
                    ctx.arc(SCOOP_X, SCOOP_Y, 30, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Scoop rim with depth
                ctx.save();
                ctx.shadowColor = scoopColor;
                ctx.shadowBlur = 10;
                ctx.strokeStyle = scoopColor;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(SCOOP_X, SCOOP_Y, SCOOP_RADIUS + 2, Math.PI * 0.3, Math.PI * 0.7, true);
                ctx.stroke();
                ctx.restore();

                // Scoop hole gradient
                const holeGrad = ctx.createRadialGradient(SCOOP_X, SCOOP_Y, 0, SCOOP_X, SCOOP_Y, SCOOP_RADIUS);
                holeGrad.addColorStop(0, '#110022');
                holeGrad.addColorStop(0.7, '#220044');
                holeGrad.addColorStop(1, '#330066');
                ctx.fillStyle = holeGrad;
                ctx.beginPath();
                ctx.arc(SCOOP_X, SCOOP_Y, SCOOP_RADIUS - 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw locked ball in scoop
                if (scoopBallLocked) {
                    const lockPulse = 0.8 + 0.2 * Math.sin(frame * 0.15);
                    ctx.save();
                    ctx.globalAlpha = lockPulse;
                    drawBall3D(SCOOP_X, SCOOP_Y, BALL_RADIUS, 0, 0);
                    ctx.restore();

                    // "LOCKED" text with glow
                    ctx.save();
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = frame % 10 < 5 ? '#ff00ff' : '#ffffff';
                    ctx.font = "bold 9px 'Orbitron', monospace";
                    ctx.textAlign = 'center';
                    ctx.fillText('LOCKED', SCOOP_X, SCOOP_Y + 28);
                    ctx.restore();
                }

                // Scoop label
                ctx.save();
                ctx.shadowColor = scoopColor;
                ctx.shadowBlur = 5;
                ctx.fillStyle = scoopColor;
                ctx.font = "bold 8px 'Orbitron', monospace";
                ctx.textAlign = 'center';
                ctx.fillText('LOCK', SCOOP_X, SCOOP_Y - 22);
                ctx.restore();
            }

            // Multiball ready indicator
            if (multiballReady) {
                ctx.save();
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 20;
                ctx.fillStyle = frame % 8 < 4 ? '#ff00ff' : '#ffffff';
                ctx.font = "bold 14px 'Orbitron', monospace";
                ctx.textAlign = 'center';
                ctx.fillText('MULTIBALL READY!', TABLE_WIDTH / 2, 80);
                ctx.restore();
            }

            // Multiball active indicator
            if (multiballActive) {
                ctx.save();
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.fillStyle = frame % 6 < 3 ? '#00ffff' : '#ff00ff';
                ctx.font = "bold 18px 'Orbitron', monospace";
                ctx.textAlign = 'center';
                ctx.fillText('MULTIBALL!', TABLE_WIDTH / 2, 70);
                ctx.font = "bold 12px 'Orbitron', monospace";
                ctx.fillText('2X SCORING', TABLE_WIDTH / 2, 88);
                ctx.restore();
            }

            // Table 2 indicator with subtle glow
            ctx.save();
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 8;
            ctx.fillStyle = '#00ff88';
            ctx.font = "bold 10px 'Orbitron', monospace";
            ctx.textAlign = 'left';
            ctx.fillText('TABLE 2', 10, TABLE_HEIGHT - 15);
            ctx.restore();
        }

        if (currentTable === 3) {
            drawTable3Features();
        }


        // Table transition effect
        if (tableTransitioning && tableTransitionTimer > 0) {
            const progress = 1 - (tableTransitionTimer / 120);
            ctx.save();
            ctx.globalAlpha = Math.sin(progress * Math.PI);
            ctx.fillStyle = '#00ff88';
            ctx.font = "bold 32px 'Orbitron', monospace";
            ctx.textAlign = 'center';
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 30;
            ctx.fillText('TABLE 2', TABLE_WIDTH / 2, TABLE_HEIGHT / 2 - 20);
            ctx.font = "bold 16px 'Orbitron', monospace";
            ctx.fillText('ADVANCED MODE', TABLE_WIDTH / 2, TABLE_HEIGHT / 2 + 15);
            ctx.restore();
        }

        // Score multiplier with pulsing glow
        if (scoreMultiplier > 1) {
            ctx.save();
            const multPulse = 0.8 + 0.2 * Math.sin(frame * 0.1);
            ctx.shadowColor = '#ff8800';
            ctx.shadowBlur = 10 * multPulse;
            ctx.fillStyle = '#ff8800';
            ctx.font = "bold 16px 'Orbitron', monospace";
            ctx.textAlign = 'center';
            ctx.fillText(scoreMultiplier + 'X', CENTER_X, FLIPPER_Y - 140);
            ctx.restore();
        }

        // Draw ball LAST (on top of everything) with enhanced 3D rendering
        if (ball.x > -50) {
            drawBall3D(ball.x, ball.y, ball.radius, ball.vx, ball.vy);
        }
        
        drawScorePopups();

        // Draw mute button during gameplay - DMD style
        if (gameState === STATE_PLAYING) {
            const mbx = TABLE_WIDTH - 48;
            const mby = 14;
            ctx.fillStyle = '#080005';
            ctx.fillRect(mbx, mby, 38, 20);
            ctx.strokeStyle = soundMuted ? '#ff4444' : 'rgba(255,0,200,0.4)';
            ctx.lineWidth = 1;
            ctx.strokeRect(mbx, mby, 38, 20);
            if (soundMuted) {
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = 6;
            }
            ctx.fillStyle = soundMuted ? '#ff4444' : 'rgba(255,0,200,0.6)';
            ctx.font = 'bold 9px "Share Tech Mono", monospace';
            ctx.textAlign = 'center';
            ctx.fillText(soundMuted ? 'MUTE' : 'SND', mbx + 19, mby + 14);
            ctx.shadowBlur = 0;
        }

        // Draw level up text
        if (levelUpTimer > 0) {
            const luAlpha = Math.min(1, levelUpTimer / 20);
            ctx.save();
            ctx.globalAlpha = luAlpha;
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#ffff00';
            ctx.font = "bold 26px 'Orbitron', monospace";
            ctx.textAlign = 'center';
            ctx.fillText('TABLE LEVEL UP!', TABLE_WIDTH / 2, TABLE_HEIGHT / 3);
            ctx.fillStyle = '#ffffff';
            ctx.font = "bold 16px 'Orbitron', monospace";
            ctx.fillText('LEVEL ' + targetLevel, TABLE_WIDTH / 2, TABLE_HEIGHT / 3 + 28);
            ctx.restore();
        }

        // Draw ball save text
        if (ballSaveTimer > 0) {
            const bsAlpha = Math.min(1, ballSaveTimer / 20);
            ctx.save();
            ctx.globalAlpha = bsAlpha;
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#00ff00';
            ctx.font = "bold 28px 'Orbitron', monospace";
            ctx.textAlign = 'center';
            ctx.fillText('BALL SAVE!', TABLE_WIDTH / 2, TABLE_HEIGHT / 3);
            ctx.restore();
        }

        // Draw extra ball text
        if (extraBallTimer > 0 && levelUpTimer <= 0) {
            const ebAlpha = Math.min(1, extraBallTimer / 20);
            ctx.save();
            ctx.globalAlpha = ebAlpha;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#00ffff';
            ctx.font = "bold 28px 'Orbitron', monospace";
            ctx.textAlign = 'center';
            ctx.fillText('EXTRA BALL!', TABLE_WIDTH / 2, TABLE_HEIGHT / 3);
            ctx.fillStyle = '#ffffff';
            ctx.font = "bold 14px 'Orbitron', monospace";
            ctx.fillText('+1 BALL', TABLE_WIDTH / 2, TABLE_HEIGHT / 3 + 24);
            ctx.restore();
        }

        // Draw deep space burst particles (magenta/cyan)
        ctx.save();
        for (const p of dsParticles) {
            const [r,g,b] = p.color;
            const sz = p.size * p.life;
            if (sz < 0.2) continue;
            // Glow halo
            const haloR = sz * 2.5;
            const halo = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, haloR);
            halo.addColorStop(0, `rgba(${r},${g},${b},${p.life * 0.45})`);
            halo.addColorStop(1, 'transparent');
            ctx.fillStyle = halo;
            ctx.beginPath();
            ctx.arc(p.x, p.y, haloR, 0, Math.PI * 2);
            ctx.fill();
            // Core dot
            ctx.beginPath();
            ctx.arc(p.x, p.y, sz, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${r},${g},${b},${p.life * 0.9})`;
            ctx.shadowBlur = 8;
            ctx.shadowColor = `rgba(${r},${g},${b},1)`;
            ctx.fill();
            ctx.shadowBlur = 0;
            // White specular centre
            ctx.beginPath();
            ctx.arc(p.x, p.y, sz * 0.35, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255,255,255,${p.life * 0.7})`;
            ctx.fill();
        }
        ctx.restore();

        // Draw particles with enhanced glow
        for (const p of particles) {
            const alpha = Math.max(0, p.life / 80);
            ctx.globalAlpha = alpha;

            // Particle glow
            ctx.save();
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 8;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Bright center
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        // Draw state overlay
        if (gameState !== STATE_PLAYING) {
            drawOverlay();
        }

        ctx.restore();

        if (gameStarted && gameState === STATE_PLAYING) {
            document.getElementById('instructions').classList.add('hidden');
        }

        
    }

    // === GAME LOOP ===
    let lastTime = 0;
    let accumulator = 0;
    const fixedDelta = 1000 / 60;

    function gameLoop(timestamp) {
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;
        accumulator += Math.min(deltaTime, 50);

        if (gameState === STATE_PLAYING) {
            while (accumulator >= fixedDelta) {
                updatePhysics();
                accumulator -= fixedDelta;
                frame++;
            }
        } else {
            while (accumulator >= fixedDelta) {
                accumulator -= fixedDelta;
                frame++;
            }
            updateMenuState();
        }

        draw();
        requestAnimationFrame(gameLoop);
    }

    // === RESIZE HANDLER ===
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const scaleX = canvas.width / TABLE_WIDTH;
        const scaleY = canvas.height / TABLE_HEIGHT;
        scale = Math.min(scaleX, scaleY) * 0.95;

        // Centre on the visual content midpoint (dome is at CENTER_X=180, not TABLE_WIDTH/2=200)
        // Shift right by the difference so the playfield dome appears centred on screen
        const visualCentreOffset = (TABLE_WIDTH / 2 - CENTER_X) * scale; // = 20 * scale
        offsetX = (canvas.width - TABLE_WIDTH * scale) / 2 + visualCentreOffset;
        offsetY = (canvas.height - TABLE_HEIGHT * scale) / 2;
    }

    // === INPUT HANDLING ===
    // Track actual key states to detect stuck keys
    let keyboardState = { z: false, slash: false, space: false };

    document.addEventListener('keydown', (e) => {
        initAudio();
        // Left flipper: Z key (primary), Shift-Left (alternative)
        if (e.key === 'z' || e.key === 'Z') { keys.z = true; keyboardState.z = true; }
        if (e.code === 'ShiftLeft') keys.z = true;
        // Right flipper: / key (primary), Shift-Right or X (alternative)
        if (e.key === '/' || e.key === '?') { keys.x = true; keyboardState.slash = true; }
        if (e.code === 'ShiftRight' || e.key === 'x' || e.key === 'X') keys.x = true;
        // Plunger: Space or C
        if (e.code === 'Space' || e.key === 'c' || e.key === 'C') { keys.c = true; keyboardState.space = true; }
        if (e.key === 'v' || e.key === 'V') keys.v = true;
        if ((e.key === 'm' || e.key === 'M') && !e.repeat) {
            soundMuted = !soundMuted;
            try { localStorage.setItem('neonPinballMuted', soundMuted ? 'true' : 'false'); } catch (ex) {}
        }
        // Secret hotkey "2" to instantly switch to Table 2 for testing
        if (e.key === '2' && !e.repeat && gameState === STATE_PLAYING && currentTable === 1) {
            transitionToTable2();
        }
        if (e.code === 'Space') e.preventDefault();
        // secret hot key for table 3
        if (e.key === '3' && !e.repeat && gameState === STATE_PLAYING && currentTable === 1) {
            transitionToTable3();
        }

    });

    document.addEventListener('keyup', (e) => {
        // Left flipper release
        if (e.key === 'z' || e.key === 'Z') { keys.z = false; keyboardState.z = false; }
        if (e.code === 'ShiftLeft') keys.z = false;
        // Right flipper release
        if (e.key === '/' || e.key === '?') { keys.x = false; keyboardState.slash = false; }
        if (e.code === 'ShiftRight' || e.key === 'x' || e.key === 'X') keys.x = false;
        // Plunger release
        if (e.code === 'Space' || e.key === 'c' || e.key === 'C') { keys.c = false; keyboardState.space = false; }
        if (e.key === 'v' || e.key === 'V') keys.v = false;
    });

    // Reset all keys when window loses focus (prevents stuck flippers)
    window.addEventListener('blur', () => {
        keys.z = false;
        keys.x = false;
        keys.c = false;
        keys.v = false;
        keyboardState.z = false;
        keyboardState.slash = false;
        keyboardState.space = false;
    });

    // Also reset when window regains focus to catch any missed keyup events
    window.addEventListener('focus', () => {
        keys.z = false;
        keys.x = false;
        keys.c = false;
        keys.v = false;
        keyboardState.z = false;
        keyboardState.slash = false;
        keyboardState.space = false;
    });

    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            keys.z = false;
            keys.x = false;
            keys.c = false;
            keys.v = false;
            keyboardState.z = false;
            keyboardState.slash = false;
            keyboardState.space = false;
        }
    });

    // === TOUCH CONTROLS ===
    document.body.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
    document.body.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

    let activeTouches = new Map();

    function handleTouchStart(e) {
        initAudio();
        for (let touch of e.changedTouches) {
            const x = touch.clientX;
            const y = touch.clientY;
            const width = window.innerWidth;

            // Check overlay buttons in non-playing states
            if (gameState !== STATE_PLAYING) {
                const gameX = (x - offsetX) / scale;
                const gameY = (y - offsetY) / scale;
                const action = checkOverlayButtonHit(gameX, gameY);
                if (action) {
                    overlayTap = action;
                    continue;
                }
                // Fallthrough for left/right scroll in welcome/menu states
            }

            // Check mute button during gameplay
            if (gameState === STATE_PLAYING) {
                const gameX = (x - offsetX) / scale;
                const gameY = (y - offsetY) / scale;
                if (gameX >= TABLE_WIDTH - 48 && gameX <= TABLE_WIDTH - 10 && gameY >= 14 && gameY <= 34) {
                    soundMuted = !soundMuted;
                    try { localStorage.setItem('neonPinballMuted', soundMuted ? 'true' : 'false'); } catch (ex) {}
                    continue;
                }
            }

            if (x < width * 0.5) {
                activeTouches.set(touch.identifier, { zone: 'left', startY: y });
                keys.z = true;
            } else {
                activeTouches.set(touch.identifier, { zone: 'right', startY: y });
                keys.x = true;
            }
        }
    }

    function handleTouchMove(e) {
        for (let touch of e.changedTouches) {
            const touchData = activeTouches.get(touch.identifier);
            if (touchData && touchData.zone === 'right') {
                const deltaY = touch.clientY - touchData.startY;
                if (deltaY > 30) {
                    keys.c = true;
                    touchData.swiping = true;
                }
            }
        }
    }

    function handleTouchEnd(e) {
        for (let touch of e.changedTouches) {
            const touchData = activeTouches.get(touch.identifier);
            activeTouches.delete(touch.identifier);

            let stillLeft = false, stillRight = false;
            for (let [id, data] of activeTouches) {
                if (data.zone === 'left') stillLeft = true;
                if (data.zone === 'right') stillRight = true;
            }

            if (!stillLeft) keys.z = false;
            if (!stillRight) keys.x = false;

            if (touchData && touchData.swiping) {
                keys.c = false;
            }
        }
    }

    document.addEventListener('touchstart', handleTouchStart, { passive: false });
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd, { passive: false });
    document.addEventListener('touchcancel', handleTouchEnd, { passive: false });

    // Mouse controls with overlay button support
    canvas.addEventListener('mousedown', (e) => {
        initAudio();
        const x = e.clientX;
        const y = e.clientY;
        const width = window.innerWidth;

        // Check overlay buttons in non-playing states
        if (gameState !== STATE_PLAYING) {
            const gameX = (x - offsetX) / scale;
            const gameY = (y - offsetY) / scale;
            const action = checkOverlayButtonHit(gameX, gameY);
            if (action) {
                overlayTap = action;
                return;
            }
            // Left/right half for flipper scroll in menus
            if (e.button === 0) {
                if (x < width * 0.5) { keys.z = true; } else { keys.x = true; }
            }
            return;
        }

        // Check mute button
        const gameX = (x - offsetX) / scale;
        const gameY = (y - offsetY) / scale;
        if (gameX >= TABLE_WIDTH - 48 && gameX <= TABLE_WIDTH - 10 && gameY >= 14 && gameY <= 34) {
            soundMuted = !soundMuted;
            try { localStorage.setItem('neonPinballMuted', soundMuted ? 'true' : 'false'); } catch (ex) {}
            return;
        }

        if (e.button === 0) {
            if (x < width * 0.5) { keys.z = true; } else { keys.x = true; }
        }
        if (e.button === 2) { keys.c = true; }
    });

    canvas.addEventListener('mouseup', (e) => {
        if (e.button === 0) { keys.z = false; keys.x = false; }
        if (e.button === 2) { keys.c = false; }
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // === INITIALIZATION ===
    loadHighScores();
    initialsChars = loadSavedInitials();
    currentInitialPos = 0;
    gameState = STATE_WELCOME;
    document.getElementById('instructions').classList.add('hidden');
    window.addEventListener('resize', resize);
    resize();
    buildTable();
    requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
